"use strict"; (self.webpackChunkangular_app = self.webpackChunkangular_app || []).push([[179], { 196: () => { function Ce(n) { return "function" == typeof n } function Zr(n) { const e = n(i => { Error.call(i), i.stack = (new Error).stack }); return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e } const Qa = Zr(n => function (e) { n(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((i, s) => `${s + 1}) ${i.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e }); function Gs(n, t) { if (n) { const e = n.indexOf(t); 0 <= e && n.splice(e, 1) } } class Qt { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: e } = this; if (e) if (this._parentage = null, Array.isArray(e)) for (const r of e) r.remove(this); else e.remove(this); const { initialTeardown: i } = this; if (Ce(i)) try { i() } catch (r) { t = r instanceof Qa ? r.errors : [r] } const { _finalizers: s } = this; if (s) { this._finalizers = null; for (const r of s) try { Em(r) } catch (o) { t = t ?? [], o instanceof Qa ? t = [...t, ...o.errors] : t.push(o) } } if (t) throw new Qa(t) } } add(t) { var e; if (t && t !== this) if (this.closed) Em(t); else { if (t instanceof Qt) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (e = this._finalizers) && void 0 !== e ? e : []).push(t) } } _hasParent(t) { const { _parentage: e } = this; return e === t || Array.isArray(e) && e.includes(t) } _addParent(t) { const { _parentage: e } = this; this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t } _removeParent(t) { const { _parentage: e } = this; e === t ? this._parentage = null : Array.isArray(e) && Gs(e, t) } remove(t) { const { _finalizers: e } = this; e && Gs(e, t), t instanceof Qt && t._removeParent(this) } } Qt.EMPTY = (() => { const n = new Qt; return n.closed = !0, n })(); const Cm = Qt.EMPTY; function Sm(n) { return n instanceof Qt || n && "closed" in n && Ce(n.remove) && Ce(n.add) && Ce(n.unsubscribe) } function Em(n) { Ce(n) ? n() : n.unsubscribe() } const os = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Za = { setTimeout(n, t, ...e) { const { delegate: i } = Za; return i?.setTimeout ? i.setTimeout(n, t, ...e) : setTimeout(n, t, ...e) }, clearTimeout(n) { const { delegate: t } = Za; return (t?.clearTimeout || clearTimeout)(n) }, delegate: void 0 }; function Mm(n) { Za.setTimeout(() => { const { onUnhandledError: t } = os; if (!t) throw n; t(n) }) } function nd() { } const O2 = id("C", void 0, void 0); function id(n, t, e) { return { kind: n, value: t, error: e } } let as = null; function Ya(n) { if (os.useDeprecatedSynchronousErrorHandling) { const t = !as; if (t && (as = { errorThrown: !1, error: null }), n(), t) { const { errorThrown: e, error: i } = as; if (as = null, e) throw i } } else n() } class sd extends Qt { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Sm(t) && t.add(this)) : this.destination = H2 } static create(t, e, i) { return new Yr(t, e, i) } next(t) { this.isStopped ? od(function F2(n) { return id("N", n, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? od(function L2(n) { return id("E", void 0, n) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? od(O2, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const j2 = Function.prototype.bind; function rd(n, t) { return j2.call(n, t) } class B2 { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: e } = this; if (e.next) try { e.next(t) } catch (i) { Xa(i) } } error(t) { const { partialObserver: e } = this; if (e.error) try { e.error(t) } catch (i) { Xa(i) } else Xa(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (e) { Xa(e) } } } class Yr extends sd { constructor(t, e, i) { let s; if (super(), Ce(t) || !t) s = { next: t ?? void 0, error: e ?? void 0, complete: i ?? void 0 }; else { let r; this && os.useDeprecatedNextContext ? (r = Object.create(t), r.unsubscribe = () => this.unsubscribe(), s = { next: t.next && rd(t.next, r), error: t.error && rd(t.error, r), complete: t.complete && rd(t.complete, r) }) : s = t } this.destination = new B2(s) } } function Xa(n) { os.useDeprecatedSynchronousErrorHandling ? function N2(n) { os.useDeprecatedSynchronousErrorHandling && as && (as.errorThrown = !0, as.error = n) }(n) : Mm(n) } function od(n, t) { const { onStoppedNotification: e } = os; e && Za.setTimeout(() => e(n, t)) } const H2 = { closed: !0, next: nd, error: function V2(n) { throw n }, complete: nd }, ad = "function" == typeof Symbol && Symbol.observable || "@@observable"; function ls(n) { return n } let $e = (() => { class n { constructor(e) { e && (this._subscribe = e) } lift(e) { const i = new n; return i.source = this, i.operator = e, i } subscribe(e, i, s) { const r = function z2(n) { return n && n instanceof sd || function $2(n) { return n && Ce(n.next) && Ce(n.error) && Ce(n.complete) }(n) && Sm(n) }(e) ? e : new Yr(e, i, s); return Ya(() => { const { operator: o, source: a } = this; r.add(o ? o.call(r, a) : a ? this._subscribe(r) : this._trySubscribe(r)) }), r } _trySubscribe(e) { try { return this._subscribe(e) } catch (i) { e.error(i) } } forEach(e, i) { return new (i = Am(i))((s, r) => { const o = new Yr({ next: a => { try { e(a) } catch (l) { r(l), o.unsubscribe() } }, error: r, complete: s }); this.subscribe(o) }) } _subscribe(e) { var i; return null === (i = this.source) || void 0 === i ? void 0 : i.subscribe(e) } [ad]() { return this } pipe(...e) { return function Tm(n) { return 0 === n.length ? ls : 1 === n.length ? n[0] : function (e) { return n.reduce((i, s) => s(i), e) } }(e)(this) } toPromise(e) { return new (e = Am(e))((i, s) => { let r; this.subscribe(o => r = o, o => s(o), () => i(r)) }) } } return n.create = t => new n(t), n })(); function Am(n) { var t; return null !== (t = n ?? os.Promise) && void 0 !== t ? t : Promise } const U2 = Zr(n => function () { n(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Ne = (() => { class n extends $e { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(e) { const i = new km(this, this); return i.operator = e, i } _throwIfClosed() { if (this.closed) throw new U2 } next(e) { Ya(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const i of this.currentObservers) i.next(e) } }) } error(e) { Ya(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = e; const { observers: i } = this; for (; i.length;)i.shift().error(e) } }) } complete() { Ya(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: e } = this; for (; e.length;)e.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var e; return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0 } _trySubscribe(e) { return this._throwIfClosed(), super._trySubscribe(e) } _subscribe(e) { return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e) } _innerSubscribe(e) { const { hasError: i, isStopped: s, observers: r } = this; return i || s ? Cm : (this.currentObservers = null, r.push(e), new Qt(() => { this.currentObservers = null, Gs(r, e) })) } _checkFinalizedStatuses(e) { const { hasError: i, thrownError: s, isStopped: r } = this; i ? e.error(s) : r && e.complete() } asObservable() { const e = new $e; return e.source = this, e } } return n.create = (t, e) => new km(t, e), n })(); class km extends Ne { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, t) } error(t) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, t) } complete() { var t, e; null === (e = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === e || e.call(t) } _subscribe(t) { var e, i; return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)) && void 0 !== i ? i : Cm } } function Im(n) { return Ce(n?.lift) } function Ye(n) { return t => { if (Im(t)) return t.lift(function (e) { try { return n(e, this) } catch (i) { this.error(i) } }); throw new TypeError("Unable to lift unknown Observable type") } } function rt(n, t, e, i, s) { return new W2(n, t, e, i, s) } class W2 extends sd { constructor(t, e, i, s, r, o) { super(t), this.onFinalize = r, this.shouldUnsubscribe = o, this._next = e ? function (a) { try { e(a) } catch (l) { t.error(l) } } : super._next, this._error = s ? function (a) { try { s(a) } catch (l) { t.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = i ? function () { try { i() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: e } = this; super.unsubscribe(), !e && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function he(n, t) { return Ye((e, i) => { let s = 0; e.subscribe(rt(i, r => { i.next(n.call(t, r, s++)) })) }) } function cs(n) { return this instanceof cs ? (this.v = n, this) : new cs(n) } function K2(n, t, e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var s, i = e.apply(n, t || []), r = []; return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function () { return this }, s; function o(h) { i[h] && (s[h] = function (f) { return new Promise(function (p, g) { r.push([h, f, p, g]) > 1 || a(h, f) }) }) } function a(h, f) { try { !function l(h) { h.value instanceof cs ? Promise.resolve(h.value.v).then(c, u) : d(r[0][2], h) }(i[h](f)) } catch (p) { d(r[0][3], p) } } function c(h) { a("next", h) } function u(h) { a("throw", h) } function d(h, f) { h(f), r.shift(), r.length && a(r[0][0], r[0][1]) } } function Q2(n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e, t = n[Symbol.asyncIterator]; return t ? t.call(n) : (n = function Om(n) { var t = "function" == typeof Symbol && Symbol.iterator, e = t && n[t], i = 0; if (e) return e.call(n); if (n && "number" == typeof n.length) return { next: function () { return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(n), e = {}, i("next"), i("throw"), i("return"), e[Symbol.asyncIterator] = function () { return this }, e); function i(r) { e[r] = n[r] && function (o) { return new Promise(function (a, l) { !function s(r, o, a, l) { Promise.resolve(l).then(function (c) { r({ value: c, done: a }) }, o) }(a, l, (o = n[r](o)).done, o.value) }) } } } const Lm = n => n && "number" == typeof n.length && "function" != typeof n; function Fm(n) { return Ce(n?.then) } function Nm(n) { return Ce(n[ad]) } function jm(n) { return Symbol.asyncIterator && Ce(n?.[Symbol.asyncIterator]) } function Bm(n) { return new TypeError(`You provided ${null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Vm = function Y2() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Hm(n) { return Ce(n?.[Vm]) } function $m(n) { return K2(this, arguments, function* () { const e = n.getReader(); try { for (; ;) { const { value: i, done: s } = yield cs(e.read()); if (s) return yield cs(void 0); yield yield cs(i) } } finally { e.releaseLock() } }) } function zm(n) { return Ce(n?.getReader) } function Sn(n) { if (n instanceof $e) return n; if (null != n) { if (Nm(n)) return function X2(n) { return new $e(t => { const e = n[ad](); if (Ce(e.subscribe)) return e.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(n); if (Lm(n)) return function J2(n) { return new $e(t => { for (let e = 0; e < n.length && !t.closed; e++)t.next(n[e]); t.complete() }) }(n); if (Fm(n)) return function eE(n) { return new $e(t => { n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, Mm) }) }(n); if (jm(n)) return Um(n); if (Hm(n)) return function tE(n) { return new $e(t => { for (const e of n) if (t.next(e), t.closed) return; t.complete() }) }(n); if (zm(n)) return function nE(n) { return Um($m(n)) }(n) } throw Bm(n) } function Um(n) { return new $e(t => { (function iE(n, t) { var e, i, s, r; return function q2(n, t, e, i) { return new (e || (e = Promise))(function (r, o) { function a(u) { try { c(i.next(u)) } catch (d) { o(d) } } function l(u) { try { c(i.throw(u)) } catch (d) { o(d) } } function c(u) { u.done ? r(u.value) : function s(r) { return r instanceof e ? r : new e(function (o) { o(r) }) }(u.value).then(a, l) } c((i = i.apply(n, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (e = Q2(n); !(i = yield e.next()).done;)if (t.next(i.value), t.closed) return } catch (o) { s = { error: o } } finally { try { i && !i.done && (r = e.return) && (yield r.call(e)) } finally { if (s) throw s.error } } t.complete() }) })(n, t).catch(e => t.error(e)) }) } function ri(n, t, e, i = 0, s = !1) { const r = t.schedule(function () { e(), s ? n.add(this.schedule(null, i)) : this.unsubscribe() }, i); if (n.add(r), !s) return r } function ht(n, t, e = 1 / 0) { return Ce(t) ? ht((i, s) => he((r, o) => t(i, r, s, o))(Sn(n(i, s))), e) : ("number" == typeof t && (e = t), Ye((i, s) => function sE(n, t, e, i, s, r, o, a) { const l = []; let c = 0, u = 0, d = !1; const h = () => { d && !l.length && !c && t.complete() }, f = g => c < i ? p(g) : l.push(g), p = g => { r && t.next(g), c++; let m = !1; Sn(e(g, u++)).subscribe(rt(t, y => { s?.(y), r ? f(y) : t.next(y) }, () => { m = !0 }, void 0, () => { if (m) try { for (c--; l.length && c < i;) { const y = l.shift(); o ? ri(t, o, () => p(y)) : p(y) } h() } catch (y) { t.error(y) } })) }; return n.subscribe(rt(t, f, () => { d = !0, h() })), () => { a?.() } }(i, s, n, e))) } function Ks(n = 1 / 0) { return ht(ls, n) } const oi = new $e(n => n.complete()); function Wm(n) { return n && Ce(n.schedule) } function cd(n) { return n[n.length - 1] } function qm(n) { return Ce(cd(n)) ? n.pop() : void 0 } function Xr(n) { return Wm(cd(n)) ? n.pop() : void 0 } function Gm(n, t = 0) { return Ye((e, i) => { e.subscribe(rt(i, s => ri(i, n, () => i.next(s), t), () => ri(i, n, () => i.complete(), t), s => ri(i, n, () => i.error(s), t))) }) } function Km(n, t = 0) { return Ye((e, i) => { i.add(n.schedule(() => e.subscribe(i), t)) }) } function Qm(n, t) { if (!n) throw new Error("Iterable cannot be null"); return new $e(e => { ri(e, t, () => { const i = n[Symbol.asyncIterator](); ri(e, t, () => { i.next().then(s => { s.done ? e.complete() : e.next(s.value) }) }, 0, !0) }) }) } function ft(n, t) { return t ? function hE(n, t) { if (null != n) { if (Nm(n)) return function aE(n, t) { return Sn(n).pipe(Km(t), Gm(t)) }(n, t); if (Lm(n)) return function cE(n, t) { return new $e(e => { let i = 0; return t.schedule(function () { i === n.length ? e.complete() : (e.next(n[i++]), e.closed || this.schedule()) }) }) }(n, t); if (Fm(n)) return function lE(n, t) { return Sn(n).pipe(Km(t), Gm(t)) }(n, t); if (jm(n)) return Qm(n, t); if (Hm(n)) return function uE(n, t) { return new $e(e => { let i; return ri(e, t, () => { i = n[Vm](), ri(e, t, () => { let s, r; try { ({ value: s, done: r } = i.next()) } catch (o) { return void e.error(o) } r ? e.complete() : e.next(s) }, 0, !0) }), () => Ce(i?.return) && i.return() }) }(n, t); if (zm(n)) return function dE(n, t) { return Qm($m(n), t) }(n, t) } throw Bm(n) }(n, t) : Sn(n) } function $n(...n) { const t = Xr(n), e = function oE(n, t) { return "number" == typeof cd(n) ? n.pop() : t }(n, 1 / 0), i = n; return i.length ? 1 === i.length ? Sn(i[0]) : Ks(e)(ft(i, t)) : oi } function Zm(n = {}) { const { connector: t = (() => new Ne), resetOnError: e = !0, resetOnComplete: i = !0, resetOnRefCountZero: s = !0 } = n; return r => { let o, a, l, c = 0, u = !1, d = !1; const h = () => { a?.unsubscribe(), a = void 0 }, f = () => { h(), o = l = void 0, u = d = !1 }, p = () => { const g = o; f(), g?.unsubscribe() }; return Ye((g, m) => { c++, !d && !u && h(); const y = l = l ?? t(); m.add(() => { c--, 0 === c && !d && !u && (a = ud(p, s)) }), y.subscribe(m), !o && c > 0 && (o = new Yr({ next: b => y.next(b), error: b => { d = !0, h(), a = ud(f, e, b), y.error(b) }, complete: () => { u = !0, h(), a = ud(f, i), y.complete() } }), Sn(g).subscribe(o)) })(r) } } function ud(n, t, ...e) { if (!0 === t) return void n(); if (!1 === t) return; const i = new Yr({ next: () => { i.unsubscribe(), n() } }); return t(...e).subscribe(i) } function Ee(n) { for (let t in n) if (n[t] === Ee) return t; throw Error("Could not find renamed property on target object.") } function Me(n) { if ("string" == typeof n) return n; if (Array.isArray(n)) return "[" + n.map(Me).join(", ") + "]"; if (null == n) return "" + n; if (n.overriddenName) return `${n.overriddenName}`; if (n.name) return `${n.name}`; const t = n.toString(); if (null == t) return "" + t; const e = t.indexOf("\n"); return -1 === e ? t : t.substring(0, e) } function hd(n, t) { return null == n || "" === n ? null === t ? "" : t : null == t || "" === t ? n : n + " " + t } const fE = Ee({ __forward_ref__: Ee }); function fd(n) { return n.__forward_ref__ = fd, n.toString = function () { return Me(this()) }, n } function Q(n) { return pd(n) ? n() : n } function pd(n) { return "function" == typeof n && n.hasOwnProperty(fE) && n.__forward_ref__ === fd } class T extends Error { constructor(t, e) { super(function Ja(n, t) { return `NG0${Math.abs(n)}${t ? ": " + t.trim() : ""}` }(t, e)), this.code = t } } function Y(n) { return "string" == typeof n ? n : null == n ? "" : String(n) } function el(n, t) { throw new T(-201, !1) } function Yt(n, t) { null == n && function we(n, t, e, i) { throw new Error(`ASSERTION ERROR: ${n}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${t} <=Actual]`)) }(t, n, null, "!=") } function V(n) { return { token: n.token, providedIn: n.providedIn || null, factory: n.factory, value: void 0 } } function Xt(n) { return { providers: n.providers || [], imports: n.imports || [] } } function gd(n) { return Ym(n, tl) || Ym(n, Jm) } function Ym(n, t) { return n.hasOwnProperty(t) ? n[t] : null } function Xm(n) { return n && (n.hasOwnProperty(md) || n.hasOwnProperty(wE)) ? n[md] : null } const tl = Ee({ \u0275prov: Ee }), md = Ee({ \u0275inj: Ee }), Jm = Ee({ ngInjectableDef: Ee }), wE = Ee({ ngInjectorDef: Ee }); var U = (() => ((U = U || {})[U.Default = 0] = "Default", U[U.Host = 1] = "Host", U[U.Self = 2] = "Self", U[U.SkipSelf = 4] = "SkipSelf", U[U.Optional = 8] = "Optional", U))(); let yd; function zn(n) { const t = yd; return yd = n, t } function ey(n, t, e) { const i = gd(n); return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : e & U.Optional ? null : void 0 !== t ? t : void el(Me(n)) } function Oi(n) { return { toString: n }.toString() } var En = (() => ((En = En || {})[En.OnPush = 0] = "OnPush", En[En.Default = 1] = "Default", En))(), Mn = (() => { return (n = Mn || (Mn = {}))[n.Emulated = 0] = "Emulated", n[n.None = 2] = "None", n[n.ShadowDom = 3] = "ShadowDom", Mn; var n })(); const Se = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), Qs = {}, be = [], nl = Ee({ \u0275cmp: Ee }), vd = Ee({ \u0275dir: Ee }), _d = Ee({ \u0275pipe: Ee }), ty = Ee({ \u0275mod: Ee }), li = Ee({ \u0275fac: Ee }), Jr = Ee({ __NG_ELEMENT_ID__: Ee }); let xE = 0; function Un(n) { return Oi(() => { const e = !0 === n.standalone, i = {}, s = { type: n.type, providersResolver: null, decls: n.decls, vars: n.vars, factory: null, template: n.template || null, consts: n.consts || null, ngContentSelectors: n.ngContentSelectors, hostBindings: n.hostBindings || null, hostVars: n.hostVars || 0, hostAttrs: n.hostAttrs || null, contentQueries: n.contentQueries || null, declaredInputs: i, inputs: null, outputs: null, exportAs: n.exportAs || null, onPush: n.changeDetection === En.OnPush, directiveDefs: null, pipeDefs: null, standalone: e, dependencies: e && n.dependencies || null, getStandaloneInjector: null, selectors: n.selectors || be, viewQuery: n.viewQuery || null, features: n.features || null, data: n.data || {}, encapsulation: n.encapsulation || Mn.Emulated, id: "c" + xE++, styles: n.styles || be, _: null, setInput: null, schemas: n.schemas || null, tView: null }, r = n.dependencies, o = n.features; return s.inputs = sy(n.inputs, i), s.outputs = sy(n.outputs), o && o.forEach(a => a(s)), s.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(ny).filter(iy) : null, s.pipeDefs = r ? () => ("function" == typeof r ? r() : r).map(Rt).filter(iy) : null, s }) } function ny(n) { return ke(n) || Pt(n) } function iy(n) { return null !== n } const SE = {}; function un(n) { return Oi(() => { const t = { type: n.type, bootstrap: n.bootstrap || be, declarations: n.declarations || be, imports: n.imports || be, exports: n.exports || be, transitiveCompileScopes: null, schemas: n.schemas || null, id: n.id || null }; return null != n.id && (SE[n.id] = n.type), t }) } function sy(n, t) { if (null == n) return Qs; const e = {}; for (const i in n) if (n.hasOwnProperty(i)) { let s = n[i], r = s; Array.isArray(s) && (r = s[1], s = s[0]), e[s] = i, t && (t[s] = r) } return e } const mt = Un; function It(n) { return { type: n.type, name: n.name, factory: null, pure: !1 !== n.pure, standalone: !0 === n.standalone, onDestroy: n.type.prototype.ngOnDestroy || null } } function ke(n) { return n[nl] || null } function Pt(n) { return n[vd] || null } function Rt(n) { return n[_d] || null } function Jt(n, t) { const e = n[ty] || null; if (!e && !0 === t) throw new Error(`Type ${Me(n)} does not have '\u0275mod' property.`); return e } function $t(n) { return Array.isArray(n) && "object" == typeof n[1] } function An(n) { return Array.isArray(n) && !0 === n[1] } function Dd(n) { return 0 != (8 & n.flags) } function ol(n) { return 2 == (2 & n.flags) } function al(n) { return 1 == (1 & n.flags) } function kn(n) { return null !== n.template } function kE(n) { return 0 != (256 & n[2]) } function ps(n, t) { return n.hasOwnProperty(li) ? n[li] : null } class RE { constructor(t, e, i) { this.previousValue = t, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } } function Li() { return ay } function ay(n) { return n.type.prototype.ngOnChanges && (n.setInput = LE), OE } function OE() { const n = cy(this), t = n?.current; if (t) { const e = n.previous; if (e === Qs) n.previous = t; else for (let i in t) e[i] = t[i]; n.current = null, this.ngOnChanges(t) } } function LE(n, t, e, i) { const s = cy(n) || function FE(n, t) { return n[ly] = t }(n, { previous: Qs, current: null }), r = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[e], l = o[a]; r[a] = new RE(l && l.currentValue, t, o === Qs), n[i] = t } Li.ngInherit = !0; const ly = "__ngSimpleChanges__"; function cy(n) { return n[ly] || null } function Xe(n) { for (; Array.isArray(n);)n = n[0]; return n } function fn(n, t) { return Xe(t[n.index]) } function Md(n, t) { return n.data[t] } function er(n, t) { return n[t] } function tn(n, t) { const e = t[n]; return $t(e) ? e : e[0] } function uy(n) { return 4 == (4 & n[2]) } function Td(n) { return 64 == (64 & n[2]) } function Fi(n, t) { return null == t ? null : n[t] } function dy(n) { n[18] = 0 } function Ad(n, t) { n[5] += t; let e = n, i = n[3]; for (; null !== i && (1 === t && 1 === e[5] || -1 === t && 0 === e[5]);)i[5] += t, e = i, i = i[3] } const Z = { lFrame: by(null), bindingsEnabled: !0 }; function fy() { return Z.bindingsEnabled } function E() { return Z.lFrame.lView } function me() { return Z.lFrame.tView } function xt(n) { return Z.lFrame.contextLView = n, n[8] } function Ct(n) { return Z.lFrame.contextLView = null, n } function ot() { let n = py(); for (; null !== n && 64 === n.type;)n = n.parent; return n } function py() { return Z.lFrame.currentTNode } function Wn(n, t) { const e = Z.lFrame; e.currentTNode = n, e.isParent = t } function kd() { return Z.lFrame.isParent } function Id() { Z.lFrame.isParent = !1 } function Ot() { const n = Z.lFrame; let t = n.bindingRootIndex; return -1 === t && (t = n.bindingRootIndex = n.tView.bindingStartIndex), t } function tr() { return Z.lFrame.bindingIndex++ } function ZE(n, t) { const e = Z.lFrame; e.bindingIndex = e.bindingRootIndex = n, Pd(t) } function Pd(n) { Z.lFrame.currentDirectiveIndex = n } function yy() { return Z.lFrame.currentQueryIndex } function Od(n) { Z.lFrame.currentQueryIndex = n } function XE(n) { const t = n[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? n[6] : null } function vy(n, t, e) { if (e & U.SkipSelf) { let s = t, r = n; for (; !(s = s.parent, null !== s || e & U.Host || (s = XE(r), null === s || (r = r[15], 10 & s.type)));); if (null === s) return !1; t = s, n = r } const i = Z.lFrame = _y(); return i.currentTNode = t, i.lView = n, !0 } function Ld(n) { const t = _y(), e = n[1]; Z.lFrame = t, t.currentTNode = e.firstChild, t.lView = n, t.tView = e, t.contextLView = n, t.bindingIndex = e.bindingStartIndex, t.inI18n = !1 } function _y() { const n = Z.lFrame, t = null === n ? null : n.child; return null === t ? by(n) : t } function by(n) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: n, child: null, inI18n: !1 }; return null !== n && (n.child = t), t } function wy() { const n = Z.lFrame; return Z.lFrame = n.parent, n.currentTNode = null, n.lView = null, n } const Dy = wy; function Fd() { const n = wy(); n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null, n.elementDepthCount = 0, n.currentDirectiveIndex = -1, n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1, n.currentQueryIndex = 0 } function Lt() { return Z.lFrame.selectedIndex } function Ni(n) { Z.lFrame.selectedIndex = n } function We() { const n = Z.lFrame; return Md(n.tView, n.selectedIndex) } function Je() { Z.lFrame.currentNamespace = "svg" } function yt() { !function nM() { Z.lFrame.currentNamespace = null }() } function ul(n, t) { for (let e = t.directiveStart, i = t.directiveEnd; e < i; e++) { const r = n.data[e].type.prototype, { ngAfterContentInit: o, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: u } = r; o && (n.contentHooks || (n.contentHooks = [])).push(-e, o), a && ((n.contentHooks || (n.contentHooks = [])).push(e, a), (n.contentCheckHooks || (n.contentCheckHooks = [])).push(e, a)), l && (n.viewHooks || (n.viewHooks = [])).push(-e, l), c && ((n.viewHooks || (n.viewHooks = [])).push(e, c), (n.viewCheckHooks || (n.viewCheckHooks = [])).push(e, c)), null != u && (n.destroyHooks || (n.destroyHooks = [])).push(e, u) } } function dl(n, t, e) { xy(n, t, 3, e) } function hl(n, t, e, i) { (3 & n[2]) === e && xy(n, t, e, i) } function Nd(n, t) { let e = n[2]; (3 & e) === t && (e &= 2047, e += 1, n[2] = e) } function xy(n, t, e, i) { const r = i ?? -1, o = t.length - 1; let a = 0; for (let l = void 0 !== i ? 65535 & n[18] : 0; l < o; l++)if ("number" == typeof t[l + 1]) { if (a = t[l], null != i && a >= i) break } else t[l] < 0 && (n[18] += 65536), (a < r || -1 == r) && (rM(n, e, t, l), n[18] = (4294901760 & n[18]) + l + 2), l++ } function rM(n, t, e, i) { const s = e[i] < 0, r = e[i + 1], a = n[s ? -e[i] : e[i]]; if (s) { if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === t) { n[2] += 2048; try { r.call(a) } finally { } } } else try { r.call(a) } finally { } } class so { constructor(t, e, i) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } } function fl(n, t, e) { let i = 0; for (; i < e.length;) { const s = e[i]; if ("number" == typeof s) { if (0 !== s) break; i++; const r = e[i++], o = e[i++], a = e[i++]; n.setAttribute(t, o, a, r) } else { const r = s, o = e[++i]; Sy(r) ? n.setProperty(t, r, o) : n.setAttribute(t, r, o), i++ } } return i } function Cy(n) { return 3 === n || 4 === n || 6 === n } function Sy(n) { return 64 === n.charCodeAt(0) } function pl(n, t) { if (null !== t && 0 !== t.length) if (null === n || 0 === n.length) n = t.slice(); else { let e = -1; for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? e = s : 0 === e || Ey(n, e, s, null, -1 === e || 2 === e ? t[++i] : null) } } return n } function Ey(n, t, e, i, s) { let r = 0, o = n.length; if (-1 === t) o = -1; else for (; r < n.length;) { const a = n[r++]; if ("number" == typeof a) { if (a === t) { o = -1; break } if (a > t) { o = r - 1; break } } } for (; r < n.length;) { const a = n[r]; if ("number" == typeof a) break; if (a === e) { if (null === i) return void (null !== s && (n[r + 1] = s)); if (i === n[r + 1]) return void (n[r + 2] = s) } r++, null !== i && r++, null !== s && r++ } -1 !== o && (n.splice(o, 0, t), r = o + 1), n.splice(r++, 0, e), null !== i && n.splice(r++, 0, i), null !== s && n.splice(r++, 0, s) } function My(n) { return -1 !== n } function nr(n) { return 32767 & n } function ir(n, t) { let e = function uM(n) { return n >> 16 }(n), i = t; for (; e > 0;)i = i[15], e--; return i } let Bd = !0; function gl(n) { const t = Bd; return Bd = n, t } let dM = 0; const qn = {}; function oo(n, t) { const e = Hd(n, t); if (-1 !== e) return e; const i = t[1]; i.firstCreatePass && (n.injectorIndex = t.length, Vd(i.data, n), Vd(t, null), Vd(i.blueprint, null)); const s = ml(n, t), r = n.injectorIndex; if (My(s)) { const o = nr(s), a = ir(s, t), l = a[1].data; for (let c = 0; c < 8; c++)t[r + c] = a[o + c] | l[o + c] } return t[r + 8] = s, r } function Vd(n, t) { n.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function Hd(n, t) { return -1 === n.injectorIndex || n.parent && n.parent.injectorIndex === n.injectorIndex || null === t[n.injectorIndex + 8] ? -1 : n.injectorIndex } function ml(n, t) { if (n.parent && -1 !== n.parent.injectorIndex) return n.parent.injectorIndex; let e = 0, i = null, s = t; for (; null !== s;) { if (i = Fy(s), null === i) return -1; if (e++, s = s[15], -1 !== i.injectorIndex) return i.injectorIndex | e << 16 } return -1 } function yl(n, t, e) { !function hM(n, t, e) { let i; "string" == typeof e ? i = e.charCodeAt(0) || 0 : e.hasOwnProperty(Jr) && (i = e[Jr]), null == i && (i = e[Jr] = dM++); const s = 255 & i; t.data[n + (s >> 5)] |= 1 << s }(n, t, e) } function ky(n, t, e) { if (e & U.Optional) return n; el() } function Iy(n, t, e, i) { if (e & U.Optional && void 0 === i && (i = null), 0 == (e & (U.Self | U.Host))) { const s = n[9], r = zn(void 0); try { return s ? s.get(t, i, e & U.Optional) : ey(t, i, e & U.Optional) } finally { zn(r) } } return ky(i, 0, e) } function Py(n, t, e, i = U.Default, s) { if (null !== n) { if (1024 & t[2]) { const o = function yM(n, t, e, i, s) { let r = n, o = t; for (; null !== r && null !== o && 1024 & o[2] && !(256 & o[2]);) { const a = Ry(r, o, e, i | U.Self, qn); if (a !== qn) return a; let l = r.parent; if (!l) { const c = o[21]; if (c) { const u = c.get(e, qn, i); if (u !== qn) return u } l = Fy(o), o = o[15] } r = l } return s }(n, t, e, i, qn); if (o !== qn) return o } const r = Ry(n, t, e, i, qn); if (r !== qn) return r } return Iy(t, e, i, s) } function Ry(n, t, e, i, s) { const r = function gM(n) { if ("string" == typeof n) return n.charCodeAt(0) || 0; const t = n.hasOwnProperty(Jr) ? n[Jr] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : mM : t }(e); if ("function" == typeof r) { if (!vy(t, n, i)) return i & U.Host ? ky(s, 0, i) : Iy(t, e, i, s); try { const o = r(i); if (null != o || i & U.Optional) return o; el() } finally { Dy() } } else if ("number" == typeof r) { let o = null, a = Hd(n, t), l = -1, c = i & U.Host ? t[16][6] : null; for ((-1 === a || i & U.SkipSelf) && (l = -1 === a ? ml(n, t) : t[a + 8], -1 !== l && Ly(i, !1) ? (o = t[1], a = nr(l), t = ir(l, t)) : a = -1); -1 !== a;) { const u = t[1]; if (Oy(r, a, u.data)) { const d = pM(a, t, e, o, i, c); if (d !== qn) return d } l = t[a + 8], -1 !== l && Ly(i, t[1].data[a + 8] === c) && Oy(r, a, t) ? (o = u, a = nr(l), t = ir(l, t)) : a = -1 } } return s } function pM(n, t, e, i, s, r) { const o = t[1], a = o.data[n + 8], u = vl(a, o, e, null == i ? ol(a) && Bd : i != o && 0 != (3 & a.type), s & U.Host && r === a); return null !== u ? ao(t, o, u, a) : qn } function vl(n, t, e, i, s) { const r = n.providerIndexes, o = t.data, a = 1048575 & r, l = n.directiveStart, u = r >> 20, h = s ? a + u : n.directiveEnd; for (let f = i ? a : a + u; f < h; f++) { const p = o[f]; if (f < l && e === p || f >= l && p.type === e) return f } if (s) { const f = o[l]; if (f && kn(f) && f.type === e) return l } return null } function ao(n, t, e, i) { let s = n[e]; const r = t.data; if (function oM(n) { return n instanceof so }(s)) { const o = s; o.resolving && function pE(n, t) { const e = t ? `. Dependency path: ${t.join(" > ")} > ${n}` : ""; throw new T(-200, `Circular dependency in DI detected for ${n}${e}`) }(function _e(n) { return "function" == typeof n ? n.name || n.toString() : "object" == typeof n && null != n && "function" == typeof n.type ? n.type.name || n.type.toString() : Y(n) }(r[e])); const a = gl(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? zn(o.injectImpl) : null; vy(n, i, U.Default); try { s = n[e] = o.factory(void 0, r, n, i), t.firstCreatePass && e >= i.directiveStart && function sM(n, t, e) { const { ngOnChanges: i, ngOnInit: s, ngDoCheck: r } = t.type.prototype; if (i) { const o = ay(t); (e.preOrderHooks || (e.preOrderHooks = [])).push(n, o), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, o) } s && (e.preOrderHooks || (e.preOrderHooks = [])).push(0 - n, s), r && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n, r), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, r)) }(e, r[e], t) } finally { null !== l && zn(l), gl(a), o.resolving = !1, Dy() } } return s } function Oy(n, t, e) { return !!(e[t + (n >> 5)] & 1 << n) } function Ly(n, t) { return !(n & U.Self || n & U.Host && t) } class sr { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e, i) { return Py(this._tNode, this._lView, t, i, e) } } function mM() { return new sr(ot(), E()) } function _l(n) { return Oi(() => { const t = n.prototype.constructor, e = t[li] || $d(t), i = Object.prototype; let s = Object.getPrototypeOf(n.prototype).constructor; for (; s && s !== i;) { const r = s[li] || $d(s); if (r && r !== e) return r; s = Object.getPrototypeOf(s) } return r => new r }) } function $d(n) { return pd(n) ? () => { const t = $d(Q(n)); return t && t() } : ps(n) } function Fy(n) { const t = n[1], e = t.type; return 2 === e ? t.declTNode : 1 === e ? n[6] : null } function lo(n) { return function fM(n, t) { if ("class" === t) return n.classes; if ("style" === t) return n.styles; const e = n.attrs; if (e) { const i = e.length; let s = 0; for (; s < i;) { const r = e[s]; if (Cy(r)) break; if (0 === r) s += 2; else if ("number" == typeof r) for (s++; s < i && "string" == typeof e[s];)s++; else { if (r === t) return e[s + 1]; s += 2 } } } return null }(ot(), n) } const or = "__parameters__"; function lr(n, t, e) { return Oi(() => { const i = function zd(n) { return function (...e) { if (n) { const i = n(...e); for (const s in i) this[s] = i[s] } } }(t); function s(...r) { if (this instanceof s) return i.apply(this, r), this; const o = new s(...r); return a.annotation = o, a; function a(l, c, u) { const d = l.hasOwnProperty(or) ? l[or] : Object.defineProperty(l, or, { value: [] })[or]; for (; d.length <= u;)d.push(null); return (d[u] = d[u] || []).push(o), l } } return e && (s.prototype = Object.create(e.prototype)), s.prototype.ngMetadataName = n, s.annotationCls = s, s }) } class W { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = V({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const _M = new W("AnalyzeForEntryComponents"); function nn(n, t) { void 0 === t && (t = n); for (let e = 0; e < n.length; e++) { let i = n[e]; Array.isArray(i) ? (t === n && (t = n.slice(0, e)), nn(i, t)) : t !== n && t.push(i) } return t } function di(n, t) { n.forEach(e => Array.isArray(e) ? di(e, t) : t(e)) } function jy(n, t, e) { t >= n.length ? n.push(e) : n.splice(t, 0, e) } function bl(n, t) { return t >= n.length - 1 ? n.pop() : n.splice(t, 1)[0] } const fo = {}, Gd = "__NG_DI_FLAG__", Dl = "ngTempTokenPath", kM = /\n/gm, $y = "__source"; let po; function xl(n) { const t = po; return po = n, t } function PM(n, t = U.Default) { if (void 0 === po) throw new T(-203, !1); return null === po ? ey(n, void 0, t) : po.get(n, t & U.Optional ? null : void 0, t) } function k(n, t = U.Default) { return (function DE() { return yd }() || PM)(Q(n), t) } function gs(n, t = U.Default) { return k(n, t) } function Kd(n) { const t = []; for (let e = 0; e < n.length; e++) { const i = Q(n[e]); if (Array.isArray(i)) { if (0 === i.length) throw new T(900, !1); let s, r = U.Default; for (let o = 0; o < i.length; o++) { const a = i[o], l = RM(a); "number" == typeof l ? -1 === l ? s = a.token : r |= l : s = a } t.push(k(s, r)) } else t.push(k(i)) } return t } function go(n, t) { return n[Gd] = t, n.prototype[Gd] = t, n } function RM(n) { return n[Gd] } const Bi = go(lr("Optional"), 8), mo = go(lr("SkipSelf"), 4); let Zd, El, Ml; function dr(n) { return function Yd() { if (void 0 === El && (El = null, Se.trustedTypes)) try { El = Se.trustedTypes.createPolicy("angular", { createHTML: n => n, createScript: n => n, createScriptURL: n => n }) } catch { } return El }()?.createHTML(n) || n } function Xy(n) { return function Xd() { if (void 0 === Ml && (Ml = null, Se.trustedTypes)) try { Ml = Se.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: n => n, createScript: n => n, createScriptURL: n => n }) } catch { } return Ml }()?.createHTML(n) || n } class tv { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } function Vi(n) { return n instanceof tv ? n.changingThisBreaksApplicationSecurity : n } function _o(n, t) { const e = function JM(n) { return n instanceof tv && n.getTypeName() || null }(n); if (null != e && e !== t) { if ("ResourceURL" === e && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${e} (see https://g.co/ng/security#xss)`) } return e === t } class eT { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(dr(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch { return null } } } class tT { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const e = this.inertDocument.createElement("html"); this.inertDocument.appendChild(e); const i = this.inertDocument.createElement("body"); e.appendChild(i) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = dr(t), e; const i = this.inertDocument.createElement("body"); return i.innerHTML = dr(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(i), i } stripCustomNsAttrs(t) { const e = t.attributes; for (let s = e.length - 1; 0 < s; s--) { const o = e.item(s).name; ("xmlns:ns1" === o || 0 === o.indexOf("ns1:")) && t.removeAttribute(o) } let i = t.firstChild; for (; i;)i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i), i = i.nextSibling } } const iT = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, sT = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Tl(n) { return (n = String(n)).match(iT) || n.match(sT) ? n : "unsafe:" + n } function Gn(n) { const t = {}; for (const e of n.split(",")) t[e] = !0; return t } function bo(...n) { const t = {}; for (const e of n) for (const i in e) e.hasOwnProperty(i) && (t[i] = !0); return t } const sv = Gn("area,br,col,hr,img,wbr"), rv = Gn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), ov = Gn("rp,rt"), Jd = bo(sv, bo(rv, Gn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), bo(ov, Gn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), bo(ov, rv)), eh = Gn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), th = Gn("srcset"), av = bo(eh, th, Gn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Gn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), rT = Gn("script,style,template"); class oT { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, i = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let s = this.checkClobberedElement(e, e.nextSibling); if (s) { e = s; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Jd.hasOwnProperty(e)) return this.sanitizedSomething = !0, !rT.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const i = t.attributes; for (let s = 0; s < i.length; s++) { const r = i.item(s), o = r.name, a = o.toLowerCase(); if (!av.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = r.value; eh[a] && (l = Tl(l)), th[a] && (n = l, l = (n = String(n)).split(",").map(t => Tl(t.trim())).join(", ")), this.buf.push(" ", o, '="', lv(l), '"') } var n; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); Jd.hasOwnProperty(e) && !sv.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(lv(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const aT = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, lT = /([^\#-~ |!])/g; function lv(n) { return n.replace(/&/g, "&amp;").replace(aT, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(lT, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Al; function nh(n) { return "content" in n && function uT(n) { return n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName }(n) ? n.content : null } var et = (() => ((et = et || {})[et.NONE = 0] = "NONE", et[et.HTML = 1] = "HTML", et[et.STYLE = 2] = "STYLE", et[et.SCRIPT = 3] = "SCRIPT", et[et.URL = 4] = "URL", et[et.RESOURCE_URL = 5] = "RESOURCE_URL", et))(); function kl(n) { const t = wo(); return t ? Xy(t.sanitize(et.HTML, n) || "") : _o(n, "HTML") ? Xy(Vi(n)) : function cT(n, t) { let e = null; try { Al = Al || function nv(n) { const t = new tT(n); return function nT() { try { return !!(new window.DOMParser).parseFromString(dr(""), "text/html") } catch { return !1 } }() ? new eT(t) : t }(n); let i = t ? String(t) : ""; e = Al.getInertBodyElement(i); let s = 5, r = i; do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable"); s--, i = r, r = e.innerHTML, e = Al.getInertBodyElement(i) } while (i !== r); return dr((new oT).sanitizeChildren(nh(e) || e)) } finally { if (e) { const i = nh(e) || e; for (; i.firstChild;)i.removeChild(i.firstChild) } } }(function Yy() { return void 0 !== Zd ? Zd : typeof document < "u" ? document : void 0 }(), Y(n)) } function hr(n) { const t = wo(); return t ? t.sanitize(et.URL, n) || "" : _o(n, "URL") ? Vi(n) : Tl(Y(n)) } function wo() { const n = E(); return n && n[12] } function sh(n) { return n.ngOriginalError } class ms { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t); this._console.error("ERROR", t), e && this._console.error("ORIGINAL ERROR", e) } _findOriginalError(t) { let e = t && sh(t); for (; e && sh(e);)e = sh(e); return e || null } } const rh = new Map; let ST = 0; const ah = "__ngContext__"; function St(n, t) { $t(t) ? (n[ah] = t[20], function MT(n) { rh.set(n[20], n) }(t)) : n[ah] = t } function Do(n) { const t = n[ah]; return "number" == typeof t ? function dv(n) { return rh.get(n) || null }(t) : t || null } function lh(n) { const t = Do(n); return t ? $t(t) ? t : t.lView : null } const FT = (() => (typeof requestAnimationFrame < "u" && requestAnimationFrame || setTimeout).bind(Se))(); function mv(n) { return n.ownerDocument } function hi(n) { return n instanceof Function ? n() : n } var zt = (() => ((zt = zt || {})[zt.Important = 1] = "Important", zt[zt.DashCase = 2] = "DashCase", zt))(); function uh(n, t) { return undefined(n, t) } function xo(n) { const t = n[3]; return An(t) ? t[3] : t } function dh(n) { return bv(n[13]) } function hh(n) { return bv(n[4]) } function bv(n) { for (; null !== n && !An(n);)n = n[4]; return n } function pr(n, t, e, i, s) { if (null != i) { let r, o = !1; An(i) ? r = i : $t(i) && (o = !0, i = i[0]); const a = Xe(i); 0 === n && null !== e ? null == s ? Ev(t, e, a) : ys(t, e, a, s || null, !0) : 1 === n && null !== e ? ys(t, e, a, s || null, !0) : 2 === n ? function Rv(n, t, e) { const i = Il(n, t); i && function XT(n, t, e, i) { n.removeChild(t, e, i) }(n, i, t, e) }(t, a, o) : 3 === n && t.destroyNode(a), null != r && function tA(n, t, e, i, s) { const r = e[7]; r !== Xe(e) && pr(t, n, i, r, s); for (let a = 10; a < e.length; a++) { const l = e[a]; Co(l[1], l, n, t, i, r) } }(t, n, r, e, s) } } function ph(n, t, e) { return n.createElement(t, e) } function Dv(n, t) { const e = n[9], i = e.indexOf(t), s = t[3]; 512 & t[2] && (t[2] &= -513, Ad(s, -1)), e.splice(i, 1) } function gh(n, t) { if (n.length <= 10) return; const e = 10 + t, i = n[e]; if (i) { const s = i[17]; null !== s && s !== n && Dv(s, i), t > 0 && (n[e - 1][4] = i[4]); const r = bl(n, 10 + t); !function UT(n, t) { Co(n, t, t[11], 2, null, null), t[0] = null, t[6] = null }(i[1], i); const o = r[19]; null !== o && o.detachView(r[1]), i[3] = null, i[4] = null, i[2] &= -65 } return i } function xv(n, t) { if (!(128 & t[2])) { const e = t[11]; e.destroyNode && Co(n, t, e, 3, null, null), function GT(n) { let t = n[13]; if (!t) return mh(n[1], n); for (; t;) { let e = null; if ($t(t)) e = t[13]; else { const i = t[10]; i && (e = i) } if (!e) { for (; t && !t[4] && t !== n;)$t(t) && mh(t[1], t), t = t[3]; null === t && (t = n), $t(t) && mh(t[1], t), e = t && t[4] } t = e } }(t) } } function mh(n, t) { if (!(128 & t[2])) { t[2] &= -65, t[2] |= 128, function YT(n, t) { let e; if (null != n && null != (e = n.destroyHooks)) for (let i = 0; i < e.length; i += 2) { const s = t[e[i]]; if (!(s instanceof so)) { const r = e[i + 1]; if (Array.isArray(r)) for (let o = 0; o < r.length; o += 2) { const a = s[r[o]], l = r[o + 1]; try { l.call(a) } finally { } } else try { r.call(s) } finally { } } } }(n, t), function ZT(n, t) { const e = n.cleanup, i = t[7]; let s = -1; if (null !== e) for (let r = 0; r < e.length - 1; r += 2)if ("string" == typeof e[r]) { const o = e[r + 1], a = "function" == typeof o ? o(t) : Xe(t[o]), l = i[s = e[r + 2]], c = e[r + 3]; "boolean" == typeof c ? a.removeEventListener(e[r], l, c) : c >= 0 ? i[s = c]() : i[s = -c].unsubscribe(), r += 2 } else { const o = i[s = e[r + 1]]; e[r].call(o) } if (null !== i) { for (let r = s + 1; r < i.length; r++)i[r](); t[7] = null } }(n, t), 1 === t[1].type && t[11].destroy(); const e = t[17]; if (null !== e && An(t[3])) { e !== t[3] && Dv(e, t); const i = t[19]; null !== i && i.detachView(n) } !function TT(n) { rh.delete(n[20]) }(t) } } function Cv(n, t, e) { return function Sv(n, t, e) { let i = t; for (; null !== i && 40 & i.type;)i = (t = i).parent; if (null === i) return e[0]; if (2 & i.flags) { const s = n.data[i.directiveStart].encapsulation; if (s === Mn.None || s === Mn.Emulated) return null } return fn(i, e) }(n, t.parent, e) } function ys(n, t, e, i, s) { n.insertBefore(t, e, i, s) } function Ev(n, t, e) { n.appendChild(t, e) } function Mv(n, t, e, i, s) { null !== i ? ys(n, t, e, i, s) : Ev(n, t, e) } function Il(n, t) { return n.parentNode(t) } let kv = function Av(n, t, e) { return 40 & n.type ? fn(n, e) : null }; function Pl(n, t, e, i) { const s = Cv(n, i, t), r = t[11], a = function Tv(n, t, e) { return kv(n, t, e) }(i.parent || t[6], i, t); if (null != s) if (Array.isArray(e)) for (let l = 0; l < e.length; l++)Mv(r, s, e[l], a, !1); else Mv(r, s, e, a, !1) } function Rl(n, t) { if (null !== t) { const e = t.type; if (3 & e) return fn(t, n); if (4 & e) return vh(-1, n[t.index]); if (8 & e) { const i = t.child; if (null !== i) return Rl(n, i); { const s = n[t.index]; return An(s) ? vh(-1, s) : Xe(s) } } if (32 & e) return uh(t, n)() || Xe(n[t.index]); { const i = Pv(n, t); return null !== i ? Array.isArray(i) ? i[0] : Rl(xo(n[16]), i) : Rl(n, t.next) } } return null } function Pv(n, t) { return null !== t ? n[16][6].projection[t.projection] : null } function vh(n, t) { const e = 10 + n + 1; if (e < t.length) { const i = t[e], s = i[1].firstChild; if (null !== s) return Rl(i, s) } return t[7] } function _h(n, t, e, i, s, r, o) { for (; null != e;) { const a = i[e.index], l = e.type; if (o && 0 === t && (a && St(Xe(a), i), e.flags |= 4), 64 != (64 & e.flags)) if (8 & l) _h(n, t, e.child, i, s, r, !1), pr(t, n, s, a, r); else if (32 & l) { const c = uh(e, i); let u; for (; u = c();)pr(t, n, s, u, r); pr(t, n, s, a, r) } else 16 & l ? Ov(n, t, i, e, s, r) : pr(t, n, s, a, r); e = o ? e.projectionNext : e.next } } function Co(n, t, e, i, s, r) { _h(e, i, n.firstChild, t, s, r, !1) } function Ov(n, t, e, i, s, r) { const o = e[16], l = o[6].projection[i.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++)pr(t, n, s, l[c], r); else _h(n, t, l, o[3], s, r, !0) } function Lv(n, t, e) { n.setAttribute(t, "style", e) } function bh(n, t, e) { "" === e ? n.removeAttribute(t, "class") : n.setAttribute(t, "class", e) } function Fv(n, t, e) { let i = n.length; for (; ;) { const s = n.indexOf(t, e); if (-1 === s) return s; if (0 === s || n.charCodeAt(s - 1) <= 32) { const r = t.length; if (s + r === i || n.charCodeAt(s + r) <= 32) return s } e = s + 1 } } const Nv = "ng-template"; function iA(n, t, e) { let i = 0; for (; i < n.length;) { let s = n[i++]; if (e && "class" === s) { if (s = n[i], -1 !== Fv(s.toLowerCase(), t, 0)) return !0 } else if (1 === s) { for (; i < n.length && "string" == typeof (s = n[i++]);)if (s.toLowerCase() === t) return !0; return !1 } } return !1 } function jv(n) { return 4 === n.type && n.value !== Nv } function sA(n, t, e) { return t === (4 !== n.type || e ? n.value : Nv) } function rA(n, t, e) { let i = 4; const s = n.attrs || [], r = function lA(n) { for (let t = 0; t < n.length; t++)if (Cy(n[t])) return t; return n.length }(s); let o = !1; for (let a = 0; a < t.length; a++) { const l = t[a]; if ("number" != typeof l) { if (!o) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !sA(n, l, e) || "" === l && 1 === t.length) { if (In(i)) return !1; o = !0 } } else { const c = 8 & i ? l : t[++a]; if (8 & i && null !== n.attrs) { if (!iA(n.attrs, c, e)) { if (In(i)) return !1; o = !0 } continue } const d = oA(8 & i ? "class" : l, s, jv(n), e); if (-1 === d) { if (In(i)) return !1; o = !0; continue } if ("" !== c) { let h; h = d > r ? "" : s[d + 1].toLowerCase(); const f = 8 & i ? h : null; if (f && -1 !== Fv(f, c, 0) || 2 & i && c !== h) { if (In(i)) return !1; o = !0 } } } } else { if (!o && !In(i) && !In(l)) return !1; if (o && In(l)) continue; o = !1, i = l | 1 & i } } return In(i) || o } function In(n) { return 0 == (1 & n) } function oA(n, t, e, i) { if (null === t) return -1; let s = 0; if (i || !e) { let r = !1; for (; s < t.length;) { const o = t[s]; if (o === n) return s; if (3 === o || 6 === o) r = !0; else { if (1 === o || 2 === o) { let a = t[++s]; for (; "string" == typeof a;)a = t[++s]; continue } if (4 === o) break; if (0 === o) { s += 4; continue } } s += r ? 1 : 2 } return -1 } return function cA(n, t) { let e = n.indexOf(4); if (e > -1) for (e++; e < n.length;) { const i = n[e]; if ("number" == typeof i) return -1; if (i === t) return e; e++ } return -1 }(t, n) } function Bv(n, t, e = !1) { for (let i = 0; i < t.length; i++)if (rA(n, t[i], e)) return !0; return !1 } function Vv(n, t) { return n ? ":not(" + t.trim() + ")" : t } function dA(n) { let t = n[0], e = 1, i = 2, s = "", r = !1; for (; e < n.length;) { let o = n[e]; if ("string" == typeof o) if (2 & i) { const a = n[++e]; s += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & i ? s += "." + o : 4 & i && (s += " " + o); else "" !== s && !In(o) && (t += Vv(r, s), s = ""), i = o, r = r || !In(i); e++ } return "" !== s && (t += Vv(r, s)), t } const X = {}; function M(n) { Hv(me(), E(), Lt() + n, !1) } function Hv(n, t, e, i) { if (!i) if (3 == (3 & t[2])) { const r = n.preOrderCheckHooks; null !== r && dl(t, r, e) } else { const r = n.preOrderHooks; null !== r && hl(t, r, 0, e) } Ni(e) } const wh = new W("ENVIRONMENT_INITIALIZER"), Wv = new W("INJECTOR_DEF_TYPES"); function _A(...n) { return { \u0275providers: qv(0, n) } } function qv(n, ...t) { const e = [], i = new Set; let s; return di(t, r => { const o = r; Dh(o, e, [], i) && (s || (s = []), s.push(o)) }), void 0 !== s && Gv(s, e), e } function Gv(n, t) { for (let e = 0; e < n.length; e++) { const { providers: s } = n[e]; di(s, r => { t.push(r) }) } } function Dh(n, t, e, i) { if (!(n = Q(n))) return !1; let s = null, r = Xm(n); const o = !r && ke(n); if (r || o) { if (o && !o.standalone) return !1; s = n } else { const l = n.ngModule; if (r = Xm(l), !r) return !1; s = l } const a = i.has(s); if (o) { if (a) return !1; if (i.add(s), o.dependencies) { const l = "function" == typeof o.dependencies ? o.dependencies() : o.dependencies; for (const c of l) Dh(c, t, e, i) } } else { if (!r) return !1; { if (null != r.imports && !a) { let c; i.add(s); try { di(r.imports, u => { Dh(u, t, e, i) && (c || (c = []), c.push(u)) }) } finally { } void 0 !== c && Gv(c, t) } if (!a) { const c = ps(s) || (() => new s); t.push({ provide: s, useFactory: c, deps: be }, { provide: Wv, useValue: s, multi: !0 }, { provide: wh, useValue: () => k(s), multi: !0 }) } const l = r.providers; null == l || a || di(l, u => { t.push(u) }) } } return s !== n && void 0 !== n.providers } const bA = Ee({ provide: String, useValue: Ee }); function xh(n) { return null !== n && "object" == typeof n && bA in n } function vs(n) { return "function" == typeof n } const Ch = new W("INJECTOR", -1); class Zv { get(t, e = fo) { if (e === fo) { const i = new Error(`NullInjectorError: No provider for ${Me(t)}!`); throw i.name = "NullInjectorError", i } return e } } const Sh = new W("Set Injector scope."), Ol = {}, DA = {}; let Eh; function Mh() { return void 0 === Eh && (Eh = new Zv), Eh } class _s { } class Yv extends _s { constructor(t, e, i, s) { super(), this.parent = e, this.source = i, this.scopes = s, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Ah(t, o => this.processProvider(o)), this.records.set(Ch, gr(void 0, this)), s.has("environment") && this.records.set(_s, gr(void 0, this)); const r = this.records.get(Sh); null != r && "string" == typeof r.value && this.scopes.add(r.value), this.injectorDefTypes = new Set(this.get(Wv.multi, be, U.Self)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } get(t, e = fo, i = U.Default) { this.assertNotDestroyed(); const s = xl(this), r = zn(void 0); try { if (!(i & U.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const l = function MA(n) { return "function" == typeof n || "object" == typeof n && n instanceof W }(t) && gd(t); a = l && this.injectableDefInScope(l) ? gr(Th(t), Ol) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (i & U.Self ? Mh() : this.parent).get(t, e = i & U.Optional && e === fo ? null : e) } catch (o) { if ("NullInjectorError" === o.name) { if ((o[Dl] = o[Dl] || []).unshift(Me(t)), s) throw o; return function OM(n, t, e, i) { const s = n[Dl]; throw t[$y] && s.unshift(t[$y]), n.message = function LM(n, t, e, i = null) { n = n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1) ? n.slice(2) : n; let s = Me(t); if (Array.isArray(t)) s = t.map(Me).join(" -> "); else if ("object" == typeof t) { let r = []; for (let o in t) if (t.hasOwnProperty(o)) { let a = t[o]; r.push(o + ":" + ("string" == typeof a ? JSON.stringify(a) : Me(a))) } s = `{${r.join(", ")}}` } return `${e}${i ? "(" + i + ")" : ""}[${s}]: ${n.replace(kM, "\n  ")}` }("\n" + n.message, s, e, i), n.ngTokenPath = s, n[Dl] = null, n }(o, t, "R3InjectorError", this.source) } throw o } finally { zn(r), xl(s) } } resolveInjectorInitializers() { const t = xl(this), e = zn(void 0); try { const i = this.get(wh.multi, be, U.Self); for (const s of i) s() } finally { xl(t), zn(e) } } toString() { const t = [], e = this.records; for (const i of e.keys()) t.push(Me(i)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new T(205, !1) } processProvider(t) { let e = vs(t = Q(t)) ? t : Q(t && t.provide); const i = function CA(n) { return xh(n) ? gr(void 0, n.useValue) : gr(Xv(n), Ol) }(t); if (vs(t) || !0 !== t.multi) this.records.get(e); else { let s = this.records.get(e); s || (s = gr(void 0, Ol, !0), s.factory = () => Kd(s.multi), this.records.set(e, s)), e = t, s.multi.push(t) } this.records.set(e, i) } hydrate(t, e) { return e.value === Ol && (e.value = DA, e.value = e.factory()), "object" == typeof e.value && e.value && function EA(n) { return null !== n && "object" == typeof n && "function" == typeof n.ngOnDestroy }(e.value) && this._ngOnDestroyHooks.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = Q(t.providedIn); return "string" == typeof e ? "any" === e || this.scopes.has(e) : this.injectorDefTypes.has(e) } } function Th(n) { const t = gd(n), e = null !== t ? t.factory : ps(n); if (null !== e) return e; if (n instanceof W) throw new T(204, !1); if (n instanceof Function) return function xA(n) { const t = n.length; if (t > 0) throw function ho(n, t) { const e = []; for (let i = 0; i < n; i++)e.push(t); return e }(t, "?"), new T(204, !1); const e = function _E(n) { const t = n && (n[tl] || n[Jm]); if (t) { const e = function bE(n) { if (n.hasOwnProperty("name")) return n.name; const t = ("" + n).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(n); return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`), t } return null }(n); return null !== e ? () => e.factory(n) : () => new n }(n); throw new T(204, !1) } function Xv(n, t, e) { let i; if (vs(n)) { const s = Q(n); return ps(s) || Th(s) } if (xh(n)) i = () => Q(n.useValue); else if (function Qv(n) { return !(!n || !n.useFactory) }(n)) i = () => n.useFactory(...Kd(n.deps || [])); else if (function Kv(n) { return !(!n || !n.useExisting) }(n)) i = () => k(Q(n.useExisting)); else { const s = Q(n && (n.useClass || n.provide)); if (!function SA(n) { return !!n.deps }(n)) return ps(s) || Th(s); i = () => new s(...Kd(n.deps)) } return i } function gr(n, t, e = !1) { return { factory: n, value: t, multi: e ? [] : void 0 } } function TA(n) { return !!n.\u0275providers } function Ah(n, t) { for (const e of n) Array.isArray(e) ? Ah(e, t) : TA(e) ? Ah(e.\u0275providers, t) : t(e) } function Jv(n, t = null, e = null, i) { const s = e0(n, t, e, i); return s.resolveInjectorInitializers(), s } function e0(n, t = null, e = null, i, s = new Set) { const r = [e || be, _A(n)]; return i = i || ("object" == typeof n ? void 0 : Me(n)), new Yv(r, t || Mh(), i || null, s) } let Nt = (() => { class n { static create(e, i) { if (Array.isArray(e)) return Jv({ name: "" }, i, e, ""); { const s = e.name ?? ""; return Jv({ name: s }, e.parent, e.providers, s) } } } return n.THROW_IF_NOT_FOUND = fo, n.NULL = new Zv, n.\u0275prov = V({ token: n, providedIn: "any", factory: () => k(Ch) }), n.__NG_ELEMENT_ID__ = -1, n })(); function L(n, t = U.Default) { const e = E(); return null === e ? k(n, t) : Py(ot(), e, Q(n), t) } function Oh() { throw new Error("invalid") } function w0(n, t) { const e = n.contentQueries; if (null !== e) for (let i = 0; i < e.length; i += 2) { const s = e[i], r = e[i + 1]; if (-1 !== r) { const o = n.data[r]; Od(s), o.contentQueries(2, t[r], r) } } } function Bl(n, t, e, i, s, r, o, a, l, c, u) { const d = t.blueprint.slice(); return d[0] = s, d[2] = 76 | i, (null !== u || n && 1024 & n[2]) && (d[2] |= 1024), dy(d), d[3] = d[15] = n, d[8] = e, d[10] = o || n && n[10], d[11] = a || n && n[11], d[12] = l || n && n[12] || null, d[9] = c || n && n[9] || null, d[6] = r, d[20] = function ET() { return ST++ }(), d[21] = u, d[16] = 2 == t.type ? n[16] : d, d } function yr(n, t, e, i, s) { let r = n.data[t]; if (null === r) r = function Qh(n, t, e, i, s) { const r = py(), o = kd(), l = n.data[t] = function ak(n, t, e, i, s, r) { return { type: e, index: i, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: s, attrs: r, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? r : r && r.parent, e, t, i, s); return null === n.firstChild && (n.firstChild = l), null !== r && (o ? null == r.child && null !== l.parent && (r.child = l) : null === r.next && (r.next = l)), l }(n, t, e, i, s), function QE() { return Z.lFrame.inI18n }() && (r.flags |= 64); else if (64 & r.type) { r.type = e, r.value = i, r.attrs = s; const o = function io() { const n = Z.lFrame, t = n.currentTNode; return n.isParent ? t : t.parent }(); r.injectorIndex = null === o ? -1 : o.injectorIndex } return Wn(r, !0), r } function vr(n, t, e, i) { if (0 === e) return -1; const s = t.length; for (let r = 0; r < e; r++)t.push(i), n.blueprint.push(i), n.data.push(null); return s } function Vl(n, t, e) { Ld(t); try { const i = n.viewQuery; null !== i && rf(1, i, e); const s = n.template; null !== s && D0(n, t, s, 1, e), n.firstCreatePass && (n.firstCreatePass = !1), n.staticContentQueries && w0(n, t), n.staticViewQueries && rf(2, n.viewQuery, e); const r = n.components; null !== r && function ik(n, t) { for (let e = 0; e < t.length; e++)Sk(n, t[e]) }(t, r) } catch (i) { throw n.firstCreatePass && (n.incompleteFirstPass = !0, n.firstCreatePass = !1), i } finally { t[2] &= -5, Fd() } } function So(n, t, e, i) { const s = t[2]; if (128 != (128 & s)) { Ld(t); try { dy(t), function gy(n) { return Z.lFrame.bindingIndex = n }(n.bindingStartIndex), null !== e && D0(n, t, e, 2, i); const o = 3 == (3 & s); if (o) { const c = n.preOrderCheckHooks; null !== c && dl(t, c, null) } else { const c = n.preOrderHooks; null !== c && hl(t, c, 0, null), Nd(t, 0) } if (function xk(n) { for (let t = dh(n); null !== t; t = hh(t)) { if (!t[2]) continue; const e = t[9]; for (let i = 0; i < e.length; i++) { const s = e[i], r = s[3]; 0 == (512 & s[2]) && Ad(r, 1), s[2] |= 512 } } }(t), function Dk(n) { for (let t = dh(n); null !== t; t = hh(t))for (let e = 10; e < t.length; e++) { const i = t[e], s = i[1]; Td(i) && So(s, i, s.template, i[8]) } }(t), null !== n.contentQueries && w0(n, t), o) { const c = n.contentCheckHooks; null !== c && dl(t, c) } else { const c = n.contentHooks; null !== c && hl(t, c, 1), Nd(t, 1) } !function tk(n, t) { const e = n.hostBindingOpCodes; if (null !== e) try { for (let i = 0; i < e.length; i++) { const s = e[i]; if (s < 0) Ni(~s); else { const r = s, o = e[++i], a = e[++i]; ZE(o, r), a(2, t[r]) } } } finally { Ni(-1) } }(n, t); const a = n.components; null !== a && function nk(n, t) { for (let e = 0; e < t.length; e++)Ck(n, t[e]) }(t, a); const l = n.viewQuery; if (null !== l && rf(2, l, i), o) { const c = n.viewCheckHooks; null !== c && dl(t, c) } else { const c = n.viewHooks; null !== c && hl(t, c, 2), Nd(t, 2) } !0 === n.firstUpdatePass && (n.firstUpdatePass = !1), t[2] &= -41, 512 & t[2] && (t[2] &= -513, Ad(t[3], -1)) } finally { Fd() } } } function sk(n, t, e, i) { const s = t[10], o = uy(t); try { !o && s.begin && s.begin(), o && Vl(n, t, i), So(n, t, e, i) } finally { !o && s.end && s.end() } } function D0(n, t, e, i, s) { const r = Lt(), o = 2 & i; try { Ni(-1), o && t.length > 22 && Hv(n, t, 22, !1), e(i, s) } finally { Ni(r) } } function x0(n, t, e) { if (Dd(t)) { const s = t.directiveEnd; for (let r = t.directiveStart; r < s; r++) { const o = n.data[r]; o.contentQueries && o.contentQueries(1, e[r], r) } } } function Zh(n, t, e) { !fy() || (function pk(n, t, e, i) { const s = e.directiveStart, r = e.directiveEnd; n.firstCreatePass || oo(e, t), St(i, t); const o = e.initialInputs; for (let a = s; a < r; a++) { const l = n.data[a], c = kn(l); c && _k(t, e, l); const u = ao(t, n, a, e); St(u, t), null !== o && bk(0, a - s, u, l, 0, o), c && (tn(e.index, t)[8] = u) } }(n, t, e, fn(e, t)), 128 == (128 & e.flags) && function gk(n, t, e) { const i = e.directiveStart, s = e.directiveEnd, r = e.index, o = function YE() { return Z.lFrame.currentDirectiveIndex }(); try { Ni(r); for (let a = i; a < s; a++) { const l = n.data[a], c = t[a]; Pd(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && T0(l, c) } } finally { Ni(-1), Pd(o) } }(n, t, e)) } function Yh(n, t, e = fn) { const i = t.localNames; if (null !== i) { let s = t.index + 1; for (let r = 0; r < i.length; r += 2) { const o = i[r + 1], a = -1 === o ? e(t, n) : n[o]; n[s++] = a } } } function C0(n) { const t = n.tView; return null === t || t.incompleteFirstPass ? n.tView = Xh(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs, n.viewQuery, n.schemas, n.consts) : t } function Xh(n, t, e, i, s, r, o, a, l, c) { const u = 22 + i, d = u + s, h = function rk(n, t) { const e = []; for (let i = 0; i < t; i++)e.push(i < n ? null : X); return e }(u, d), f = "function" == typeof c ? c() : c; return h[1] = { type: n, blueprint: h, template: e, queries: null, viewQuery: a, declTNode: t, data: h.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof r ? r() : r, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: f, incompleteFirstPass: !1 } } function S0(n, t, e, i) { const s = L0(t); null === e ? s.push(i) : (s.push(e), n.firstCreatePass && F0(n).push(i, s.length - 1)) } function E0(n, t, e) { for (let i in n) if (n.hasOwnProperty(i)) { const s = n[i]; (e = null === e ? {} : e).hasOwnProperty(i) ? e[i].push(t, s) : e[i] = [t, s] } return e } function Jh(n, t, e, i) { let s = !1; if (fy()) { const r = function mk(n, t, e) { const i = n.directiveRegistry; let s = null; if (i) for (let r = 0; r < i.length; r++) { const o = i[r]; Bv(e, o.selectors, !1) && (s || (s = []), yl(oo(e, t), n, o.type), kn(o) ? (A0(n, e), s.unshift(o)) : s.push(o)) } return s }(n, t, e), o = null === i ? null : { "": -1 }; if (null !== r) { s = !0, k0(e, n.data.length, r.length); for (let u = 0; u < r.length; u++) { const d = r[u]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, c = vr(n, t, r.length, null); for (let u = 0; u < r.length; u++) { const d = r[u]; e.mergedAttrs = pl(e.mergedAttrs, d.hostAttrs), I0(n, e, t, c, d), vk(c, d, o), null !== d.contentQueries && (e.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (e.flags |= 128); const h = d.type.prototype; !a && (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e.index), a = !0), !l && (h.ngOnChanges || h.ngDoCheck) && ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e.index), l = !0), c++ } !function lk(n, t) { const i = t.directiveEnd, s = n.data, r = t.attrs, o = []; let a = null, l = null; for (let c = t.directiveStart; c < i; c++) { const u = s[c], d = u.inputs, h = null === r || jv(t) ? null : wk(d, r); o.push(h), a = E0(d, c, a), l = E0(u.outputs, c, l) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = o, t.inputs = a, t.outputs = l }(n, e) } o && function yk(n, t, e) { if (t) { const i = n.localNames = []; for (let s = 0; s < t.length; s += 2) { const r = e[t[s + 1]]; if (null == r) throw new T(-301, !1); i.push(t[s], r) } } }(e, i, o) } return e.mergedAttrs = pl(e.mergedAttrs, e.attrs), s } function M0(n, t, e, i, s, r) { const o = r.hostBindings; if (o) { let a = n.hostBindingOpCodes; null === a && (a = n.hostBindingOpCodes = []); const l = ~t.index; (function fk(n) { let t = n.length; for (; t > 0;) { const e = n[--t]; if ("number" == typeof e && e < 0) return e } return 0 })(a) != l && a.push(l), a.push(i, s, o) } } function T0(n, t) { null !== n.hostBindings && n.hostBindings(1, t) } function A0(n, t) { t.flags |= 2, (n.components || (n.components = [])).push(t.index) } function vk(n, t, e) { if (e) { if (t.exportAs) for (let i = 0; i < t.exportAs.length; i++)e[t.exportAs[i]] = n; kn(t) && (e[""] = n) } } function k0(n, t, e) { n.flags |= 1, n.directiveStart = t, n.directiveEnd = t + e, n.providerIndexes = t } function I0(n, t, e, i, s) { n.data[i] = s; const r = s.factory || (s.factory = ps(s.type)), o = new so(r, kn(s), L); n.blueprint[i] = o, e[i] = o, M0(n, t, 0, i, vr(n, e, s.hostVars, X), s) } function _k(n, t, e) { const i = fn(t, n), s = C0(e), r = n[10], o = Hl(n, Bl(n, s, null, e.onPush ? 32 : 16, i, t, r, r.createRenderer(i, e), null, null, null)); n[t.index] = o } function Kn(n, t, e, i, s, r) { const o = fn(n, t); !function ef(n, t, e, i, s, r, o) { if (null == r) n.removeAttribute(t, s, e); else { const a = null == o ? Y(r) : o(r, i || "", s); n.setAttribute(t, s, a, e) } }(t[11], o, r, n.value, e, i, s) } function bk(n, t, e, i, s, r) { const o = r[t]; if (null !== o) { const a = i.setInput; for (let l = 0; l < o.length;) { const c = o[l++], u = o[l++], d = o[l++]; null !== a ? i.setInput(e, d, c, u) : e[u] = d } } } function wk(n, t) { let e = null, i = 0; for (; i < t.length;) { const s = t[i]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; n.hasOwnProperty(s) && (null === e && (e = []), e.push(s, n[s], t[i + 1])), i += 2 } else i += 2; else i += 4 } return e } function P0(n, t, e, i) { return new Array(n, !0, !1, t, null, 0, i, e, null, null) } function Ck(n, t) { const e = tn(t, n); if (Td(e)) { const i = e[1]; 48 & e[2] ? So(i, e, i.template, e[8]) : e[5] > 0 && tf(e) } } function tf(n) { for (let i = dh(n); null !== i; i = hh(i))for (let s = 10; s < i.length; s++) { const r = i[s]; if (512 & r[2]) { const o = r[1]; So(o, r, o.template, r[8]) } else r[5] > 0 && tf(r) } const e = n[1].components; if (null !== e) for (let i = 0; i < e.length; i++) { const s = tn(e[i], n); Td(s) && s[5] > 0 && tf(s) } } function Sk(n, t) { const e = tn(t, n), i = e[1]; (function Ek(n, t) { for (let e = t.length; e < n.blueprint.length; e++)t.push(n.blueprint[e]) })(i, e), Vl(i, e, e[8]) } function Hl(n, t) { return n[13] ? n[14][4] = t : n[13] = t, n[14] = t, t } function nf(n) { for (; n;) { n[2] |= 32; const t = xo(n); if (kE(n) && !t) return n; n = t } return null } function O0(n) { !function R0(n) { for (let t = 0; t < n.components.length; t++) { const e = n.components[t], i = lh(e); if (null !== i) { const s = i[1]; sk(s, i, s.template, e) } } }(n[8]) } function rf(n, t, e) { Od(0), t(n, e) } const Tk = (() => Promise.resolve(null))(); function L0(n) { return n[7] || (n[7] = []) } function F0(n) { return n.cleanup || (n.cleanup = []) } function j0(n, t) { const e = n[9], i = e ? e.get(ms, null) : null; i && i.handleError(t) } function B0(n, t, e, i, s) { for (let r = 0; r < e.length;) { const o = e[r++], a = e[r++], l = t[o], c = n.data[o]; null !== c.setInput ? c.setInput(l, s, i, a) : l[a] = s } } function pi(n, t, e) { const i = function ll(n, t) { return Xe(t[n]) }(t, n); !function wv(n, t, e) { n.setValue(t, e) }(n[11], i, e) } function $l(n, t, e) { let i = e ? n.styles : null, s = e ? n.classes : null, r = 0; if (null !== t) for (let o = 0; o < t.length; o++) { const a = t[o]; "number" == typeof a ? r = a : 1 == r ? s = hd(s, a) : 2 == r && (i = hd(i, a + ": " + t[++o] + ";")) } e ? n.styles = i : n.stylesWithoutHost = i, e ? n.classes = s : n.classesWithoutHost = s } function Pk() { const n = ot(); ul(E()[1], n) } let zl = null; function bs() { if (!zl) { const n = Se.Symbol; if (n && n.iterator) zl = n.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const i = t[e]; "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (zl = i) } } } return zl } function Eo(n) { return !!lf(n) && (Array.isArray(n) || !(n instanceof Map) && bs() in n) } function lf(n) { return null !== n && ("function" == typeof n || "object" == typeof n) } function Qn(n, t, e) { return n[t] = e } function Et(n, t, e) { return !Object.is(n[t], e) && (n[t] = e, !0) } function ws(n, t, e, i) { const s = Et(n, t, e); return Et(n, t + 1, i) || s } function pn(n, t, e, i, s, r) { const o = ws(n, t, e, i); return ws(n, t + 2, s, r) || o } function cf(n, t, e, i) { const s = E(); return Et(s, tr(), t) && (me(), Kn(We(), s, n, t, e, i)), cf } function jt(n, t, e, i, s, r, o, a) { const l = E(), c = me(), u = n + 22, d = c.firstCreatePass ? function Wk(n, t, e, i, s, r, o, a, l) { const c = t.consts, u = yr(t, n, 4, o || null, Fi(c, a)); Jh(t, e, u, Fi(c, l)), ul(t, u); const d = u.tViews = Xh(2, u, i, s, r, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c); return null !== t.queries && (t.queries.template(t, u), d.queries = t.queries.embeddedTView(u)), u }(u, c, l, t, e, i, s, r, o) : c.data[u]; Wn(d, !1); const h = l[11].createComment(""); Pl(c, l, h, d), St(h, l), Hl(l, l[u] = P0(h, l, h, d)), al(d) && Zh(c, l, d), null != o && Yh(l, d, a) } function gi(n) { return er(function KE() { return Z.lFrame.contextLView }(), 22 + n) } function De(n, t, e) { const i = E(); return Et(i, tr(), t) && function rn(n, t, e, i, s, r, o, a) { const l = fn(t, e); let u, c = t.inputs; !a && null != c && (u = c[i]) ? (B0(n, e, u, i, s), ol(t) && function uk(n, t) { const e = tn(t, n); 16 & e[2] || (e[2] |= 32) }(e, t.index)) : 3 & t.type && (i = function ck(n) { return "class" === n ? "className" : "for" === n ? "htmlFor" : "formaction" === n ? "formAction" : "innerHtml" === n ? "innerHTML" : "readonly" === n ? "readOnly" : "tabindex" === n ? "tabIndex" : n }(i), s = null != o ? o(s, t.value || "", i) : s, r.setProperty(l, i, s)) }(me(), We(), i, n, t, i[11], e, !1), De } function uf(n, t, e, i, s) { const o = s ? "class" : "style"; B0(n, e, t.inputs[o], o, i) } function _(n, t, e, i) { const s = E(), r = me(), o = 22 + n, a = s[11], l = s[o] = ph(a, t, function iM() { return Z.lFrame.currentNamespace }()), c = r.firstCreatePass ? function Gk(n, t, e, i, s, r, o) { const a = t.consts, c = yr(t, n, 2, s, Fi(a, r)); return Jh(t, e, c, Fi(a, o)), null !== c.attrs && $l(c, c.attrs, !1), null !== c.mergedAttrs && $l(c, c.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, c), c }(o, r, s, 0, t, e, i) : r.data[o]; Wn(c, !0); const u = c.mergedAttrs; null !== u && fl(a, l, u); const d = c.classes; null !== d && bh(a, l, d); const h = c.styles; return null !== h && Lv(a, l, h), 64 != (64 & c.flags) && Pl(r, s, l, c), 0 === function zE() { return Z.lFrame.elementDepthCount }() && St(l, s), function UE() { Z.lFrame.elementDepthCount++ }(), al(c) && (Zh(r, s, c), x0(r, c, s)), null !== i && Yh(s, c), _ } function w() { let n = ot(); kd() ? Id() : (n = n.parent, Wn(n, !1)); const t = n; !function WE() { Z.lFrame.elementDepthCount-- }(); const e = me(); return e.firstCreatePass && (ul(e, n), Dd(n) && e.queries.elementEnd(n)), null != t.classesWithoutHost && function lM(n) { return 0 != (16 & n.flags) }(t) && uf(e, t, E(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function cM(n) { return 0 != (32 & n.flags) }(t) && uf(e, t, E(), t.stylesWithoutHost, !1), w } function C(n, t, e, i) { return _(n, t, e, i), w(), C } function To(n, t, e) { const i = E(), s = me(), r = n + 22, o = s.firstCreatePass ? function Kk(n, t, e, i, s) { const r = t.consts, o = Fi(r, i), a = yr(t, n, 8, "ng-container", o); return null !== o && $l(a, o, !0), Jh(t, e, a, Fi(r, s)), null !== t.queries && t.queries.elementStart(t, a), a }(r, s, i, t, e) : s.data[r]; Wn(o, !0); const a = i[r] = i[11].createComment(""); return Pl(s, i, a, o), St(a, i), al(o) && (Zh(s, i, o), x0(s, o, i)), null != e && Yh(i, o), To } function Ao() { let n = ot(); const t = me(); return kd() ? Id() : (n = n.parent, Wn(n, !1)), t.firstCreatePass && (ul(t, n), Dd(n) && t.queries.elementEnd(n)), Ao } function Ds() { return E() } function Wl(n) { return !!n && "function" == typeof n.then } const J0 = function X0(n) { return !!n && "function" == typeof n.subscribe }; function Pe(n, t, e, i) { const s = E(), r = me(), o = ot(); return function t_(n, t, e, i, s, r, o, a) { const l = al(i), u = n.firstCreatePass && F0(n), d = t[8], h = L0(t); let f = !0; if (3 & i.type || a) { const m = fn(i, t), y = a ? a(m) : m, b = h.length, v = a ? x => a(Xe(x[i.index])) : i.index; let D = null; if (!a && l && (D = function Qk(n, t, e, i) { const s = n.cleanup; if (null != s) for (let r = 0; r < s.length - 1; r += 2) { const o = s[r]; if (o === e && s[r + 1] === i) { const a = t[7], l = s[r + 2]; return a.length > l ? a[l] : null } "string" == typeof o && (r += 2) } return null }(n, t, s, i.index)), null !== D) (D.__ngLastListenerFn__ || D).__ngNextListenerFn__ = r, D.__ngLastListenerFn__ = r, f = !1; else { r = i_(i, t, d, r, !1); const x = e.listen(y, s, r); h.push(r, x), u && u.push(s, v, b, b + 1) } } else r = i_(i, t, d, r, !1); const p = i.outputs; let g; if (f && null !== p && (g = p[s])) { const m = g.length; if (m) for (let y = 0; y < m; y += 2) { const S = t[g[y]][g[y + 1]].subscribe(r), A = h.length; h.push(r, S), u && u.push(s, i.index, A, -(A + 1)) } } }(r, s, s[11], o, n, t, 0, i), Pe } function n_(n, t, e, i) { try { return !1 !== e(i) } catch (s) { return j0(n, s), !1 } } function i_(n, t, e, i, s) { return function r(o) { if (o === Function) return i; nf(2 & n.flags ? tn(n.index, t) : t); let l = n_(t, 0, i, o), c = r.__ngNextListenerFn__; for (; c;)l = n_(t, 0, c, o) && l, c = c.__ngNextListenerFn__; return s && !1 === l && (o.preventDefault(), o.returnValue = !1), l } } function lt(n = 1) { return function JE(n) { return (Z.lFrame.contextLView = function eM(n, t) { for (; n > 0;)t = t[15], n--; return t }(n, Z.lFrame.contextLView))[8] }(n) } function I(n, t = "") { const e = E(), i = me(), s = n + 22, r = i.firstCreatePass ? yr(i, s, 1, t, null) : i.data[s], o = e[s] = function fh(n, t) { return n.createText(t) }(e[11], t); Pl(i, e, o, r), Wn(r, !1) } function q(n) { return fe("", n, ""), q } function fe(n, t, e) { const i = E(), s = function br(n, t, e, i) { return Et(n, tr(), e) ? t + Y(e) + i : X }(i, n, t, e); return s !== X && pi(i, Lt(), s), fe } const kr = "en-US"; let Q_ = kr; function gf(n, t, e, i, s) { if (n = Q(n), Array.isArray(n)) for (let r = 0; r < n.length; r++)gf(n[r], t, e, i, s); else { const r = me(), o = E(); let a = vs(n) ? n : Q(n.provide), l = Xv(n); const c = ot(), u = 1048575 & c.providerIndexes, d = c.directiveStart, h = c.providerIndexes >> 20; if (vs(n) || !n.multi) { const f = new so(l, s, L), p = yf(a, t, s ? u : u + h, d); -1 === p ? (yl(oo(c, o), r, a), mf(r, n, t.length), t.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), e.push(f), o.push(f)) : (e[p] = f, o[p] = f) } else { const f = yf(a, t, u + h, d), p = yf(a, t, u, u + h), g = f >= 0 && e[f], m = p >= 0 && e[p]; if (s && !m || !s && !g) { yl(oo(c, o), r, a); const y = function LI(n, t, e, i, s) { const r = new so(n, e, L); return r.multi = [], r.index = t, r.componentProviders = 0, w1(r, s, i && !e), r }(s ? OI : RI, e.length, s, i, l); !s && m && (e[p].providerFactory = y), mf(r, n, t.length, 0), t.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), e.push(y), o.push(y) } else mf(r, n, f > -1 ? f : p, w1(e[s ? p : f], l, !s && i)); !s && i && m && e[p].componentProviders++ } } } function mf(n, t, e, i) { const s = vs(t), r = function wA(n) { return !!n.useClass }(t); if (s || r) { const l = (r ? Q(t.useClass) : t).prototype.ngOnDestroy; if (l) { const c = n.destroyHooks || (n.destroyHooks = []); if (!s && t.multi) { const u = c.indexOf(e); -1 === u ? c.push(e, [i, l]) : c[u + 1].push(i, l) } else c.push(e, l) } } } function w1(n, t, e) { return e && n.componentProviders++, n.multi.push(t) - 1 } function yf(n, t, e, i) { for (let s = e; s < i; s++)if (t[s] === n) return s; return -1 } function RI(n, t, e, i) { return vf(this.multi, []) } function OI(n, t, e, i) { const s = this.multi; let r; if (this.providerFactory) { const o = this.providerFactory.componentProviders, a = ao(e, e[1], this.providerFactory.index, i); r = a.slice(0, o), vf(s, r); for (let l = o; l < a.length; l++)r.push(a[l]) } else r = [], vf(s, r); return r } function vf(n, t) { for (let e = 0; e < n.length; e++)t.push((0, n[e])()); return t } function D1(n, t = []) { return e => { e.providersResolver = (i, s) => function PI(n, t, e) { const i = me(); if (i.firstCreatePass) { const s = kn(n); gf(e, i.data, i.blueprint, s, !0), gf(t, i.data, i.blueprint, s, !1) } }(i, s ? s(n) : n, t) } } class NI { resolveComponentFactory(t) { throw function FI(n) { const t = Error(`No component factory found for ${Me(n)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = n, t }(t) } } let Lo = (() => { class n { } return n.NULL = new NI, n })(); class zi { } class C1 { } class S1 { } function BI() { return Pr(ot(), E()) } function Pr(n, t) { return new Xn(fn(n, t)) } let Xn = (() => { class n { constructor(e) { this.nativeElement = e } } return n.__NG_ELEMENT_ID__ = BI, n })(); function VI(n) { return n instanceof Xn ? n.nativeElement : n } class Fo { } let No = (() => { class n { } return n.__NG_ELEMENT_ID__ = () => function HI() { const n = E(), e = tn(ot().index, n); return ($t(e) ? e : n)[11] }(), n })(), $I = (() => { class n { } return n.\u0275prov = V({ token: n, providedIn: "root", factory: () => null }), n })(); class Yl { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const zI = new Yl("14.0.6"), _f = {}; function Xl(n, t, e, i, s = !1) { for (; null !== e;) { const r = t[e.index]; if (null !== r && i.push(Xe(r)), An(r)) for (let a = 10; a < r.length; a++) { const l = r[a], c = l[1].firstChild; null !== c && Xl(l[1], l, c, i) } const o = e.type; if (8 & o) Xl(n, t, e.child, i); else if (32 & o) { const a = uh(e, t); let l; for (; l = a();)i.push(l) } else if (16 & o) { const a = Pv(t, e); if (Array.isArray(a)) i.push(...a); else { const l = xo(t[16]); Xl(l[1], l, a, i, !0) } } e = s ? e.projectionNext : e.next } return i } class jo { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return Xl(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (An(t)) { const e = t[8], i = e ? e.indexOf(this) : -1; i > -1 && (gh(t, i), bl(e, i)) } this._attachedToViewContainer = !1 } xv(this._lView[1], this._lView) } onDestroy(t) { S0(this._lView[1], this._lView, null, t) } markForCheck() { nf(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { !function sf(n, t, e) { const i = t[10]; i.begin && i.begin(); try { So(n, t, n.template, e) } catch (s) { throw j0(t, s), s } finally { i.end && i.end() } }(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new T(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function qT(n, t) { Co(n, t, t[11], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new T(902, !1); this._appRef = t } } class UI extends jo { constructor(t) { super(t), this._view = t } detectChanges() { O0(this._view) } checkNoChanges() { } get context() { return null } } class bf extends Lo { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = ke(t); return new wf(e, this.ngModule) } } function E1(n) { const t = []; for (let e in n) n.hasOwnProperty(e) && t.push({ propName: n[e], templateName: e }); return t } class qI { constructor(t, e) { this.injector = t, this.parentInjector = e } get(t, e, i) { const s = this.injector.get(t, _f, i); return s !== _f || e === _f ? s : this.parentInjector.get(t, e, i) } } class wf extends S1 { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = function hA(n) { return n.map(dA).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return E1(this.componentDef.inputs) } get outputs() { return E1(this.componentDef.outputs) } create(t, e, i, s) { let r = (s = s || this.ngModule) instanceof _s ? s : s?.injector; r && null !== this.componentDef.getStandaloneInjector && (r = this.componentDef.getStandaloneInjector(r) || r); const o = r ? new qI(t, r) : t, a = o.get(Fo, null); if (null === a) throw new T(407, !1); const l = o.get($I, null), c = a.createRenderer(null, this.componentDef), u = this.componentDef.selectors[0][0] || "div", d = i ? function ok(n, t, e) { return n.selectRootElement(t, e === Mn.ShadowDom) }(c, i, this.componentDef.encapsulation) : ph(a.createRenderer(null, this.componentDef), u, function WI(n) { const t = n.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(u)), h = this.componentDef.onPush ? 288 : 272, f = function Ik(n, t) { return { components: [], scheduler: n || FT, clean: Tk, playerHandler: t || null, flags: 0 } }(), p = Xh(0, null, null, 1, 0, null, null, null, null, null), g = Bl(null, p, f, h, null, null, a, c, l, o, null); let m, y; Ld(g); try { const b = function Ak(n, t, e, i, s, r) { const o = e[1]; e[22] = n; const l = yr(o, 22, 2, "#host", null), c = l.mergedAttrs = t.hostAttrs; null !== c && ($l(l, c, !0), null !== n && (fl(s, n, c), null !== l.classes && bh(s, n, l.classes), null !== l.styles && Lv(s, n, l.styles))); const u = i.createRenderer(n, t), d = Bl(e, C0(t), null, t.onPush ? 32 : 16, e[22], l, i, u, r || null, null, null); return o.firstCreatePass && (yl(oo(l, e), o, t.type), A0(o, l), k0(l, e.length, 1)), Hl(e, d), e[22] = d }(d, this.componentDef, g, a, c); if (d) if (i) fl(c, d, ["ng-version", zI.full]); else { const { attrs: v, classes: D } = function fA(n) { const t = [], e = []; let i = 1, s = 2; for (; i < n.length;) { let r = n[i]; if ("string" == typeof r) 2 === s ? "" !== r && t.push(r, n[++i]) : 8 === s && e.push(r); else { if (!In(s)) break; s = r } i++ } return { attrs: t, classes: e } }(this.componentDef.selectors[0]); v && fl(c, d, v), D && D.length > 0 && bh(c, d, D.join(" ")) } if (y = Md(p, 22), void 0 !== e) { const v = y.projection = []; for (let D = 0; D < this.ngContentSelectors.length; D++) { const x = e[D]; v.push(null != x ? Array.from(x) : null) } } m = function kk(n, t, e, i, s) { const r = e[1], o = function hk(n, t, e) { const i = ot(); n.firstCreatePass && (e.providersResolver && e.providersResolver(e), I0(n, i, t, vr(n, t, 1, null), e)); const s = ao(t, n, i.directiveStart, i); St(s, t); const r = fn(i, t); return r && St(r, t), s }(r, e, t); if (i.components.push(o), n[8] = o, null !== s) for (const l of s) l(o, t); if (t.contentQueries) { const l = ot(); t.contentQueries(1, o, l.directiveStart) } const a = ot(); return !r.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (Ni(a.index), M0(e[1], a, 0, a.directiveStart, a.directiveEnd, t), T0(t, o)), o }(b, this.componentDef, g, f, [Pk]), Vl(p, g, null) } finally { Fd() } return new KI(this.componentType, m, Pr(y, g), g, y) } } class KI extends class jI { }{ constructor(t, e, i, s, r) { super(), this.location = i, this._rootLView = s, this._tNode = r, this.instance = e, this.hostView = this.changeDetectorRef = new UI(s), this.componentType = t } get injector() { return new sr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } class M1 extends zi { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new bf(this); const i = Jt(t); this._bootstrapComponents = hi(i.bootstrap), this._r3Injector = e0(t, e, [{ provide: zi, useValue: this }, { provide: Lo, useValue: this.componentFactoryResolver }], Me(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this.get(t) } get(t, e = Nt.THROW_IF_NOT_FOUND, i = U.Default) { return t === Nt || t === zi || t === Ch ? this : this._r3Injector.get(t, e, i) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Df extends C1 { constructor(t) { super(), this.moduleType = t } create(t) { return new M1(this.moduleType, t) } } class ZI extends zi { constructor(t, e, i) { super(), this.componentFactoryResolver = new bf(this), this.instance = null; const s = new Yv([...t, { provide: zi, useValue: this }, { provide: Lo, useValue: this.componentFactoryResolver }], e || Mh(), i, new Set(["environment"])); this.injector = s, s.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } function Jl(n, t = null, e = null) { return new ZI(n, t, e).injector } function Bo(n, t, e, i) { return L1(E(), Ot(), n, t, e, i) } function ec(n, t, e, i, s) { return function F1(n, t, e, i, s, r, o) { const a = t + e; return ws(n, a, s, r) ? Qn(n, a + 2, o ? i.call(o, s, r) : i(s, r)) : Vo(n, a + 2) }(E(), Ot(), n, t, e, i, s) } function O1(n, t, e, i, s, r, o) { return function j1(n, t, e, i, s, r, o, a, l) { const c = t + e; return pn(n, c, s, r, o, a) ? Qn(n, c + 4, l ? i.call(l, s, r, o, a) : i(s, r, o, a)) : Vo(n, c + 4) }(E(), Ot(), n, t, e, i, s, r, o) } function Cf(n, t, e, i, s, r, o, a) { const l = Ot() + n, c = E(), u = pn(c, l, e, i, s, r); return Et(c, l + 4, o) || u ? Qn(c, l + 5, a ? t.call(a, e, i, s, r, o) : t(e, i, s, r, o)) : function Mo(n, t) { return n[t] }(c, l + 5) } function Vo(n, t) { const e = n[t]; return e === X ? void 0 : e } function L1(n, t, e, i, s, r) { const o = t + e; return Et(n, o, s) ? Qn(n, o + 1, r ? i.call(r, s) : i(s)) : Vo(n, o + 1) } function R(n, t) { const e = me(); let i; const s = n + 22; e.firstCreatePass ? (i = function fP(n, t) { if (t) for (let e = t.length - 1; e >= 0; e--) { const i = t[e]; if (n === i.name) return i } }(t, e.pipeRegistry), e.data[s] = i, i.onDestroy && (e.destroyHooks || (e.destroyHooks = [])).push(s, i.onDestroy)) : i = e.data[s]; const r = i.factory || (i.factory = ps(i.type)), o = zn(L); try { const a = gl(!1), l = r(); return gl(a), function qk(n, t, e, i) { e >= n.data.length && (n.data[e] = null, n.blueprint[e] = null), t[e] = i }(e, E(), s, l), l } finally { zn(o) } } function O(n, t, e) { const i = n + 22, s = E(), r = er(s, i); return function Ho(n, t) { return n[1].data[t].pure }(s, i) ? L1(s, Ot(), t, r.transform, e, r) : r.transform(e) } function Sf(n) { return t => { setTimeout(n, void 0, t) } } const Re = class vP extends Ne { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, i) { let s = t, r = e || (() => null), o = i; if (t && "object" == typeof t) { const l = t; s = l.next?.bind(l), r = l.error?.bind(l), o = l.complete?.bind(l) } this.__isAsync && (r = Sf(r), s && (s = Sf(s)), o && (o = Sf(o))); const a = super.subscribe({ next: s, error: r, complete: o }); return t instanceof Qt && t.add(a), a } }; function _P() { return this._results[bs()]() } class Ef { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = bs(), i = Ef.prototype; i[e] || (i[e] = _P) } get changes() { return this._changes || (this._changes = new Re) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const i = this; i.dirty = !1; const s = nn(t); (this._changesDetected = !function bM(n, t, e) { if (n.length !== t.length) return !1; for (let i = 0; i < n.length; i++) { let s = n[i], r = t[i]; if (e && (s = e(s), r = e(r)), r !== s) return !1 } return !0 }(i._results, s, e)) && (i._results = s, i.length = s.length, i.last = s[this.length - 1], i.first = s[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let Jn = (() => { class n { } return n.__NG_ELEMENT_ID__ = DP, n })(); const bP = Jn, wP = class extends bP { constructor(t, e, i) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = i } createEmbeddedView(t, e) { const i = this._declarationTContainer.tViews, s = Bl(this._declarationLView, i, t, 16, null, i.declTNode, null, null, null, null, e || null); s[17] = this._declarationLView[this._declarationTContainer.index]; const o = this._declarationLView[19]; return null !== o && (s[19] = o.createEmbeddedView(i)), Vl(i, s, t), new jo(s) } }; function DP() { return tc(ot(), E()) } function tc(n, t) { return 4 & n.type ? new wP(t, n, Pr(n, t)) : null } let Ln = (() => { class n { } return n.__NG_ELEMENT_ID__ = xP, n })(); function xP() { return $1(ot(), E()) } const CP = Ln, V1 = class extends CP { constructor(t, e, i) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i } get element() { return Pr(this._hostTNode, this._hostLView) } get injector() { return new sr(this._hostTNode, this._hostLView) } get parentInjector() { const t = ml(this._hostTNode, this._hostLView); if (My(t)) { const e = ir(t, this._hostLView), i = nr(t); return new sr(e[1].data[i + 8], e) } return new sr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = H1(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, e, i) { let s, r; "number" == typeof i ? s = i : null != i && (s = i.index, r = i.injector); const o = t.createEmbeddedView(e || {}, r); return this.insert(o, s), o } createComponent(t, e, i, s, r) { const o = t && !function uo(n) { return "function" == typeof n }(t); let a; if (o) a = e; else { const d = e || {}; a = d.index, i = d.injector, s = d.projectableNodes, r = d.environmentInjector || d.ngModuleRef } const l = o ? t : new wf(ke(t)), c = i || this.parentInjector; if (!r && null == l.ngModule) { const h = (o ? c : this.parentInjector).get(_s, null); h && (r = h) } const u = l.create(c, s, void 0, r); return this.insert(u.hostView, a), u } insert(t, e) { const i = t._lView, s = i[1]; if (function $E(n) { return An(n[3]) }(i)) { const u = this.indexOf(t); if (-1 !== u) this.detach(u); else { const d = i[3], h = new V1(d, d[6], d[3]); h.detach(h.indexOf(t)) } } const r = this._adjustIndex(e), o = this._lContainer; !function KT(n, t, e, i) { const s = 10 + i, r = e.length; i > 0 && (e[s - 1][4] = t), i < r - 10 ? (t[4] = e[s], jy(e, 10 + i, t)) : (e.push(t), t[4] = null), t[3] = e; const o = t[17]; null !== o && e !== o && function QT(n, t) { const e = n[9]; t[16] !== t[3][3][16] && (n[2] = !0), null === e ? n[9] = [t] : e.push(t) }(o, t); const a = t[19]; null !== a && a.insertView(n), t[2] |= 64 }(s, i, o, r); const a = vh(r, o), l = i[11], c = Il(l, o[7]); return null !== c && function WT(n, t, e, i, s, r) { i[0] = s, i[6] = t, Co(n, i, e, 1, s, r) }(s, o[6], l, i, c, a), t.attachToViewContainerRef(), jy(Mf(o), r, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = H1(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), i = gh(this._lContainer, e); i && (bl(Mf(this._lContainer), e), xv(i[1], i)) } detach(t) { const e = this._adjustIndex(t, -1), i = gh(this._lContainer, e); return i && null != bl(Mf(this._lContainer), e) ? new jo(i) : null } _adjustIndex(t, e = 0) { return t ?? this.length + e } }; function H1(n) { return n[8] } function Mf(n) { return n[8] || (n[8] = []) } function $1(n, t) { let e; const i = t[n.index]; if (An(i)) e = i; else { let s; if (8 & n.type) s = Xe(i); else { const r = t[11]; s = r.createComment(""); const o = fn(n, t); ys(r, Il(r, o), s, function JT(n, t) { return n.nextSibling(t) }(r, o), !1) } t[n.index] = e = P0(i, t, s, n), Hl(t, e) } return new V1(e, n, t) } class Tf { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Tf(this.queryList) } setDirty() { this.queryList.setDirty() } } class Af { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const i = null !== t.contentQueries ? t.contentQueries[0] : e.length, s = []; for (let r = 0; r < i; r++) { const o = e.getByIndex(r); s.push(this.queries[o.indexInDeclarationView].clone()) } return new Af(s) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== G1(t, e).matches && this.queries[e].setDirty() } } class z1 { constructor(t, e, i = null) { this.predicate = t, this.flags = e, this.read = i } } class kf { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let i = 0; i < this.length; i++) { const s = null !== e ? e.length : 0, r = this.getByIndex(i).embeddedTView(t, s); r && (r.indexInDeclarationView = i, null !== e ? e.push(r) : e = [r]) } return null !== e ? new kf(e) : null } template(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class If { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new If(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let i = t.parent; for (; null !== i && 8 & i.type && i.index !== e;)i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const i = this.metadata.predicate; if (Array.isArray(i)) for (let s = 0; s < i.length; s++) { const r = i[s]; this.matchTNodeWithReadOption(t, e, MP(e, r)), this.matchTNodeWithReadOption(t, e, vl(e, t, r, !1, !1)) } else i === Jn ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, vl(e, t, i, !1, !1)) } matchTNodeWithReadOption(t, e, i) { if (null !== i) { const s = this.metadata.read; if (null !== s) if (s === Xn || s === Ln || s === Jn && 4 & e.type) this.addMatch(e.index, -2); else { const r = vl(e, t, s, !1, !1); null !== r && this.addMatch(e.index, r) } else this.addMatch(e.index, i) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function MP(n, t) { const e = n.localNames; if (null !== e) for (let i = 0; i < e.length; i += 2)if (e[i] === t) return e[i + 1]; return null } function AP(n, t, e, i) { return -1 === e ? function TP(n, t) { return 11 & n.type ? Pr(n, t) : 4 & n.type ? tc(n, t) : null }(t, n) : -2 === e ? function kP(n, t, e) { return e === Xn ? Pr(t, n) : e === Jn ? tc(t, n) : e === Ln ? $1(t, n) : void 0 }(n, t, i) : ao(n, n[1], e, t) } function U1(n, t, e, i) { const s = t[19].queries[i]; if (null === s.matches) { const r = n.data, o = e.matches, a = []; for (let l = 0; l < o.length; l += 2) { const c = o[l]; a.push(c < 0 ? null : AP(t, r[c], o[l + 1], e.metadata.read)) } s.matches = a } return s.matches } function Pf(n, t, e, i) { const s = n.queries.getByIndex(e), r = s.matches; if (null !== r) { const o = U1(n, t, s, e); for (let a = 0; a < r.length; a += 2) { const l = r[a]; if (l > 0) i.push(o[a / 2]); else { const c = r[a + 1], u = t[-l]; for (let d = 10; d < u.length; d++) { const h = u[d]; h[17] === h[3] && Pf(h[1], h, c, i) } if (null !== u[9]) { const d = u[9]; for (let h = 0; h < d.length; h++) { const f = d[h]; Pf(f[1], f, c, i) } } } } } return i } function nc(n) { const t = E(), e = me(), i = yy(); Od(i + 1); const s = G1(e, i); if (n.dirty && uy(t) === (2 == (2 & s.metadata.flags))) { if (null === s.matches) n.reset([]); else { const r = s.crossesNgTemplate ? Pf(e, t, i, []) : U1(e, t, s, i); n.reset(r, VI), n.notifyOnChanges() } return !0 } return !1 } function ic(n, t, e, i) { const s = me(); if (s.firstCreatePass) { const r = ot(); (function q1(n, t, e) { null === n.queries && (n.queries = new kf), n.queries.track(new If(t, e)) })(s, new z1(t, e, i), r.index), function RP(n, t) { const e = n.contentQueries || (n.contentQueries = []); t !== (e.length ? e[e.length - 1] : -1) && e.push(n.queries.length - 1, t) }(s, n), 2 == (2 & e) && (s.staticContentQueries = !0) } !function W1(n, t, e) { const i = new Ef(4 == (4 & e)); S0(n, t, i, i.destroy), null === t[19] && (t[19] = new Af), t[19].queries.push(new Tf(i)) }(s, E(), e) } function G1(n, t) { return n.queries.getByIndex(t) } function oc(...n) { } const ac = new W("Application Initializer"); let lc = (() => { class n { constructor(e) { this.appInits = e, this.resolve = oc, this.reject = oc, this.initialized = !1, this.done = !1, this.donePromise = new Promise((i, s) => { this.resolve = i, this.reject = s }) } runInitializers() { if (this.initialized) return; const e = [], i = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let s = 0; s < this.appInits.length; s++) { const r = this.appInits[s](); if (Wl(r)) e.push(r); else if (J0(r)) { const o = new Promise((a, l) => { r.subscribe({ complete: a, error: l }) }); e.push(o) } } Promise.all(e).then(() => { i() }).catch(s => { this.reject(s) }), 0 === e.length && i(), this.initialized = !0 } } return n.\u0275fac = function (e) { return new (e || n)(k(ac, 8)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const zo = new W("AppId", { providedIn: "root", factory: function hb() { return `${Nf()}${Nf()}${Nf()}` } }); function Nf() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const fb = new W("Platform Initializer"), Uo = new W("Platform ID", { providedIn: "platform", factory: () => "unknown" }), pb = new W("appBootstrapListener"), gb = new W("AnimationModuleType"); let eR = (() => { class n { log(e) { console.log(e) } warn(e) { console.warn(e) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "platform" }), n })(); const mi = new W("LocaleId", { providedIn: "root", factory: () => gs(mi, U.Optional | U.SkipSelf) || function tR() { return typeof $localize < "u" && $localize.locale || kr }() }); class iR { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } let jf = (() => { class n { compileModuleSync(e) { return new Df(e) } compileModuleAsync(e) { return Promise.resolve(this.compileModuleSync(e)) } compileModuleAndAllComponentsSync(e) { const i = this.compileModuleSync(e), r = hi(Jt(e).declarations).reduce((o, a) => { const l = ke(a); return l && o.push(new wf(l)), o }, []); return new iR(i, r) } compileModuleAndAllComponentsAsync(e) { return Promise.resolve(this.compileModuleAndAllComponentsSync(e)) } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const oR = (() => Promise.resolve(0))(); function Bf(n) { typeof Zone > "u" ? oR.then(() => { n && n.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", n) } class Ve { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: i = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Re(!1), this.onMicrotaskEmpty = new Re(!1), this.onStable = new Re(!1), this.onError = new Re(!1), typeof Zone > "u") throw new T(908, !1); Zone.assertZonePatched(); const s = this; s._nesting = 0, s._outer = s._inner = Zone.current, Zone.TaskTrackingZoneSpec && (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)), s.shouldCoalesceEventChangeDetection = !i && e, s.shouldCoalesceRunChangeDetection = i, s.lastRequestAnimationFrameId = -1, s.nativeRequestAnimationFrame = function aR() { let n = Se.requestAnimationFrame, t = Se.cancelAnimationFrame; if (typeof Zone < "u" && n && t) { const e = n[Zone.__symbol__("OriginalDelegate")]; e && (n = e); const i = t[Zone.__symbol__("OriginalDelegate")]; i && (t = i) } return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function uR(n) { const t = () => { !function cR(n) { n.isCheckStableRunning || -1 !== n.lastRequestAnimationFrameId || (n.lastRequestAnimationFrameId = n.nativeRequestAnimationFrame.call(Se, () => { n.fakeTopEventTask || (n.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { n.lastRequestAnimationFrameId = -1, Hf(n), n.isCheckStableRunning = !0, Vf(n), n.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), n.fakeTopEventTask.invoke() }), Hf(n)) }(n) }; n._inner = n._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (e, i, s, r, o, a) => { try { return vb(n), e.invokeTask(s, r, o, a) } finally { (n.shouldCoalesceEventChangeDetection && "eventTask" === r.type || n.shouldCoalesceRunChangeDetection) && t(), _b(n) } }, onInvoke: (e, i, s, r, o, a, l) => { try { return vb(n), e.invoke(s, r, o, a, l) } finally { n.shouldCoalesceRunChangeDetection && t(), _b(n) } }, onHasTask: (e, i, s, r) => { e.hasTask(s, r), i === s && ("microTask" == r.change ? (n._hasPendingMicrotasks = r.microTask, Hf(n), Vf(n)) : "macroTask" == r.change && (n.hasPendingMacrotasks = r.macroTask)) }, onHandleError: (e, i, s, r) => (e.handleError(s, r), n.runOutsideAngular(() => n.onError.emit(r)), !1) }) }(s) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Ve.isInAngularZone()) throw new T(909, !1) } static assertNotInAngularZone() { if (Ve.isInAngularZone()) throw new T(909, !1) } run(t, e, i) { return this._inner.run(t, e, i) } runTask(t, e, i, s) { const r = this._inner, o = r.scheduleEventTask("NgZoneEvent: " + s, t, lR, oc, oc); try { return r.runTask(o, e, i) } finally { r.cancelTask(o) } } runGuarded(t, e, i) { return this._inner.runGuarded(t, e, i) } runOutsideAngular(t) { return this._outer.run(t) } } const lR = {}; function Vf(n) { if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable) try { n._nesting++, n.onMicrotaskEmpty.emit(null) } finally { if (n._nesting--, !n.hasPendingMicrotasks) try { n.runOutsideAngular(() => n.onStable.emit(null)) } finally { n.isStable = !0 } } } function Hf(n) { n.hasPendingMicrotasks = !!(n._hasPendingMicrotasks || (n.shouldCoalesceEventChangeDetection || n.shouldCoalesceRunChangeDetection) && -1 !== n.lastRequestAnimationFrameId) } function vb(n) { n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null)) } function _b(n) { n._nesting--, Vf(n) } class dR { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Re, this.onMicrotaskEmpty = new Re, this.onStable = new Re, this.onError = new Re } run(t, e, i) { return t.apply(e, i) } runGuarded(t, e, i) { return t.apply(e, i) } runOutsideAngular(t) { return t() } runTask(t, e, i, s) { return t.apply(e, i) } } const bb = new W(""), cc = new W(""); let Uf, $f = (() => { class n { constructor(e, i, s) { this._ngZone = e, this.registry = i, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Uf || (function hR(n) { Uf = n }(s), s.addToWindow(i)), this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Ve.assertNotInAngularZone(), Bf(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Bf(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, i, s) { let r = -1; i && i > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(o => o.timeoutId !== r), e(this._didWork, this.getPendingTasks()) }, i)), this._callbacks.push({ doneCb: e, timeoutId: r, updateCb: s }) } whenStable(e, i, s) { if (s && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(e, i, s), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(e) { this.registry.registerApplication(e, this) } unregisterApplication(e) { this.registry.unregisterApplication(e) } findProviders(e, i, s) { return [] } } return n.\u0275fac = function (e) { return new (e || n)(k(Ve), k(zf), k(cc)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), zf = (() => { class n { constructor() { this._applications = new Map } registerApplication(e, i) { this._applications.set(e, i) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, i = !0) { return Uf?.findTestabilityInTree(this, e, i) ?? null } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "platform" }), n })(), Ui = null; const wb = new W("AllowMultipleToken"), Wf = new W("PlatformDestroyListeners"); class Db { constructor(t, e) { this.name = t, this.token = e } } function Cb(n, t, e = []) { const i = `Platform: ${t}`, s = new W(i); return (r = []) => { let o = qf(); if (!o || o.injector.get(wb, !1)) { const a = [...e, ...r, { provide: s, useValue: !0 }]; n ? n(a) : function gR(n) { if (Ui && !Ui.get(wb, !1)) throw new T(400, !1); Ui = n; const t = n.get(Eb); (function xb(n) { const t = n.get(fb, null); t && t.forEach(e => e()) })(n) }(function Sb(n = [], t) { return Nt.create({ name: t, providers: [{ provide: Sh, useValue: "platform" }, { provide: Wf, useValue: new Set([() => Ui = null]) }, ...n] }) }(a, i)) } return function yR(n) { const t = qf(); if (!t) throw new T(401, !1); return t }() } } function qf() { return Ui?.get(Eb) ?? null } let Eb = (() => { class n { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, i) { const s = function vR(n, t) { let e; return e = "noop" === n ? new dR : ("zone.js" === n ? void 0 : n) || new Ve(t), e }(i?.ngZone, function Mb(n) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!n || !n.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!n || !n.ngZoneRunCoalescing) || !1 } }(i)), r = [{ provide: Ve, useValue: s }]; return s.run(() => { const o = Nt.create({ providers: r, parent: this.injector, name: e.moduleType.name }), a = e.create(o), l = a.injector.get(ms, null); if (!l) throw new T(402, !1); return s.runOutsideAngular(() => { const c = s.onError.subscribe({ next: u => { l.handleError(u) } }); a.onDestroy(() => { uc(this._modules, a), c.unsubscribe() }) }), function Tb(n, t, e) { try { const i = e(); return Wl(i) ? i.catch(s => { throw t.runOutsideAngular(() => n.handleError(s)), s }) : i } catch (i) { throw t.runOutsideAngular(() => n.handleError(i)), i } }(l, s, () => { const c = a.injector.get(lc); return c.runInitializers(), c.donePromise.then(() => (function Z_(n) { Yt(n, "Expected localeId to be defined"), "string" == typeof n && (Q_ = n.toLowerCase().replace(/_/g, "-")) }(a.injector.get(mi, kr) || kr), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(e, i = []) { const s = Ab({}, i); return function fR(n, t, e) { const i = new Df(e); return Promise.resolve(i) }(0, 0, e).then(r => this.bootstrapModuleFactory(r, s)) } _moduleDoBootstrap(e) { const i = e.injector.get(Wo); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(s => i.bootstrap(s)); else { if (!e.instance.ngDoBootstrap) throw new T(403, !1); e.instance.ngDoBootstrap(i) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new T(404, !1); this._modules.slice().forEach(i => i.destroy()), this._destroyListeners.forEach(i => i()); const e = this._injector.get(Wf, null); e && (e.forEach(i => i()), e.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return n.\u0275fac = function (e) { return new (e || n)(k(Nt)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "platform" }), n })(); function Ab(n, t) { return Array.isArray(t) ? t.reduce(Ab, n) : { ...n, ...t } } let Wo = (() => { class n { constructor(e, i, s) { this._zone = e, this._injector = i, this._exceptionHandler = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const r = new $e(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), o = new $e(a => { let l; this._zone.runOutsideAngular(() => { l = this._zone.onStable.subscribe(() => { Ve.assertNotInAngularZone(), Bf(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const c = this._zone.onUnstable.subscribe(() => { Ve.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { l.unsubscribe(), c.unsubscribe() } }); this.isStable = $n(r, o.pipe(Zm())) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(e, i) { const s = e instanceof S1; if (!this._injector.get(lc).done) throw !s && function Or(n) { const t = ke(n) || Pt(n) || Rt(n); return null !== t && t.standalone }(e), new T(405, false); let o; o = s ? e : this._injector.get(Lo).resolveComponentFactory(e), this.componentTypes.push(o.componentType); const a = function pR(n) { return n.isBoundToModule }(o) ? void 0 : this._injector.get(zi), c = o.create(Nt.NULL, [], i || o.selector, a), u = c.location.nativeElement, d = c.injector.get(bb, null); return d?.registerApplication(u), c.onDestroy(() => { this.detachView(c.hostView), uc(this.components, c), d?.unregisterApplication(u) }), this._loadComponent(c), c } tick() { if (this._runningTick) throw new T(101, !1); try { this._runningTick = !0; for (let e of this._views) e.detectChanges() } catch (e) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e)) } finally { this._runningTick = !1 } } attachView(e) { const i = e; this._views.push(i), i.attachToAppRef(this) } detachView(e) { const i = e; uc(this._views, i), i.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(pb, []).concat(this._bootstrapListeners).forEach(s => s(e)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(e => e()), this._views.slice().forEach(e => e.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(e) { return this._destroyListeners.push(e), () => uc(this._destroyListeners, e) } destroy() { if (this._destroyed) throw new T(406, !1); const e = this._injector; e.destroy && !e.destroyed && e.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return n.\u0275fac = function (e) { return new (e || n)(k(Ve), k(Nt), k(ms)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function uc(n, t) { const e = n.indexOf(t); e > -1 && n.splice(e, 1) } let Ib = !0, Pb = !1, qo = (() => { class n { } return n.__NG_ELEMENT_ID__ = DR, n })(); function DR(n) { return function xR(n, t, e) { if (ol(n) && !e) { const i = tn(n.index, t); return new jo(i, i) } return 47 & n.type ? new jo(t[16], t) : null }(ot(), E(), 16 == (16 & n)) } class Fb { constructor() { } supports(t) { return Eo(t) } create(t) { return new AR(t) } } const TR = (n, t) => t; class AR { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || TR } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, i = this._removalsHead, s = 0, r = null; for (; e || i;) { const o = !i || e && e.currentIndex < jb(i, s, r) ? e : i, a = jb(o, s, r), l = o.currentIndex; if (o === i) s--, i = i._nextRemoved; else if (e = e._next, null == o.previousIndex) s++; else { r || (r = []); const c = a - s, u = l - s; if (c != u) { for (let h = 0; h < c; h++) { const f = h < r.length ? r[h] : r[h] = 0, p = f + h; u <= p && p < c && (r[h] = f + 1) } r[o.previousIndex] = u - c } } a !== l && t(o, a, l) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Eo(t)) throw new T(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let s, r, o, e = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)r = t[a], o = this._trackByFn(a, r), null !== e && Object.is(e.trackById, o) ? (i && (e = this._verifyReinsertion(e, r, o, a)), Object.is(e.item, r) || this._addIdentityChange(e, r)) : (e = this._mismatch(e, r, o, a), i = !0), e = e._next } else s = 0, function Hk(n, t) { if (Array.isArray(n)) for (let e = 0; e < n.length; e++)t(n[e]); else { const e = n[bs()](); let i; for (; !(i = e.next()).done;)t(i.value) } }(t, a => { o = this._trackByFn(s, a), null !== e && Object.is(e.trackById, o) ? (i && (e = this._verifyReinsertion(e, a, o, s)), Object.is(e.item, a) || this._addIdentityChange(e, a)) : (e = this._mismatch(e, a, o, s), i = !0), e = e._next, s++ }), this.length = s; return this._truncate(e), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, i, s) { let r; return null === t ? r = this._itTail : (r = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, r, s)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, s)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, r, s)) : t = this._addAfter(new kR(e, i), r, s), t } _verifyReinsertion(t, e, i, s) { let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== r ? t = this._reinsertAfter(r, t._prev, s) : t.currentIndex != s && (t.currentIndex = s, this._addToMoves(t, s)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const s = t._prevRemoved, r = t._nextRemoved; return null === s ? this._removalsHead = r : s._nextRemoved = r, null === r ? this._removalsTail = s : r._prevRemoved = s, this._insertAfter(t, e, i), this._addToMoves(t, i), t } _moveAfter(t, e, i) { return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t } _addAfter(t, e, i) { return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, i) { const s = null === e ? this._itHead : e._next; return t._next = s, t._prev = e, null === s ? this._itTail = t : s._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Nb), this._linkedRecords.put(t), t.currentIndex = i, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, i = t._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Nb), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class kR { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class IR { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let i; for (i = this._head; null !== i; i = i._nextDup)if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, t)) return i; return null } remove(t) { const e = t._prevDup, i = t._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class Nb { constructor() { this.map = new Map } put(t) { const e = t.trackById; let i = this.map.get(e); i || (i = new IR, this.map.set(e, i)), i.add(t) } get(t, e) { const s = this.map.get(t); return s ? s.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function jb(n, t, e) { const i = n.previousIndex; if (null === i) return i; let s = 0; return e && i < e.length && (s = e[i]), i + t + s } class Bb { constructor() { } supports(t) { return t instanceof Map || lf(t) } create() { return new PR } } class PR { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || lf(t))) throw new T(900, !1) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (i, s) => { if (e && e.key === s) this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(s, i); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let i = e; null !== i; i = i._nextRemoved)i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const i = t._prev; return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const s = this._records.get(t); this._maybeAddToChanges(s, e); const r = s._prev, o = s._next; return r && (r._next = o), o && (o._prev = r), s._next = null, s._prev = null, s } const i = new RR(t); return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i)) } } class RR { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Vb() { return new fc([new Fb]) } let fc = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (null != i) { const s = i.factories.slice(); e = e.concat(s) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || Vb()), deps: [[n, new mo, new Bi]] } } find(e) { const i = this.factories.find(s => s.supports(e)); if (null != i) return i; throw new T(901, !1) } } return n.\u0275prov = V({ token: n, providedIn: "root", factory: Vb }), n })(); function Hb() { return new Go([new Bb]) } let Go = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (i) { const s = i.factories.slice(); e = e.concat(s) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || Hb()), deps: [[n, new mo, new Bi]] } } find(e) { const i = this.factories.find(s => s.supports(e)); if (i) return i; throw new T(901, !1) } } return n.\u0275prov = V({ token: n, providedIn: "root", factory: Hb }), n })(); const FR = Cb(null, "core", []); let NR = (() => { class n { constructor(e) { } } return n.\u0275fac = function (e) { return new (e || n)(k(Wo)) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({}), n })(); function Fr(n) { return "boolean" == typeof n ? n : null != n && "false" !== n } let pc = null; function Wi() { return pc } const vt = new W("DocumentToken"); let gc = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: function () { return function HR() { return k($b) }() }, providedIn: "platform" }), n })(); const $R = new W("Location Initialized"); let $b = (() => { class n extends gc { constructor(e) { super(), this._doc = e, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Wi().getBaseHref(this._doc) } onPopState(e) { const i = Wi().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e) } onHashChange(e) { const i = Wi().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(e) { this.location.pathname = e } pushState(e, i, s) { zb() ? this._history.pushState(e, i, s) : this.location.hash = s } replaceState(e, i, s) { zb() ? this._history.replaceState(e, i, s) : this.location.hash = s } forward() { this._history.forward() } back() { this._history.back() } historyGo(e = 0) { this._history.go(e) } getState() { return this._history.state } } return n.\u0275fac = function (e) { return new (e || n)(k(vt)) }, n.\u0275prov = V({ token: n, factory: function () { return function zR() { return new $b(k(vt)) }() }, providedIn: "platform" }), n })(); function zb() { return !!window.history.pushState } function Yf(n, t) { if (0 == n.length) return t; if (0 == t.length) return n; let e = 0; return n.endsWith("/") && e++, t.startsWith("/") && e++, 2 == e ? n + t.substring(1) : 1 == e ? n + t : n + "/" + t } function Ub(n) { const t = n.match(/#|\?|$/), e = t && t.index || n.length; return n.slice(0, e - ("/" === n[e - 1] ? 1 : 0)) + n.slice(e) } function vi(n) { return n && "?" !== n[0] ? "?" + n : n } let Ss = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: function () { return function UR() { const n = k(vt).location; return new qb(k(gc), n && n.origin || "") }() }, providedIn: "root" }), n })(); const Wb = new W("appBaseHref"); let qb = (() => { class n extends Ss { constructor(e, i) { if (super(), this._platformLocation = e, this._removeListenerFns = [], null == i && (i = this._platformLocation.getBaseHrefFromDOM()), null == i) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = i } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return Yf(this._baseHref, e) } path(e = !1) { const i = this._platformLocation.pathname + vi(this._platformLocation.search), s = this._platformLocation.hash; return s && e ? `${i}${s}` : i } pushState(e, i, s, r) { const o = this.prepareExternalUrl(s + vi(r)); this._platformLocation.pushState(e, i, o) } replaceState(e, i, s, r) { const o = this.prepareExternalUrl(s + vi(r)); this._platformLocation.replaceState(e, i, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(e = 0) { this._platformLocation.historyGo?.(e) } } return n.\u0275fac = function (e) { return new (e || n)(k(gc), k(Wb, 8)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), WR = (() => { class n extends Ss { constructor(e, i) { super(), this._platformLocation = e, this._baseHref = "", this._removeListenerFns = [], null != i && (this._baseHref = i) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } path(e = !1) { let i = this._platformLocation.hash; return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i } prepareExternalUrl(e) { const i = Yf(this._baseHref, e); return i.length > 0 ? "#" + i : i } pushState(e, i, s, r) { let o = this.prepareExternalUrl(s + vi(r)); 0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.pushState(e, i, o) } replaceState(e, i, s, r) { let o = this.prepareExternalUrl(s + vi(r)); 0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.replaceState(e, i, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(e = 0) { this._platformLocation.historyGo?.(e) } } return n.\u0275fac = function (e) { return new (e || n)(k(gc), k(Wb, 8)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), Xf = (() => { class n { constructor(e) { this._subject = new Re, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = e; const i = this._locationStrategy.getBaseHref(); this._baseHref = Ub(Gb(i)), this._locationStrategy.onPopState(s => { this._subject.emit({ url: this.path(!0), pop: !0, state: s.state, type: s.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(e = !1) { return this.normalize(this._locationStrategy.path(e)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(e, i = "") { return this.path() == this.normalize(e + vi(i)) } normalize(e) { return n.stripTrailingSlash(function GR(n, t) { return n && t.startsWith(n) ? t.substring(n.length) : t }(this._baseHref, Gb(e))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._locationStrategy.prepareExternalUrl(e) } go(e, i = "", s = null) { this._locationStrategy.pushState(s, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + vi(i)), s) } replaceState(e, i = "", s = null) { this._locationStrategy.replaceState(s, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + vi(i)), s) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(e = 0) { this._locationStrategy.historyGo?.(e) } onUrlChange(e) { return this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(i => { this._notifyUrlChangeListeners(i.url, i.state) })), () => { const i = this._urlChangeListeners.indexOf(e); this._urlChangeListeners.splice(i, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(e = "", i) { this._urlChangeListeners.forEach(s => s(e, i)) } subscribe(e, i, s) { return this._subject.subscribe({ next: e, error: i, complete: s }) } } return n.normalizeQueryParams = vi, n.joinWithSlash = Yf, n.stripTrailingSlash = Ub, n.\u0275fac = function (e) { return new (e || n)(k(Ss)) }, n.\u0275prov = V({ token: n, factory: function () { return function qR() { return new Xf(k(Ss)) }() }, providedIn: "root" }), n })(); function Gb(n) { return n.replace(/\/index.html$/, "") } function nw(n, t) { t = encodeURIComponent(t); for (const e of n.split(";")) { const i = e.indexOf("="), [s, r] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)]; if (s.trim() === t) return decodeURIComponent(r) } return null } let lp = (() => { class n { constructor(e, i, s, r) { this._iterableDiffers = e, this._keyValueDiffers = i, this._ngEl = s, this._renderer = r, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(e) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof e ? e.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(e) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof e ? e.split(/\s+/) : e, this._rawClass && (Eo(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const e = this._iterableDiffer.diff(this._rawClass); e && this._applyIterableChanges(e) } else if (this._keyValueDiffer) { const e = this._keyValueDiffer.diff(this._rawClass); e && this._applyKeyValueChanges(e) } } _applyKeyValueChanges(e) { e.forEachAddedItem(i => this._toggleClass(i.key, i.currentValue)), e.forEachChangedItem(i => this._toggleClass(i.key, i.currentValue)), e.forEachRemovedItem(i => { i.previousValue && this._toggleClass(i.key, !1) }) } _applyIterableChanges(e) { e.forEachAddedItem(i => { if ("string" != typeof i.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Me(i.item)}`); this._toggleClass(i.item, !0) }), e.forEachRemovedItem(i => this._toggleClass(i.item, !1)) } _applyClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(i => this._toggleClass(i, !0)) : Object.keys(e).forEach(i => this._toggleClass(i, !!e[i]))) } _removeClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(i => this._toggleClass(i, !1)) : Object.keys(e).forEach(i => this._toggleClass(i, !1))) } _toggleClass(e, i) { (e = e.trim()) && e.split(/\s+/g).forEach(s => { i ? this._renderer.addClass(this._ngEl.nativeElement, s) : this._renderer.removeClass(this._ngEl.nativeElement, s) }) } } return n.\u0275fac = function (e) { return new (e || n)(L(fc), L(Go), L(Xn), L(No)) }, n.\u0275dir = mt({ type: n, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), n })(); class IO { constructor(t, e, i, s) { this.$implicit = t, this.ngForOf = e, this.index = i, this.count = s } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Zo = (() => { class n { constructor(e, i, s) { this._viewContainer = e, this._template = i, this._differs = s, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(e) { this._ngForOf = e, this._ngForOfDirty = !0 } set ngForTrackBy(e) { this._trackByFn = e } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(e) { e && (this._template = e) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const e = this._ngForOf; !this._differ && e && (this._differ = this._differs.find(e).create(this.ngForTrackBy)) } if (this._differ) { const e = this._differ.diff(this._ngForOf); e && this._applyChanges(e) } } _applyChanges(e) { const i = this._viewContainer; e.forEachOperation((s, r, o) => { if (null == s.previousIndex) i.createEmbeddedView(this._template, new IO(s.item, this._ngForOf, -1, -1), null === o ? void 0 : o); else if (null == o) i.remove(null === r ? void 0 : r); else if (null !== r) { const a = i.get(r); i.move(a, o), rw(a, s) } }); for (let s = 0, r = i.length; s < r; s++) { const a = i.get(s).context; a.index = s, a.count = r, a.ngForOf = this._ngForOf } e.forEachIdentityChange(s => { rw(i.get(s.currentIndex), s) }) } static ngTemplateContextGuard(e, i) { return !0 } } return n.\u0275fac = function (e) { return new (e || n)(L(Ln), L(Jn), L(fc)) }, n.\u0275dir = mt({ type: n, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), n })(); function rw(n, t) { n.context.$implicit = t.item } let Sc = (() => { class n { constructor(e, i) { this._viewContainer = e, this._context = new RO, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = i } set ngIf(e) { this._context.$implicit = this._context.ngIf = e, this._updateView() } set ngIfThen(e) { ow("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView() } set ngIfElse(e) { ow("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(e, i) { return !0 } } return n.\u0275fac = function (e) { return new (e || n)(L(Ln), L(Jn)) }, n.\u0275dir = mt({ type: n, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), n })(); class RO { constructor() { this.$implicit = null, this.ngIf = null } } function ow(n, t) { if (t && !t.createEmbeddedView) throw new Error(`${n} must be a TemplateRef, but received '${Me(t)}'.`) } let lw = (() => { class n { constructor(e, i, s) { this._ngEl = e, this._differs = i, this._renderer = s, this._ngStyle = null, this._differ = null } set ngStyle(e) { this._ngStyle = e, !this._differ && e && (this._differ = this._differs.find(e).create()) } ngDoCheck() { if (this._differ) { const e = this._differ.diff(this._ngStyle); e && this._applyChanges(e) } } _setStyle(e, i) { const [s, r] = e.split("."), o = -1 === s.indexOf("-") ? void 0 : zt.DashCase; null != i ? this._renderer.setStyle(this._ngEl.nativeElement, s, r ? `${i}${r}` : i, o) : this._renderer.removeStyle(this._ngEl.nativeElement, s, o) } _applyChanges(e) { e.forEachRemovedItem(i => this._setStyle(i.key, null)), e.forEachAddedItem(i => this._setStyle(i.key, i.currentValue)), e.forEachChangedItem(i => this._setStyle(i.key, i.currentValue)) } } return n.\u0275fac = function (e) { return new (e || n)(L(Xn), L(Go), L(No)) }, n.\u0275dir = mt({ type: n, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" } }), n })(), cw = (() => { class n { constructor(e) { this._viewContainerRef = e, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(e) { if (e.ngTemplateOutlet || e.ngTemplateOutletInjector) { const i = this._viewContainerRef; if (this._viewRef && i.remove(i.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: s, ngTemplateOutletContext: r, ngTemplateOutletInjector: o } = this; this._viewRef = i.createEmbeddedView(s, r, o ? { injector: o } : void 0) } else this._viewRef = null } else this._viewRef && e.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return n.\u0275fac = function (e) { return new (e || n)(L(Ln)) }, n.\u0275dir = mt({ type: n, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, features: [Li] }), n })(), fp = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({}), n })(); const dw = "browser"; function hw(n) { return n === dw } let a4 = (() => { class n { } return n.\u0275prov = V({ token: n, providedIn: "root", factory: () => new l4(k(vt), window) }), n })(); class l4 { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function c4(n, t) { const e = n.getElementById(t) || n.getElementsByName(t)[0]; if (e) return e; if ("function" == typeof n.createTreeWalker && n.body && (n.body.createShadowRoot || n.body.attachShadow)) { const i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT); let s = i.currentNode; for (; s;) { const r = s.shadowRoot; if (r) { const o = r.getElementById(t) || r.querySelector(`[name="${t}"]`); if (o) return o } s = i.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), e.focus()) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), i = e.left + this.window.pageXOffset, s = e.top + this.window.pageYOffset, r = this.offset(); this.window.scrollTo(i - r[0], s - r[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = fw(this.window.history) || fw(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function fw(n) { return Object.getOwnPropertyDescriptor(n, "scrollRestoration") } class pw { } class pp extends class u4 extends class VR { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function BR(n) { pc || (pc = n) }(new pp) } onAndCancel(t, e, i) { return t.addEventListener(e, i, !1), () => { t.removeEventListener(e, i, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = function d4() { return Yo = Yo || document.querySelector("base"), Yo ? Yo.getAttribute("href") : null }(); return null == e ? null : function h4(n) { Ec = Ec || document.createElement("a"), Ec.setAttribute("href", n); const t = Ec.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(e) } resetBaseElement() { Yo = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return nw(document.cookie, t) } } let Ec, Yo = null; const gw = new W("TRANSITION_ID"), p4 = [{ provide: ac, useFactory: function f4(n, t, e) { return () => { e.get(lc).donePromise.then(() => { const i = Wi(), s = t.querySelectorAll(`style[ng-transition="${n}"]`); for (let r = 0; r < s.length; r++)i.remove(s[r]) }) } }, deps: [gw, vt, Nt], multi: !0 }]; let m4 = (() => { class n { build() { return new XMLHttpRequest } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const Mc = new W("EventManagerPlugins"); let Xo = (() => { class n { constructor(e, i) { this._zone = i, this._eventNameToPlugin = new Map, e.forEach(s => s.manager = this), this._plugins = e.slice().reverse() } addEventListener(e, i, s) { return this._findPluginFor(i).addEventListener(e, i, s) } addGlobalEventListener(e, i, s) { return this._findPluginFor(i).addGlobalEventListener(e, i, s) } getZone() { return this._zone } _findPluginFor(e) { const i = this._eventNameToPlugin.get(e); if (i) return i; const s = this._plugins; for (let r = 0; r < s.length; r++) { const o = s[r]; if (o.supports(e)) return this._eventNameToPlugin.set(e, o), o } throw new Error(`No event manager plugin found for event ${e}`) } } return n.\u0275fac = function (e) { return new (e || n)(k(Mc), k(Ve)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class mw { constructor(t) { this._doc = t } addGlobalEventListener(t, e, i) { const s = Wi().getGlobalEventTarget(this._doc, t); if (!s) throw new Error(`Unsupported event target ${s} for event ${e}`); return this.addEventListener(s, e, i) } } let yw = (() => { class n { constructor() { this._stylesSet = new Set } addStyles(e) { const i = new Set; e.forEach(s => { this._stylesSet.has(s) || (this._stylesSet.add(s), i.add(s)) }), this.onStylesAdded(i) } onStylesAdded(e) { } getAllStyles() { return Array.from(this._stylesSet) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), Jo = (() => { class n extends yw { constructor(e) { super(), this._doc = e, this._hostNodes = new Map, this._hostNodes.set(e.head, []) } _addStylesToHost(e, i, s) { e.forEach(r => { const o = this._doc.createElement("style"); o.textContent = r, s.push(i.appendChild(o)) }) } addHost(e) { const i = []; this._addStylesToHost(this._stylesSet, e, i), this._hostNodes.set(e, i) } removeHost(e) { const i = this._hostNodes.get(e); i && i.forEach(vw), this._hostNodes.delete(e) } onStylesAdded(e) { this._hostNodes.forEach((i, s) => { this._addStylesToHost(e, s, i) }) } ngOnDestroy() { this._hostNodes.forEach(e => e.forEach(vw)) } } return n.\u0275fac = function (e) { return new (e || n)(k(vt)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); function vw(n) { Wi().remove(n) } const gp = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, mp = /%COMP%/g; function Tc(n, t, e) { for (let i = 0; i < t.length; i++) { let s = t[i]; Array.isArray(s) ? Tc(n, s, e) : (s = s.replace(mp, n), e.push(s)) } return e } function ww(n) { return t => { if ("__ngUnwrap__" === t) return n; !1 === n(t) && (t.preventDefault(), t.returnValue = !1) } } let Ac = (() => { class n { constructor(e, i, s) { this.eventManager = e, this.sharedStylesHost = i, this.appId = s, this.rendererByCompId = new Map, this.defaultRenderer = new yp(e) } createRenderer(e, i) { if (!e || !i) return this.defaultRenderer; switch (i.encapsulation) { case Mn.Emulated: { let s = this.rendererByCompId.get(i.id); return s || (s = new D4(this.eventManager, this.sharedStylesHost, i, this.appId), this.rendererByCompId.set(i.id, s)), s.applyToHost(e), s } case 1: case Mn.ShadowDom: return new x4(this.eventManager, this.sharedStylesHost, e, i); default: if (!this.rendererByCompId.has(i.id)) { const s = Tc(i.id, i.styles, []); this.sharedStylesHost.addStyles(s), this.rendererByCompId.set(i.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return n.\u0275fac = function (e) { return new (e || n)(k(Xo), k(Jo), k(zo)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class yp { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, e) { return e ? document.createElementNS(gp[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { (xw(t) ? t.content : t).appendChild(e) } insertBefore(t, e, i) { t && (xw(t) ? t.content : t).insertBefore(e, i) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let i = "string" == typeof t ? document.querySelector(t) : t; if (!i) throw new Error(`The selector "${t}" did not match any elements`); return e || (i.textContent = ""), i } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, i, s) { if (s) { e = s + ":" + e; const r = gp[s]; r ? t.setAttributeNS(r, e, i) : t.setAttribute(e, i) } else t.setAttribute(e, i) } removeAttribute(t, e, i) { if (i) { const s = gp[i]; s ? t.removeAttributeNS(s, e) : t.removeAttribute(`${i}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, i, s) { s & (zt.DashCase | zt.Important) ? t.style.setProperty(e, i, s & zt.Important ? "important" : "") : t.style[e] = i } removeStyle(t, e, i) { i & zt.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, i) { t[e] = i } setValue(t, e) { t.nodeValue = e } listen(t, e, i) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, ww(i)) : this.eventManager.addEventListener(t, e, ww(i)) } } function xw(n) { return "TEMPLATE" === n.tagName && void 0 !== n.content } class D4 extends yp { constructor(t, e, i, s) { super(t), this.component = i; const r = Tc(s + "-" + i.id, i.styles, []); e.addStyles(r), this.contentAttr = function _4(n) { return "_ngcontent-%COMP%".replace(mp, n) }(s + "-" + i.id), this.hostAttr = function b4(n) { return "_nghost-%COMP%".replace(mp, n) }(s + "-" + i.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const i = super.createElement(t, e); return super.setAttribute(i, this.contentAttr, ""), i } } class x4 extends yp { constructor(t, e, i, s) { super(t), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const r = Tc(s.id, s.styles, []); for (let o = 0; o < r.length; o++) { const a = document.createElement("style"); a.textContent = r[o], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, i) { return super.insertBefore(this.nodeOrShadowRoot(t), e, i) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let C4 = (() => { class n extends mw { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, i, s) { return e.addEventListener(i, s, !1), () => this.removeEventListener(e, i, s) } removeEventListener(e, i, s) { return e.removeEventListener(i, s) } } return n.\u0275fac = function (e) { return new (e || n)(k(vt)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const Cw = ["alt", "control", "meta", "shift"], E4 = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Sw = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, M4 = { alt: n => n.altKey, control: n => n.ctrlKey, meta: n => n.metaKey, shift: n => n.shiftKey }; let T4 = (() => { class n extends mw { constructor(e) { super(e) } supports(e) { return null != n.parseEventName(e) } addEventListener(e, i, s) { const r = n.parseEventName(i), o = n.eventCallback(r.fullKey, s, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Wi().onAndCancel(e, r.domEventName, o)) } static parseEventName(e) { const i = e.toLowerCase().split("."), s = i.shift(); if (0 === i.length || "keydown" !== s && "keyup" !== s) return null; const r = n._normalizeKey(i.pop()); let o = ""; if (Cw.forEach(l => { const c = i.indexOf(l); c > -1 && (i.splice(c, 1), o += l + ".") }), o += r, 0 != i.length || 0 === r.length) return null; const a = {}; return a.domEventName = s, a.fullKey = o, a } static getEventFullKey(e) { let i = "", s = function A4(n) { let t = n.key; if (null == t) { if (t = n.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === n.location && Sw.hasOwnProperty(t) && (t = Sw[t])) } return E4[t] || t }(e); return s = s.toLowerCase(), " " === s ? s = "space" : "." === s && (s = "dot"), Cw.forEach(r => { r != s && M4[r](e) && (i += r + ".") }), i += s, i } static eventCallback(e, i, s) { return r => { n.getEventFullKey(r) === e && s.runGuarded(() => i(r)) } } static _normalizeKey(e) { return "esc" === e ? "escape" : e } } return n.\u0275fac = function (e) { return new (e || n)(k(vt)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const R4 = Cb(FR, "browser", [{ provide: Uo, useValue: dw }, { provide: fb, useValue: function k4() { pp.makeCurrent() }, multi: !0 }, { provide: vt, useFactory: function P4() { return function WM(n) { Zd = n }(document), document }, deps: [] }]), Mw = new W(""), Tw = [{ provide: cc, useClass: class g4 { addToWindow(t) { Se.getAngularTestability = (i, s = !0) => { const r = t.findTestabilityInTree(i, s); if (null == r) throw new Error("Could not find testability for element."); return r }, Se.getAllAngularTestabilities = () => t.getAllTestabilities(), Se.getAllAngularRootElements = () => t.getAllRootElements(), Se.frameworkStabilizers || (Se.frameworkStabilizers = []), Se.frameworkStabilizers.push(i => { const s = Se.getAllAngularTestabilities(); let r = s.length, o = !1; const a = function (l) { o = o || l, r--, 0 == r && i(o) }; s.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(t, e, i) { return null == e ? null : t.getTestability(e) ?? (i ? Wi().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null) } }, deps: [] }, { provide: bb, useClass: $f, deps: [Ve, zf, cc] }, { provide: $f, useClass: $f, deps: [Ve, zf, cc] }], Aw = [{ provide: Sh, useValue: "root" }, { provide: ms, useFactory: function I4() { return new ms }, deps: [] }, { provide: Mc, useClass: C4, multi: !0, deps: [vt, Ve, Uo] }, { provide: Mc, useClass: T4, multi: !0, deps: [vt] }, { provide: Ac, useClass: Ac, deps: [Xo, Jo, zo] }, { provide: Fo, useExisting: Ac }, { provide: yw, useExisting: Jo }, { provide: Jo, useClass: Jo, deps: [vt] }, { provide: Xo, useClass: Xo, deps: [Mc, Ve] }, { provide: pw, useClass: m4, deps: [] }, []]; let kw = (() => { class n { constructor(e) { } static withServerTransition(e) { return { ngModule: n, providers: [{ provide: zo, useValue: e.appId }, { provide: gw, useExisting: zo }, p4] } } } return n.\u0275fac = function (e) { return new (e || n)(k(Mw, 12)) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({ providers: [...Aw, ...Tw], imports: [fp, NR] }), n })(), Iw = (() => { class n { constructor(e) { this._doc = e } getTitle() { return this._doc.title } setTitle(e) { this._doc.title = e || "" } } return n.\u0275fac = function (e) { return new (e || n)(k(vt)) }, n.\u0275prov = V({ token: n, factory: function (e) { let i = null; return i = e ? new e : function L4() { return new Iw(k(vt)) }(), i }, providedIn: "root" }), n })(); typeof window < "u" && window; class Ow { } const bi = "*"; function W4(n, t) { return { type: 7, name: n, definitions: t, options: {} } } function Lw(n, t = null) { return { type: 4, styles: t, timings: n } } function Fw(n, t = null) { return { type: 2, steps: n, options: t } } function kc(n) { return { type: 6, styles: n, offset: null } } function Nw(n, t, e) { return { type: 0, name: n, styles: t, options: e } } function jw(n, t, e = null) { return { type: 1, expr: n, animation: t, options: e } } function Bw(n) { Promise.resolve(null).then(n) } class ea { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._originalOnStartFns.push(t), this._onStartFns.push(t) } onDone(t) { this._originalOnDoneFns.push(t), this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { Bw(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class Vw { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, i = 0, s = 0; const r = this.players.length; 0 == r ? Bw(() => this._onFinish()) : this.players.forEach(o => { o.onDone(() => { ++e == r && this._onFinish() }), o.onDestroy(() => { ++i == r && this._onDestroy() }), o.onStart(() => { ++s == r && this._onStart() }) }), this.totalTime = this.players.reduce((o, a) => Math.max(o, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(i => { const s = i.totalTime ? Math.min(1, e / i.totalTime) : 1; i.setPosition(s) }) } getPosition() { const t = this.players.reduce((e, i) => null === e || i.totalTime > e.totalTime ? i : e, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } function Hw(n) { return new T(3e3, !1) } function EL() { return typeof window < "u" && typeof window.document < "u" } function wp() { return typeof process < "u" && "[object process]" === {}.toString.call(process) } function Gi(n) { switch (n.length) { case 0: return new ea; case 1: return n[0]; default: return new Vw(n) } } function $w(n, t, e, i, s = new Map, r = new Map) { const o = [], a = []; let l = -1, c = null; if (i.forEach(u => { const d = u.get("offset"), h = d == l, f = h && c || new Map; u.forEach((p, g) => { let m = g, y = p; if ("offset" !== g) switch (m = t.normalizePropertyName(m, o), y) { case "!": y = s.get(g); break; case bi: y = r.get(g); break; default: y = t.normalizeStyleValue(g, m, y, o) }f.set(m, y) }), h || a.push(f), c = f, l = d }), o.length) throw function pL(n) { return new T(3502, !1) }(); return a } function Dp(n, t, e, i) { switch (t) { case "start": n.onStart(() => i(e && xp(e, "start", n))); break; case "done": n.onDone(() => i(e && xp(e, "done", n))); break; case "destroy": n.onDestroy(() => i(e && xp(e, "destroy", n))) } } function xp(n, t, e) { const r = Cp(n.element, n.triggerName, n.fromState, n.toState, t || n.phaseName, e.totalTime ?? n.totalTime, !!e.disabled), o = n._data; return null != o && (r._data = o), r } function Cp(n, t, e, i, s = "", r = 0, o) { return { element: n, triggerName: t, fromState: e, toState: i, phaseName: s, totalTime: r, disabled: !!o } } function on(n, t, e) { let i = n.get(t); return i || n.set(t, i = e), i } function zw(n) { const t = n.indexOf(":"); return [n.substring(1, t), n.slice(t + 1)] } let Sp = (n, t) => !1, Uw = (n, t, e) => [], Ww = null; function Ep(n) { const t = n.parentNode || n.host; return t === Ww ? null : t } (wp() || typeof Element < "u") && (EL() ? (Ww = (() => document.documentElement)(), Sp = (n, t) => { for (; t;) { if (t === n) return !0; t = Ep(t) } return !1 }) : Sp = (n, t) => n.contains(t), Uw = (n, t, e) => { if (e) return Array.from(n.querySelectorAll(t)); const i = n.querySelector(t); return i ? [i] : [] }); let Es = null, qw = !1; const Gw = Sp, Kw = Uw; let Qw = (() => { class n { validateStyleProperty(e) { return function TL(n) { Es || (Es = function AL() { return typeof document < "u" ? document.body : null }() || {}, qw = !!Es.style && "WebkitAppearance" in Es.style); let t = !0; return Es.style && !function ML(n) { return "ebkit" == n.substring(1, 6) }(n) && (t = n in Es.style, !t && qw && (t = "Webkit" + n.charAt(0).toUpperCase() + n.slice(1) in Es.style)), t }(e) } matchesElement(e, i) { return !1 } containsElement(e, i) { return Gw(e, i) } getParentElement(e) { return Ep(e) } query(e, i, s) { return Kw(e, i, s) } computeStyle(e, i, s) { return s || "" } animate(e, i, s, r, o, a = [], l) { return new ea(s, r) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), Mp = (() => { class n { } return n.NOOP = new Qw, n })(); const Tp = "ng-enter", Ic = "ng-leave", Pc = "ng-trigger", Rc = ".ng-trigger", Yw = "ng-animating", Ap = ".ng-animating"; function Ki(n) { if ("number" == typeof n) return n; const t = n.match(/^(-?[\.\d]+)(m?s)/); return !t || t.length < 2 ? 0 : kp(parseFloat(t[1]), t[2]) } function kp(n, t) { return "s" === t ? 1e3 * n : n } function Oc(n, t, e) { return n.hasOwnProperty("duration") ? n : function PL(n, t, e) { let s, r = 0, o = ""; if ("string" == typeof n) { const a = n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return t.push(Hw()), { duration: 0, delay: 0, easing: "" }; s = kp(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (r = kp(parseFloat(l), a[4])); const c = a[5]; c && (o = c) } else s = n; if (!e) { let a = !1, l = t.length; s < 0 && (t.push(function q4() { return new T(3100, !1) }()), a = !0), r < 0 && (t.push(function G4() { return new T(3101, !1) }()), a = !0), a && t.splice(l, 0, Hw()) } return { duration: s, delay: r, easing: o } }(n, t, e) } function ta(n, t = {}) { return Object.keys(n).forEach(e => { t[e] = n[e] }), t } function Xw(n) { const t = new Map; return Object.keys(n).forEach(e => { t.set(e, n[e]) }), t } function Qi(n, t = new Map, e) { if (e) for (let [i, s] of e) t.set(i, s); for (let [i, s] of n) t.set(i, s); return t } function eD(n, t, e) { return e ? t + ":" + e + ";" : "" } function tD(n) { let t = ""; for (let e = 0; e < n.style.length; e++) { const i = n.style.item(e); t += eD(0, i, n.style.getPropertyValue(i)) } for (const e in n.style) n.style.hasOwnProperty(e) && !e.startsWith("_") && (t += eD(0, FL(e), n.style[e])); n.setAttribute("style", t) } function ei(n, t, e) { n.style && (t.forEach((i, s) => { const r = Pp(s); e && !e.has(s) && e.set(s, n.style[r]), n.style[r] = i }), wp() && tD(n)) } function Ms(n, t) { n.style && (t.forEach((e, i) => { const s = Pp(i); n.style[s] = "" }), wp() && tD(n)) } function na(n) { return Array.isArray(n) ? 1 == n.length ? n[0] : Fw(n) : n } const Ip = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function nD(n) { let t = []; if ("string" == typeof n) { let e; for (; e = Ip.exec(n);)t.push(e[1]); Ip.lastIndex = 0 } return t } function Lc(n, t, e) { const i = n.toString(), s = i.replace(Ip, (r, o) => { let a = t[o]; return null == a && (e.push(function Q4(n) { return new T(3003, !1) }()), a = ""), a.toString() }); return s == i ? n : s } function Fc(n) { const t = []; let e = n.next(); for (; !e.done;)t.push(e.value), e = n.next(); return t } const LL = /-+([a-z0-9])/g; function Pp(n) { return n.replace(LL, (...t) => t[1].toUpperCase()) } function FL(n) { return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function an(n, t, e) { switch (t.type) { case 7: return n.visitTrigger(t, e); case 0: return n.visitState(t, e); case 1: return n.visitTransition(t, e); case 2: return n.visitSequence(t, e); case 3: return n.visitGroup(t, e); case 4: return n.visitAnimate(t, e); case 5: return n.visitKeyframes(t, e); case 6: return n.visitStyle(t, e); case 8: return n.visitReference(t, e); case 9: return n.visitAnimateChild(t, e); case 10: return n.visitAnimateRef(t, e); case 11: return n.visitQuery(t, e); case 12: return n.visitStagger(t, e); default: throw function Z4(n) { return new T(3004, !1) }() } } function iD(n, t) { return window.getComputedStyle(n)[t] } function $L(n, t) { const e = []; return "string" == typeof n ? n.split(/\s*,\s*/).forEach(i => function zL(n, t, e) { if (":" == n[0]) { const l = function UL(n, t) { switch (n) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (e, i) => parseFloat(i) > parseFloat(e); case ":decrement": return (e, i) => parseFloat(i) < parseFloat(e); default: return t.push(function uL(n) { return new T(3016, !1) }()), "* => *" } }(n, e); if ("function" == typeof l) return void t.push(l); n = l } const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return e.push(function cL(n) { return new T(3015, !1) }()), t; const s = i[1], r = i[2], o = i[3]; t.push(sD(s, o)); "<" == r[0] && !("*" == s && "*" == o) && t.push(sD(o, s)) }(i, e, t)) : e.push(n), e } const Vc = new Set(["true", "1"]), Hc = new Set(["false", "0"]); function sD(n, t) { const e = Vc.has(n) || Hc.has(n), i = Vc.has(t) || Hc.has(t); return (s, r) => { let o = "*" == n || n == s, a = "*" == t || t == r; return !o && e && "boolean" == typeof s && (o = s ? Vc.has(n) : Hc.has(n)), !a && i && "boolean" == typeof r && (a = r ? Vc.has(t) : Hc.has(t)), o && a } } const WL = new RegExp("s*:selfs*,?", "g"); function Rp(n, t, e, i) { return new qL(n).build(t, e, i) } class qL { constructor(t) { this._driver = t } build(t, e, i) { const s = new QL(e); return this._resetContextStyleTimingState(s), an(this, na(t), s) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = new Map, t.collectedStyles.set("", new Map), t.currentTime = 0 } visitTrigger(t, e) { let i = e.queryCount = 0, s = e.depCount = 0; const r = [], o = []; return "@" == t.name.charAt(0) && e.errors.push(function X4() { return new T(3006, !1) }()), t.definitions.forEach(a => { if (this._resetContextStyleTimingState(e), 0 == a.type) { const l = a, c = l.name; c.toString().split(/\s*,\s*/).forEach(u => { l.name = u, r.push(this.visitState(l, e)) }), l.name = c } else if (1 == a.type) { const l = this.visitTransition(a, e); i += l.queryCount, s += l.depCount, o.push(l) } else e.errors.push(function J4() { return new T(3007, !1) }()) }), { type: 7, name: t.name, states: r, transitions: o, queryCount: i, depCount: s, options: null } } visitState(t, e) { const i = this.visitStyle(t.styles, e), s = t.options && t.options.params || null; if (i.containsDynamicStyles) { const r = new Set, o = s || {}; i.styles.forEach(a => { a instanceof Map && a.forEach(l => { nD(l).forEach(c => { o.hasOwnProperty(c) || r.add(c) }) }) }), r.size && (Fc(r.values()), e.errors.push(function eL(n, t) { return new T(3008, !1) }())) } return { type: 0, name: t.name, style: i, options: s ? { params: s } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const i = an(this, na(t.animation), e); return { type: 1, matchers: $L(t.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: Ts(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(i => an(this, i, e)), options: Ts(t.options) } } visitGroup(t, e) { const i = e.currentTime; let s = 0; const r = t.steps.map(o => { e.currentTime = i; const a = an(this, o, e); return s = Math.max(s, e.currentTime), a }); return e.currentTime = s, { type: 3, steps: r, options: Ts(t.options) } } visitAnimate(t, e) { const i = function YL(n, t) { if (n.hasOwnProperty("duration")) return n; if ("number" == typeof n) return Op(Oc(n, t).duration, 0, ""); const e = n; if (e.split(/\s+/).some(r => "{" == r.charAt(0) && "{" == r.charAt(1))) { const r = Op(0, 0, ""); return r.dynamic = !0, r.strValue = e, r } const s = Oc(e, t); return Op(s.duration, s.delay, s.easing) }(t.timings, e.errors); e.currentAnimateTimings = i; let s, r = t.styles ? t.styles : kc({}); if (5 == r.type) s = this.visitKeyframes(r, e); else { let o = t.styles, a = !1; if (!o) { a = !0; const c = {}; i.easing && (c.easing = i.easing), o = kc(c) } e.currentTime += i.duration + i.delay; const l = this.visitStyle(o, e); l.isEmptyStep = a, s = l } return e.currentAnimateTimings = null, { type: 4, timings: i, style: s, options: null } } visitStyle(t, e) { const i = this._makeStyleAst(t, e); return this._validateStyleAst(i, e), i } _makeStyleAst(t, e) { const i = [], s = Array.isArray(t.styles) ? t.styles : [t.styles]; for (let a of s) "string" == typeof a ? a === bi ? i.push(a) : e.errors.push(new T(3002, !1)) : i.push(Xw(a)); let r = !1, o = null; return i.forEach(a => { if (a instanceof Map && (a.has("easing") && (o = a.get("easing"), a.delete("easing")), !r)) for (let l of a.values()) if (l.toString().indexOf("{{") >= 0) { r = !0; break } }), { type: 6, styles: i, easing: o, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const i = e.currentAnimateTimings; let s = e.currentTime, r = e.currentTime; i && r > 0 && (r -= i.duration + i.delay), t.styles.forEach(o => { "string" != typeof o && o.forEach((a, l) => { const c = e.collectedStyles.get(e.currentQuerySelector), u = c.get(l); let d = !0; u && (r != s && r >= u.startTime && s <= u.endTime && (e.errors.push(function nL(n, t, e, i, s) { return new T(3010, !1) }()), d = !1), r = u.startTime), d && c.set(l, { startTime: r, endTime: s }), e.options && function OL(n, t, e) { const i = t.params || {}, s = nD(n); s.length && s.forEach(r => { i.hasOwnProperty(r) || e.push(function K4(n) { return new T(3001, !1) }()) }) }(a, e.options, e.errors) }) }) } visitKeyframes(t, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push(function iL() { return new T(3011, !1) }()), i; let r = 0; const o = []; let a = !1, l = !1, c = 0; const u = t.steps.map(y => { const b = this._makeStyleAst(y, e); let v = null != b.offset ? b.offset : function ZL(n) { if ("string" == typeof n) return null; let t = null; if (Array.isArray(n)) n.forEach(e => { if (e instanceof Map && e.has("offset")) { const i = e; t = parseFloat(i.get("offset")), i.delete("offset") } }); else if (n instanceof Map && n.has("offset")) { const e = n; t = parseFloat(e.get("offset")), e.delete("offset") } return t }(b.styles), D = 0; return null != v && (r++, D = b.offset = v), l = l || D < 0 || D > 1, a = a || D < c, c = D, o.push(D), b }); l && e.errors.push(function sL() { return new T(3012, !1) }()), a && e.errors.push(function rL() { return new T(3200, !1) }()); const d = t.steps.length; let h = 0; r > 0 && r < d ? e.errors.push(function oL() { return new T(3202, !1) }()) : 0 == r && (h = 1 / (d - 1)); const f = d - 1, p = e.currentTime, g = e.currentAnimateTimings, m = g.duration; return u.forEach((y, b) => { const v = h > 0 ? b == f ? 1 : h * b : o[b], D = v * m; e.currentTime = p + g.delay + D, g.duration = D, this._validateStyleAst(y, e), y.offset = v, i.styles.push(y) }), i } visitReference(t, e) { return { type: 8, animation: an(this, na(t.animation), e), options: Ts(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Ts(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Ts(t.options) } } visitQuery(t, e) { const i = e.currentQuerySelector, s = t.options || {}; e.queryCount++, e.currentQuery = t; const [r, o] = function GL(n) { const t = !!n.split(/\s*,\s*/).find(e => ":self" == e); return t && (n = n.replace(WL, "")), n = n.replace(/@\*/g, Rc).replace(/@\w+/g, e => Rc + "-" + e.slice(1)).replace(/:animating/g, Ap), [n, t] }(t.selector); e.currentQuerySelector = i.length ? i + " " + r : r, on(e.collectedStyles, e.currentQuerySelector, new Map); const a = an(this, na(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: r, limit: s.limit || 0, optional: !!s.optional, includeSelf: o, animation: a, originalSelector: t.selector, options: Ts(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push(function aL() { return new T(3013, !1) }()); const i = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : Oc(t.timings, e.errors, !0); return { type: 12, animation: an(this, na(t.animation), e), timings: i, options: null } } } class QL { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set } } function Ts(n) { return n ? (n = ta(n)).params && (n.params = function KL(n) { return n ? ta(n) : null }(n.params)) : n = {}, n } function Op(n, t, e) { return { duration: n, delay: t, easing: e } } function Lp(n, t, e, i, s, r, o = null, a = !1) { return { type: 1, element: n, keyframes: t, preStyleProps: e, postStyleProps: i, duration: s, delay: r, totalTime: s + r, easing: o, subTimeline: a } } class $c { constructor() { this._map = new Map } get(t) { return this._map.get(t) || [] } append(t, e) { let i = this._map.get(t); i || this._map.set(t, i = []), i.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const eF = new RegExp(":enter", "g"), nF = new RegExp(":leave", "g"); function Fp(n, t, e, i, s, r = new Map, o = new Map, a, l, c = []) { return (new iF).buildKeyframes(n, t, e, i, s, r, o, a, l, c) } class iF { buildKeyframes(t, e, i, s, r, o, a, l, c, u = []) { c = c || new $c; const d = new Np(t, e, c, s, r, u, []); d.options = l; const h = l.delay ? Ki(l.delay) : 0; d.currentTimeline.delayNextStep(h), d.currentTimeline.setStyles([o], null, d.errors, l), an(this, i, d); const f = d.timelines.filter(p => p.containsAnimation()); if (f.length && a.size) { let p; for (let g = f.length - 1; g >= 0; g--) { const m = f[g]; if (m.element === e) { p = m; break } } p && !p.allowOnlyTimelineStyles() && p.setStyles([a], null, d.errors, l) } return f.length ? f.map(p => p.buildKeyframes()) : [Lp(e, [], [], [], 0, h, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const i = e.subInstructions.get(e.element); if (i) { const s = e.createSubContext(t.options), r = e.currentTimeline.currentTime, o = this._visitSubInstructions(i, s, s.options); r != o && e.transformIntoNewTimeline(o) } e.previousNode = t } visitAnimateRef(t, e) { const i = e.createSubContext(t.options); i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, i) { let r = e.currentTimeline.currentTime; const o = null != i.duration ? Ki(i.duration) : null, a = null != i.delay ? Ki(i.delay) : null; return 0 !== o && t.forEach(l => { const c = e.appendInstructionToTimeline(l, o, a); r = Math.max(r, c.duration + c.delay) }), r } visitReference(t, e) { e.updateOptions(t.options, !0), an(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const i = e.subContextCount; let s = e; const r = t.options; if (r && (r.params || r.delay) && (s = e.createSubContext(r), s.transformIntoNewTimeline(), null != r.delay)) { 6 == s.previousNode.type && (s.currentTimeline.snapshotCurrentStyles(), s.previousNode = zc); const o = Ki(r.delay); s.delayNextStep(o) } t.steps.length && (t.steps.forEach(o => an(this, o, s)), s.currentTimeline.applyStylesToKeyframe(), s.subContextCount > i && s.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const i = []; let s = e.currentTimeline.currentTime; const r = t.options && t.options.delay ? Ki(t.options.delay) : 0; t.steps.forEach(o => { const a = e.createSubContext(t.options); r && a.delayNextStep(r), an(this, o, a), s = Math.max(s, a.currentTimeline.currentTime), i.push(a.currentTimeline) }), i.forEach(o => e.currentTimeline.mergeTimelineCollectedStyles(o)), e.transformIntoNewTimeline(s), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const i = t.strValue; return Oc(e.params ? Lc(i, e.params, e.errors) : i, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const i = e.currentAnimateTimings = this._visitTiming(t.timings, e), s = e.currentTimeline; i.delay && (e.incrementTime(i.delay), s.snapshotCurrentStyles()); const r = t.style; 5 == r.type ? this.visitKeyframes(r, e) : (e.incrementTime(i.duration), this.visitStyle(r, e), s.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const i = e.currentTimeline, s = e.currentAnimateTimings; !s && i.hasCurrentStyleProperties() && i.forwardFrame(); const r = s && s.easing || t.easing; t.isEmptyStep ? i.applyEmptyStep(r) : i.setStyles(t.styles, r, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const i = e.currentAnimateTimings, s = e.currentTimeline.duration, r = i.duration, a = e.createSubContext().currentTimeline; a.easing = i.easing, t.styles.forEach(l => { a.forwardTime((l.offset || 0) * r), a.setStyles(l.styles, l.easing, e.errors, e.options), a.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(s + r), e.previousNode = t } visitQuery(t, e) { const i = e.currentTimeline.currentTime, s = t.options || {}, r = s.delay ? Ki(s.delay) : 0; r && (6 === e.previousNode.type || 0 == i && e.currentTimeline.hasCurrentStyleProperties()) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = zc); let o = i; const a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!s.optional, e.errors); e.currentQueryTotal = a.length; let l = null; a.forEach((c, u) => { e.currentQueryIndex = u; const d = e.createSubContext(t.options, c); r && d.delayNextStep(r), c === e.element && (l = d.currentTimeline), an(this, t.animation, d), d.currentTimeline.applyStylesToKeyframe(), o = Math.max(o, d.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(o), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const i = e.parentContext, s = e.currentTimeline, r = t.timings, o = Math.abs(r.duration), a = o * (e.currentQueryTotal - 1); let l = o * e.currentQueryIndex; switch (r.duration < 0 ? "reverse" : r.easing) { case "reverse": l = a - l; break; case "full": l = i.currentStaggerTime }const u = e.currentTimeline; l && u.delayNextStep(l); const d = u.currentTime; an(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = s.currentTime - d + (s.startTime - i.currentTimeline.startTime) } } const zc = {}; class Np { constructor(t, e, i, s, r, o, a, l) { this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = s, this._leaveClassName = r, this.errors = o, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = zc, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new Uc(this._driver, e, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const i = t; let s = this.options; null != i.duration && (s.duration = Ki(i.duration)), null != i.delay && (s.delay = Ki(i.delay)); const r = i.params; if (r) { let o = s.params; o || (o = this.options.params = {}), Object.keys(r).forEach(a => { (!e || !o.hasOwnProperty(a)) && (o[a] = Lc(r[a], o, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const i = t.params = {}; Object.keys(e).forEach(s => { i[s] = e[s] }) } } return t } createSubContext(t = null, e, i) { const s = e || this.element, r = new Np(this._driver, s, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(s, i || 0)); return r.previousNode = this.previousNode, r.currentAnimateTimings = this.currentAnimateTimings, r.options = this._copyOptions(), r.updateOptions(t), r.currentQueryIndex = this.currentQueryIndex, r.currentQueryTotal = this.currentQueryTotal, r.parentContext = this, this.subContextCount++, r } transformIntoNewTimeline(t) { return this.previousNode = zc, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, i) { const s = { duration: e ?? t.duration, delay: this.currentTimeline.currentTime + (i ?? 0) + t.delay, easing: "" }, r = new sF(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, s, t.stretchStartingKeyframe); return this.timelines.push(r), s } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, i, s, r, o) { let a = []; if (s && a.push(this.element), t.length > 0) { t = (t = t.replace(eF, "." + this._enterClassName)).replace(nF, "." + this._leaveClassName); let c = this._driver.query(this.element, t, 1 != i); 0 !== i && (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)), a.push(...c) } return !r && 0 == a.length && o.push(function lL(n) { return new T(3014, !1) }()), a } } class Uc { constructor(t, e, i, s) { this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = s, this.duration = 0, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 === this._keyframes.size && this._pendingStyles.size; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new Uc(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles.set(t, e), this._globalTimelineStyles.set(t, e), this._styleSummary.set(t, { time: this.currentTime, value: e }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && this._previousKeyframe.set("easing", t); for (let [e, i] of this._globalTimelineStyles) this._backFill.set(e, i || bi), this._currentKeyframe.set(e, bi); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, i, s) { e && this._previousKeyframe.set("easing", e); const r = s && s.params || {}, o = function rF(n, t) { const e = new Map; let i; return n.forEach(s => { if ("*" === s) { i = i || t.keys(); for (let r of i) e.set(r, bi) } else Qi(s, e) }), e }(t, this._globalTimelineStyles); for (let [a, l] of o) { const c = Lc(l, r, i); this._pendingStyles.set(a, c), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) || bi), this._updateStyle(a, c) } } applyStylesToKeyframe() { 0 != this._pendingStyles.size && (this._pendingStyles.forEach((t, e) => { this._currentKeyframe.set(e, t) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((t, e) => { this._currentKeyframe.has(e) || this._currentKeyframe.set(e, t) })) } snapshotCurrentStyles() { for (let [t, e] of this._localTimelineStyles) this._pendingStyles.set(t, e), this._updateStyle(t, e) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { t._styleSummary.forEach((e, i) => { const s = this._styleSummary.get(i); (!s || e.time > s.time) && this._updateStyle(i, e.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, i = 1 === this._keyframes.size && 0 === this.duration; let s = []; this._keyframes.forEach((a, l) => { const c = Qi(a, new Map, this._backFill); c.forEach((u, d) => { "!" === u ? t.add(d) : u === bi && e.add(d) }), i || c.set("offset", l / this.duration), s.push(c) }); const r = t.size ? Fc(t.values()) : [], o = e.size ? Fc(e.values()) : []; if (i) { const a = s[0], l = new Map(a); a.set("offset", 0), l.set("offset", 1), s = [a, l] } return Lp(this.element, s, r, o, this.duration, this.startTime, this.easing, !1) } } class sF extends Uc { constructor(t, e, i, s, r, o, a = !1) { super(t, e, o.delay), this.keyframes = i, this.preStyleProps = s, this.postStyleProps = r, this._stretchStartingKeyframe = a, this.timings = { duration: o.duration, delay: o.delay, easing: o.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: i, easing: s } = this.timings; if (this._stretchStartingKeyframe && e) { const r = [], o = i + e, a = e / o, l = Qi(t[0]); l.set("offset", 0), r.push(l); const c = Qi(t[0]); c.set("offset", aD(a)), r.push(c); const u = t.length - 1; for (let d = 1; d <= u; d++) { let h = Qi(t[d]); const f = h.get("offset"); h.set("offset", aD((e + f * i) / o)), r.push(h) } i = o, e = 0, s = "", t = r } return Lp(this.element, t, this.preStyleProps, this.postStyleProps, i, e, s, !0) } } function aD(n, t = 3) { const e = Math.pow(10, t - 1); return Math.round(n * e) / e } class jp { } const oF = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]); class aF extends jp { normalizePropertyName(t, e) { return Pp(t) } normalizeStyleValue(t, e, i, s) { let r = ""; const o = i.toString().trim(); if (oF.has(e) && 0 !== i && "0" !== i) if ("number" == typeof i) r = "px"; else { const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && s.push(function Y4(n, t) { return new T(3005, !1) }()) } return o + r } } function lD(n, t, e, i, s, r, o, a, l, c, u, d, h) { return { type: 0, element: n, triggerName: t, isRemovalTransition: s, fromState: e, fromStyles: r, toState: i, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: d, errors: h } } const Bp = {}; class cD { constructor(t, e, i) { this._triggerName = t, this.ast = e, this._stateStyles = i } match(t, e, i, s) { return function lF(n, t, e, i, s) { return n.some(r => r(t, e, i, s)) }(this.ast.matchers, t, e, i, s) } buildStyles(t, e, i) { let s = this._stateStyles.get("*"); return void 0 !== t && (s = this._stateStyles.get(t?.toString()) || s), s ? s.buildStyles(e, i) : new Map } build(t, e, i, s, r, o, a, l, c, u) { const d = [], h = this.ast.options && this.ast.options.params || Bp, p = this.buildStyles(i, a && a.params || Bp, d), g = l && l.params || Bp, m = this.buildStyles(s, g, d), y = new Set, b = new Map, v = new Map, D = "void" === s, x = { params: cF(g, h), delay: this.ast.options?.delay }, S = u ? [] : Fp(t, e, this.ast.animation, r, o, p, m, x, c, d); let A = 0; if (S.forEach(B => { A = Math.max(B.duration + B.delay, A) }), d.length) return lD(e, this._triggerName, i, s, D, p, m, [], [], b, v, A, d); S.forEach(B => { const te = B.element, oe = on(b, te, new Set); B.preStyleProps.forEach(ve => oe.add(ve)); const J = on(v, te, new Set); B.postStyleProps.forEach(ve => J.add(ve)), te !== e && y.add(te) }); const F = Fc(y.values()); return lD(e, this._triggerName, i, s, D, p, m, S, F, b, v, A) } } function cF(n, t) { const e = ta(t); for (const i in n) n.hasOwnProperty(i) && null != n[i] && (e[i] = n[i]); return e } class uF { constructor(t, e, i) { this.styles = t, this.defaultParams = e, this.normalizer = i } buildStyles(t, e) { const i = new Map, s = ta(this.defaultParams); return Object.keys(t).forEach(r => { const o = t[r]; null !== o && (s[r] = o) }), this.styles.styles.forEach(r => { "string" != typeof r && r.forEach((o, a) => { o && (o = Lc(o, s, e)); const l = this.normalizer.normalizePropertyName(a, e); o = this.normalizer.normalizeStyleValue(a, l, o, e), i.set(l, o) }) }), i } } class hF { constructor(t, e, i) { this.name = t, this.ast = e, this._normalizer = i, this.transitionFactories = [], this.states = new Map, e.states.forEach(s => { this.states.set(s.name, new uF(s.style, s.options && s.options.params || {}, i)) }), uD(this.states, "true", "1"), uD(this.states, "false", "0"), e.transitions.forEach(s => { this.transitionFactories.push(new cD(t, s, this.states)) }), this.fallbackTransition = function fF(n, t, e) { return new cD(n, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(o, a) => !0], options: null, queryCount: 0, depCount: 0 }, t) }(t, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, i, s) { return this.transitionFactories.find(o => o.match(t, e, i, s)) || null } matchStyles(t, e, i) { return this.fallbackTransition.buildStyles(t, e, i) } } function uD(n, t, e) { n.has(t) ? n.has(e) || n.set(e, n.get(t)) : n.has(e) && n.set(t, n.get(e)) } const pF = new $c; class gF { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = new Map, this._playersById = new Map, this.players = [] } register(t, e) { const i = [], r = Rp(this._driver, e, i, []); if (i.length) throw function gL(n) { return new T(3503, !1) }(); this._animations.set(t, r) } _buildPlayer(t, e, i) { const s = t.element, r = $w(0, this._normalizer, 0, t.keyframes, e, i); return this._driver.animate(s, r, t.duration, t.delay, t.easing, [], !0) } create(t, e, i = {}) { const s = [], r = this._animations.get(t); let o; const a = new Map; if (r ? (o = Fp(this._driver, e, r, Tp, Ic, new Map, new Map, i, pF, s), o.forEach(u => { const d = on(a, u.element, new Map); u.postStyleProps.forEach(h => d.set(h, null)) })) : (s.push(function mL() { return new T(3300, !1) }()), o = []), s.length) throw function yL(n) { return new T(3504, !1) }(); a.forEach((u, d) => { u.forEach((h, f) => { u.set(f, this._driver.computeStyle(d, f, bi)) }) }); const c = Gi(o.map(u => { const d = a.get(u.element); return this._buildPlayer(u, new Map, d) })); return this._playersById.set(t, c), c.onDestroy(() => this.destroy(t)), this.players.push(c), c } destroy(t) { const e = this._getPlayer(t); e.destroy(), this._playersById.delete(t); const i = this.players.indexOf(e); i >= 0 && this.players.splice(i, 1) } _getPlayer(t) { const e = this._playersById.get(t); if (!e) throw function vL(n) { return new T(3301, !1) }(); return e } listen(t, e, i, s) { const r = Cp(e, "", "", ""); return Dp(this._getPlayer(t), i, r, s), () => { } } command(t, e, i, s) { if ("register" == i) return void this.register(t, s[0]); if ("create" == i) return void this.create(t, e, s[0] || {}); const r = this._getPlayer(t); switch (i) { case "play": r.play(); break; case "pause": r.pause(); break; case "reset": r.reset(); break; case "restart": r.restart(); break; case "finish": r.finish(); break; case "init": r.init(); break; case "setPosition": r.setPosition(parseFloat(s[0])); break; case "destroy": this.destroy(t) } } } const dD = "ng-animate-queued", Vp = "ng-animate-disabled", bF = [], hD = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, wF = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, yn = "__ng_removed"; class Hp { constructor(t, e = "") { this.namespaceId = e; const i = t && t.hasOwnProperty("value"); if (this.value = function SF(n) { return n ?? null }(i ? t.value : t), i) { const r = ta(t); delete r.value, this.options = r } else this.options = {}; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const i = this.options.params; Object.keys(e).forEach(s => { null == i[s] && (i[s] = e[s]) }) } } } const ia = "void", $p = new Hp(ia); class DF { constructor(t, e, i) { this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, vn(e, this._hostClassName) } listen(t, e, i, s) { if (!this._triggers.has(e)) throw function _L(n, t) { return new T(3302, !1) }(); if (null == i || 0 == i.length) throw function bL(n) { return new T(3303, !1) }(); if (!function EF(n) { return "start" == n || "done" == n }(i)) throw function wL(n, t) { return new T(3400, !1) }(); const r = on(this._elementListeners, t, []), o = { name: e, phase: i, callback: s }; r.push(o); const a = on(this._engine.statesByElement, t, new Map); return a.has(e) || (vn(t, Pc), vn(t, Pc + "-" + e), a.set(e, $p)), () => { this._engine.afterFlush(() => { const l = r.indexOf(o); l >= 0 && r.splice(l, 1), this._triggers.has(e) || a.delete(e) }) } } register(t, e) { return !this._triggers.has(t) && (this._triggers.set(t, e), !0) } _getTrigger(t) { const e = this._triggers.get(t); if (!e) throw function DL(n) { return new T(3401, !1) }(); return e } trigger(t, e, i, s = !0) { const r = this._getTrigger(e), o = new zp(this.id, e, t); let a = this._engine.statesByElement.get(t); a || (vn(t, Pc), vn(t, Pc + "-" + e), this._engine.statesByElement.set(t, a = new Map)); let l = a.get(e); const c = new Hp(i, this.id); if (!(i && i.hasOwnProperty("value")) && l && c.absorbOptions(l.options), a.set(e, c), l || (l = $p), c.value !== ia && l.value === c.value) { if (!function AF(n, t) { const e = Object.keys(n), i = Object.keys(t); if (e.length != i.length) return !1; for (let s = 0; s < e.length; s++) { const r = e[s]; if (!t.hasOwnProperty(r) || n[r] !== t[r]) return !1 } return !0 }(l.params, c.params)) { const g = [], m = r.matchStyles(l.value, l.params, g), y = r.matchStyles(c.value, c.params, g); g.length ? this._engine.reportError(g) : this._engine.afterFlush(() => { Ms(t, m), ei(t, y) }) } return } const h = on(this._engine.playersByElement, t, []); h.forEach(g => { g.namespaceId == this.id && g.triggerName == e && g.queued && g.destroy() }); let f = r.matchTransition(l.value, c.value, t, c.params), p = !1; if (!f) { if (!s) return; f = r.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: f, fromState: l, toState: c, player: o, isFallbackTransition: p }), p || (vn(t, dD), o.onStart(() => { Nr(t, dD) })), o.onDone(() => { let g = this.players.indexOf(o); g >= 0 && this.players.splice(g, 1); const m = this._engine.playersByElement.get(t); if (m) { let y = m.indexOf(o); y >= 0 && m.splice(y, 1) } }), this.players.push(o), h.push(o), o } deregister(t) { this._triggers.delete(t), this._engine.statesByElement.forEach(e => e.delete(t)), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(s => s.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const i = this._engine.driver.query(t, Rc, !0); i.forEach(s => { if (s[yn]) return; const r = this._engine.fetchNamespacesByElement(s); r.size ? r.forEach(o => o.triggerLeaveAnimation(s, e, !1, !0)) : this.clearElementCache(s) }), this._engine.afterFlushAnimationsDone(() => i.forEach(s => this.clearElementCache(s))) } triggerLeaveAnimation(t, e, i, s) { const r = this._engine.statesByElement.get(t), o = new Map; if (r) { const a = []; if (r.forEach((l, c) => { if (o.set(c, l.value), this._triggers.has(c)) { const u = this.trigger(t, c, ia, s); u && a.push(u) } }), a.length) return this._engine.markElementAsRemoved(this.id, t, !0, e, o), i && Gi(a).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), i = this._engine.statesByElement.get(t); if (e && i) { const s = new Set; e.forEach(r => { const o = r.name; if (s.has(o)) return; s.add(o); const l = this._triggers.get(o).fallbackTransition, c = i.get(o) || $p, u = new Hp(ia), d = new zp(this.id, o, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: o, transition: l, fromState: c, toState: u, player: d, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const i = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let s = !1; if (i.totalAnimations) { const r = i.players.length ? i.playersByQueriedElement.get(t) : []; if (r && r.length) s = !0; else { let o = t; for (; o = o.parentNode;)if (i.statesByElement.get(o)) { s = !0; break } } } if (this.prepareLeaveAnimationListeners(t), s) i.markElementAsRemoved(this.id, t, !1, e); else { const r = t[yn]; (!r || r === hD) && (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e)) } } insertNode(t, e) { vn(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(i => { const s = i.player; if (s.destroyed) return; const r = i.element, o = this._elementListeners.get(r); o && o.forEach(a => { if (a.name == i.triggerName) { const l = Cp(r, i.triggerName, i.fromState.value, i.toState.value); l._data = t, Dp(i.player, a.phase, l, a.callback) } }), s.markedForDestroy ? this._engine.afterFlush(() => { s.destroy() }) : e.push(i) }), this._queue = [], e.sort((i, s) => { const r = i.transition.ast.depCount, o = s.transition.ast.depCount; return 0 == r || 0 == o ? r - o : this._engine.driver.containsElement(i.element, s.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(i => i.element === t) || e, e } } class xF { constructor(t, e, i) { this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (s, r) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(i => { i.queued && t.push(i) }) }), t } createNamespace(t, e) { const i = new DF(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i } _balanceNamespaceList(t, e) { const i = this._namespaceList, s = this.namespacesByHostElement; if (i.length - 1 >= 0) { let o = !1, a = this.driver.getParentElement(e); for (; a;) { const l = s.get(a); if (l) { const c = i.indexOf(l); i.splice(c + 1, 0, t), o = !0; break } a = this.driver.getParentElement(a) } o || i.unshift(t) } else i.push(t); return s.set(e, t), t } register(t, e) { let i = this._namespaceLookup[t]; return i || (i = this.createNamespace(t, e)), i } registerTrigger(t, e, i) { let s = this._namespaceLookup[t]; s && s.register(e, i) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const i = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t]; const s = this._namespaceList.indexOf(i); s >= 0 && this._namespaceList.splice(s, 1) }), this.afterFlushAnimationsDone(() => i.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, i = this.statesByElement.get(t); if (i) for (let s of i.values()) if (s.namespaceId) { const r = this._fetchNamespace(s.namespaceId); r && e.add(r) } return e } trigger(t, e, i, s) { if (Wc(e)) { const r = this._fetchNamespace(t); if (r) return r.trigger(e, i, s), !0 } return !1 } insertNode(t, e, i, s) { if (!Wc(e)) return; const r = e[yn]; if (r && r.setForRemoval) { r.setForRemoval = !1, r.setForMove = !0; const o = this.collectedLeaveElements.indexOf(e); o >= 0 && this.collectedLeaveElements.splice(o, 1) } if (t) { const o = this._fetchNamespace(t); o && o.insertNode(e, i) } s && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), vn(t, Vp)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Nr(t, Vp)) } removeNode(t, e, i, s) { if (Wc(e)) { const r = t ? this._fetchNamespace(t) : null; if (r ? r.removeNode(e, s) : this.markElementAsRemoved(t, e, !1, s), i) { const o = this.namespacesByHostElement.get(e); o && o.id !== t && o.removeNode(e, s) } } else this._onRemovalComplete(e, s) } markElementAsRemoved(t, e, i, s, r) { this.collectedLeaveElements.push(e), e[yn] = { namespaceId: t, setForRemoval: s, hasAnimation: i, removedBeforeQueried: !1, previousTriggersValues: r } } listen(t, e, i, s, r) { return Wc(e) ? this._fetchNamespace(t).listen(e, i, s, r) : () => { } } _buildInstruction(t, e, i, s, r) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, s, t.fromState.options, t.toState.options, e, r) } destroyInnerAnimations(t) { let e = this.driver.query(t, Rc, !0); e.forEach(i => this.destroyActiveAnimationsForElement(i)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, Ap, !0), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(i => { i.queued ? i.markedForDestroy = !0 : i.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(i => i.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return Gi(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t[yn]; if (e && e.setForRemoval) { if (t[yn] = hD, e.namespaceId) { this.destroyInnerAnimations(t); const i = this._fetchNamespace(e.namespaceId); i && i.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } t.classList?.contains(Vp) && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(i => { this.markElementAsDisabled(i, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((i, s) => this._balanceNamespaceList(i, s)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++)vn(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, t) } finally { for (let s = 0; s < i.length; s++)i[s]() } } else for (let i = 0; i < this.collectedLeaveElements.length; i++)this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(i => i()), this._flushFns = [], this._whenQuietFns.length) { const i = this._whenQuietFns; this._whenQuietFns = [], e.length ? Gi(e).onDone(() => { i.forEach(s => s()) }) : i.forEach(s => s()) } } reportError(t) { throw function xL(n) { return new T(3402, !1) }() } _flushAnimations(t, e) { const i = new $c, s = [], r = new Map, o = [], a = new Map, l = new Map, c = new Map, u = new Set; this.disabledNodes.forEach(P => { u.add(P); const H = this.driver.query(P, ".ng-animate-queued", !0); for (let $ = 0; $ < H.length; $++)u.add(H[$]) }); const d = this.bodyNode, h = Array.from(this.statesByElement.keys()), f = gD(h, this.collectedEnterElements), p = new Map; let g = 0; f.forEach((P, H) => { const $ = Tp + g++; p.set(H, $), P.forEach(ce => vn(ce, $)) }); const m = [], y = new Set, b = new Set; for (let P = 0; P < this.collectedLeaveElements.length; P++) { const H = this.collectedLeaveElements[P], $ = H[yn]; $ && $.setForRemoval && (m.push(H), y.add(H), $.hasAnimation ? this.driver.query(H, ".ng-star-inserted", !0).forEach(ce => y.add(ce)) : b.add(H)) } const v = new Map, D = gD(h, Array.from(y)); D.forEach((P, H) => { const $ = Ic + g++; v.set(H, $), P.forEach(ce => vn(ce, $)) }), t.push(() => { f.forEach((P, H) => { const $ = p.get(H); P.forEach(ce => Nr(ce, $)) }), D.forEach((P, H) => { const $ = v.get(H); P.forEach(ce => Nr(ce, $)) }), m.forEach(P => { this.processLeaveNode(P) }) }); const x = [], S = []; for (let P = this._namespaceList.length - 1; P >= 0; P--)this._namespaceList[P].drainQueuedTransitions(e).forEach($ => { const ce = $.player, je = $.element; if (x.push(ce), this.collectedEnterElements.length) { const kt = je[yn]; if (kt && kt.setForMove) { if (kt.previousTriggersValues && kt.previousTriggersValues.has($.triggerName)) { const qs = kt.previousTriggersValues.get($.triggerName), Cn = this.statesByElement.get($.element); if (Cn && Cn.has($.triggerName)) { const td = Cn.get($.triggerName); td.value = qs, Cn.set($.triggerName, td) } } return void ce.destroy() } } const Ht = !d || !this.driver.containsElement(d, je), st = v.get(je), Kt = p.get(je), Ae = this._buildInstruction($, i, Kt, st, Ht); if (Ae.errors && Ae.errors.length) return void S.push(Ae); if (Ht) return ce.onStart(() => Ms(je, Ae.fromStyles)), ce.onDestroy(() => ei(je, Ae.toStyles)), void s.push(ce); if ($.isFallbackTransition) return ce.onStart(() => Ms(je, Ae.fromStyles)), ce.onDestroy(() => ei(je, Ae.toStyles)), void s.push(ce); const Qr = []; Ae.timelines.forEach(kt => { kt.stretchStartingKeyframe = !0, this.disabledNodes.has(kt.element) || Qr.push(kt) }), Ae.timelines = Qr, i.append(je, Ae.timelines), o.push({ instruction: Ae, player: ce, element: je }), Ae.queriedElements.forEach(kt => on(a, kt, []).push(ce)), Ae.preStyleProps.forEach((kt, qs) => { if (kt.size) { let Cn = l.get(qs); Cn || l.set(qs, Cn = new Set), kt.forEach((td, xm) => Cn.add(xm)) } }), Ae.postStyleProps.forEach((kt, qs) => { let Cn = c.get(qs); Cn || c.set(qs, Cn = new Set), kt.forEach((td, xm) => Cn.add(xm)) }) }); if (S.length) { const P = []; S.forEach(H => { P.push(function CL(n, t) { return new T(3505, !1) }()) }), x.forEach(H => H.destroy()), this.reportError(P) } const A = new Map, F = new Map; o.forEach(P => { const H = P.element; i.has(H) && (F.set(H, H), this._beforeAnimationBuild(P.player.namespaceId, P.instruction, A)) }), s.forEach(P => { const H = P.element; this._getPreviousPlayers(H, !1, P.namespaceId, P.triggerName, null).forEach(ce => { on(A, H, []).push(ce), ce.destroy() }) }); const B = m.filter(P => yD(P, l, c)), te = new Map; pD(te, this.driver, b, c, bi).forEach(P => { yD(P, l, c) && B.push(P) }); const J = new Map; f.forEach((P, H) => { pD(J, this.driver, new Set(P), l, "!") }), B.forEach(P => { const H = te.get(P), $ = J.get(P); te.set(P, new Map([...Array.from(H?.entries() ?? []), ...Array.from($?.entries() ?? [])])) }); const ve = [], Ke = [], ee = {}; o.forEach(P => { const { element: H, player: $, instruction: ce } = P; if (i.has(H)) { if (u.has(H)) return $.onDestroy(() => ei(H, ce.toStyles)), $.disabled = !0, $.overrideTotalTime(ce.totalTime), void s.push($); let je = ee; if (F.size > 1) { let st = H; const Kt = []; for (; st = st.parentNode;) { const Ae = F.get(st); if (Ae) { je = Ae; break } Kt.push(st) } Kt.forEach(Ae => F.set(Ae, je)) } const Ht = this._buildAnimation($.namespaceId, ce, A, r, J, te); if ($.setRealPlayer(Ht), je === ee) ve.push($); else { const st = this.playersByElement.get(je); st && st.length && ($.parentPlayer = Gi(st)), s.push($) } } else Ms(H, ce.fromStyles), $.onDestroy(() => ei(H, ce.toStyles)), Ke.push($), u.has(H) && s.push($) }), Ke.forEach(P => { const H = r.get(P.element); if (H && H.length) { const $ = Gi(H); P.setRealPlayer($) } }), s.forEach(P => { P.parentPlayer ? P.syncPlayerEvents(P.parentPlayer) : P.destroy() }); for (let P = 0; P < m.length; P++) { const H = m[P], $ = H[yn]; if (Nr(H, Ic), $ && $.hasAnimation) continue; let ce = []; if (a.size) { let Ht = a.get(H); Ht && Ht.length && ce.push(...Ht); let st = this.driver.query(H, Ap, !0); for (let Kt = 0; Kt < st.length; Kt++) { let Ae = a.get(st[Kt]); Ae && Ae.length && ce.push(...Ae) } } const je = ce.filter(Ht => !Ht.destroyed); je.length ? MF(this, H, je) : this.processLeaveNode(H) } return m.length = 0, ve.forEach(P => { this.players.push(P), P.onDone(() => { P.destroy(); const H = this.players.indexOf(P); this.players.splice(H, 1) }), P.play() }), ve } elementContainsData(t, e) { let i = !1; const s = e[yn]; return s && s.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, i, s, r) { let o = []; if (e) { const a = this.playersByQueriedElement.get(t); a && (o = a) } else { const a = this.playersByElement.get(t); if (a) { const l = !r || r == ia; a.forEach(c => { c.queued || !l && c.triggerName != s || o.push(c) }) } } return (i || s) && (o = o.filter(a => !(i && i != a.namespaceId || s && s != a.triggerName))), o } _beforeAnimationBuild(t, e, i) { const r = e.element, o = e.isRemovalTransition ? void 0 : t, a = e.isRemovalTransition ? void 0 : e.triggerName; for (const l of e.timelines) { const c = l.element, u = c !== r, d = on(i, c, []); this._getPreviousPlayers(c, u, o, a, e.toState).forEach(f => { const p = f.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), f.destroy(), d.push(f) }) } Ms(r, e.fromStyles) } _buildAnimation(t, e, i, s, r, o) { const a = e.triggerName, l = e.element, c = [], u = new Set, d = new Set, h = e.timelines.map(p => { const g = p.element; u.add(g); const m = g[yn]; if (m && m.removedBeforeQueried) return new ea(p.duration, p.delay); const y = g !== l, b = function TF(n) { const t = []; return mD(n, t), t }((i.get(g) || bF).map(A => A.getRealPlayer())).filter(A => !!A.element && A.element === g), v = r.get(g), D = o.get(g), x = $w(0, this._normalizer, 0, p.keyframes, v, D), S = this._buildPlayer(p, x, b); if (p.subTimeline && s && d.add(g), y) { const A = new zp(t, a, g); A.setRealPlayer(S), c.push(A) } return S }); c.forEach(p => { on(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => function CF(n, t, e) { let i = n.get(t); if (i) { if (i.length) { const s = i.indexOf(e); i.splice(s, 1) } 0 == i.length && n.delete(t) } return i }(this.playersByQueriedElement, p.element, p)) }), u.forEach(p => vn(p, Yw)); const f = Gi(h); return f.onDestroy(() => { u.forEach(p => Nr(p, Yw)), ei(l, e.toStyles) }), d.forEach(p => { on(s, p, []).push(f) }), f } _buildPlayer(t, e, i) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new ea(t.duration, t.delay) } } class zp { constructor(t, e, i) { this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new ea, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, this._queuedCallbacks.forEach((e, i) => { e.forEach(s => Dp(t, i, void 0, s)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { on(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Wc(n) { return n && 1 === n.nodeType } function fD(n, t) { const e = n.style.display; return n.style.display = t ?? "none", e } function pD(n, t, e, i, s) { const r = []; e.forEach(l => r.push(fD(l))); const o = []; i.forEach((l, c) => { const u = new Map; l.forEach(d => { const h = t.computeStyle(c, d, s); u.set(d, h), (!h || 0 == h.length) && (c[yn] = wF, o.push(c)) }), n.set(c, u) }); let a = 0; return e.forEach(l => fD(l, r[a++])), o } function gD(n, t) { const e = new Map; if (n.forEach(a => e.set(a, [])), 0 == t.length) return e; const s = new Set(t), r = new Map; function o(a) { if (!a) return 1; let l = r.get(a); if (l) return l; const c = a.parentNode; return l = e.has(c) ? c : s.has(c) ? 1 : o(c), r.set(a, l), l } return t.forEach(a => { const l = o(a); 1 !== l && e.get(l).push(a) }), e } function vn(n, t) { n.classList?.add(t) } function Nr(n, t) { n.classList?.remove(t) } function MF(n, t, e) { Gi(e).onDone(() => n.processLeaveNode(t)) } function mD(n, t) { for (let e = 0; e < n.length; e++) { const i = n[e]; i instanceof Vw ? mD(i.players, t) : t.push(i) } } function yD(n, t, e) { const i = e.get(n); if (!i) return !1; let s = t.get(n); return s ? i.forEach(r => s.add(r)) : t.set(n, i), e.delete(n), !0 } class qc { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._triggerCache = {}, this.onRemovalComplete = (s, r) => { }, this._transitionEngine = new xF(t, e, i), this._timelineEngine = new gF(t, e, i), this._transitionEngine.onRemovalComplete = (s, r) => this.onRemovalComplete(s, r) } registerTrigger(t, e, i, s, r) { const o = t + "-" + s; let a = this._triggerCache[o]; if (!a) { const l = [], u = Rp(this._driver, r, l, []); if (l.length) throw function fL(n, t) { return new T(3404, !1) }(); a = function dF(n, t, e) { return new hF(n, t, e) }(s, u, this._normalizer), this._triggerCache[o] = a } this._transitionEngine.registerTrigger(e, s, a) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, i, s) { this._transitionEngine.insertNode(t, e, i, s) } onRemove(t, e, i, s) { this._transitionEngine.removeNode(t, e, s || !1, i) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, i, s) { if ("@" == i.charAt(0)) { const [r, o] = zw(i); this._timelineEngine.command(r, e, o, s) } else this._transitionEngine.trigger(t, e, i, s) } listen(t, e, i, s, r) { if ("@" == i.charAt(0)) { const [o, a] = zw(i); return this._timelineEngine.listen(o, e, a, r) } return this._transitionEngine.listen(t, e, i, s, r) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } let IF = (() => { class n { constructor(e, i, s) { this._element = e, this._startStyles = i, this._endStyles = s, this._state = 0; let r = n.initialStylesByElement.get(e); r || n.initialStylesByElement.set(e, r = new Map), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && ei(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (ei(this._element, this._initialStyles), this._endStyles && (ei(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (n.initialStylesByElement.delete(this._element), this._startStyles && (Ms(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Ms(this._element, this._endStyles), this._endStyles = null), ei(this._element, this._initialStyles), this._state = 3) } } return n.initialStylesByElement = new WeakMap, n })(); function Up(n) { let t = null; return n.forEach((e, i) => { (function PF(n) { return "display" === n || "position" === n })(i) && (t = t || new Map, t.set(i, e)) }), t } class vD { constructor(t, e, i, s) { this.element = t, this.keyframes = e, this.options = i, this._specialStyles = s, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : new Map, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(t) { const e = []; return t.forEach(i => { e.push(Object.fromEntries(i)) }), e } _triggerWebAnimation(t, e, i) { return t.animate(this._convertKeyframesToObject(e), i) } onStart(t) { this._originalOnStartFns.push(t), this._onStartFns.push(t) } onDone(t) { this._originalOnDoneFns.push(t), this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = new Map; this.hasStarted() && this._finalKeyframe.forEach((i, s) => { "offset" !== s && t.set(s, this._finished ? i : iD(this.element, s)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" === t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class RF { validateStyleProperty(t) { return !0 } validateAnimatableStyleProperty(t) { return !0 } matchesElement(t, e) { return !1 } containsElement(t, e) { return Gw(t, e) } getParentElement(t) { return Ep(t) } query(t, e, i) { return Kw(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } animate(t, e, i, s, r, o = []) { const l = { duration: i, delay: s, fill: 0 == s ? "both" : "forwards" }; r && (l.easing = r); const c = new Map, u = o.filter(f => f instanceof vD); (function NL(n, t) { return 0 === n || 0 === t })(i, s) && u.forEach(f => { f.currentSnapshot.forEach((p, g) => c.set(g, p)) }); let d = function RL(n) { return n.length ? n[0] instanceof Map ? n : n.map(t => Xw(t)) : [] }(e).map(f => Qi(f)); d = function jL(n, t, e) { if (e.size && t.length) { let i = t[0], s = []; if (e.forEach((r, o) => { i.has(o) || s.push(o), i.set(o, r) }), s.length) for (let r = 1; r < t.length; r++) { let o = t[r]; s.forEach(a => o.set(a, iD(n, a))) } } return t }(t, d, c); const h = function kF(n, t) { let e = null, i = null; return Array.isArray(t) && t.length ? (e = Up(t[0]), t.length > 1 && (i = Up(t[t.length - 1]))) : t instanceof Map && (e = Up(t)), e || i ? new IF(n, e, i) : null }(t, d); return new vD(t, d, l, h) } } let OF = (() => { class n extends Ow { constructor(e, i) { super(), this._nextAnimationId = 0, this._renderer = e.createRenderer(i.body, { id: "0", encapsulation: Mn.None, styles: [], data: { animation: [] } }) } build(e) { const i = this._nextAnimationId.toString(); this._nextAnimationId++; const s = Array.isArray(e) ? Fw(e) : e; return _D(this._renderer, null, i, "register", [s]), new LF(i, this._renderer) } } return n.\u0275fac = function (e) { return new (e || n)(k(Fo), k(vt)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class LF extends class U4 { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new FF(this._id, t, e || {}, this._renderer) } } class FF { constructor(t, e, i, s) { this.id = t, this.element = e, this._renderer = s, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return _D(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { return this._renderer.engine.players[+this.id]?.getPosition() ?? 0 } } function _D(n, t, e, i, s) { return n.setProperty(t, `@@${e}:${i}`, s) } const bD = "@.disabled"; let NF = (() => { class n { constructor(e, i, s) { this.delegate = e, this.engine = i, this._zone = s, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), i.onRemovalComplete = (r, o) => { const a = o?.parentNode(r); a && o.removeChild(a, r) } } createRenderer(e, i) { const r = this.delegate.createRenderer(e, i); if (!(e && i && i.data && i.data.animation)) { let u = this._rendererCache.get(r); return u || (u = new wD("", r, this.engine), this._rendererCache.set(r, u)), u } const o = i.id, a = i.id + "-" + this._currentId; this._currentId++, this.engine.register(a, e); const l = u => { Array.isArray(u) ? u.forEach(l) : this.engine.registerTrigger(o, a, e, u.name, u) }; return i.data.animation.forEach(l), new jF(this, a, r, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(e, i, s) { e >= 0 && e < this._microtaskId ? this._zone.run(() => i(s)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(r => { const [o, a] = r; o(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([i, s])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return n.\u0275fac = function (e) { return new (e || n)(k(Fo), k(qc), k(Ve)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class wD { constructor(t, e, i) { this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? s => e.destroyNode(s) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, i, s = !0) { this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, s) } removeChild(t, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate, i) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, i, s) { this.delegate.setAttribute(t, e, i, s) } removeAttribute(t, e, i) { this.delegate.removeAttribute(t, e, i) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, i, s) { this.delegate.setStyle(t, e, i, s) } removeStyle(t, e, i) { this.delegate.removeStyle(t, e, i) } setProperty(t, e, i) { "@" == e.charAt(0) && e == bD ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, i) { return this.delegate.listen(t, e, i) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class jF extends wD { constructor(t, e, i, s) { super(e, i, s), this.factory = t, this.namespaceId = e } setProperty(t, e, i) { "@" == e.charAt(0) ? "." == e.charAt(1) && e == bD ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.slice(1), i) : this.delegate.setProperty(t, e, i) } listen(t, e, i) { if ("@" == e.charAt(0)) { const s = function BF(n) { switch (n) { case "body": return document.body; case "document": return document; case "window": return window; default: return n } }(t); let r = e.slice(1), o = ""; return "@" != r.charAt(0) && ([r, o] = function VF(n) { const t = n.indexOf("."); return [n.substring(0, t), n.slice(t + 1)] }(r)), this.engine.listen(this.namespaceId, s, r, o, a => { this.factory.scheduleListenerCallback(a._data || -1, i, a) }) } return this.delegate.listen(t, e, i) } } const DD = [{ provide: Ow, useClass: OF }, { provide: jp, useFactory: function $F() { return new aF } }, { provide: qc, useClass: (() => { class n extends qc { constructor(e, i, s, r) { super(e.body, i, s) } ngOnDestroy() { this.flush() } } return n.\u0275fac = function (e) { return new (e || n)(k(vt), k(Mp), k(jp), k(Wo)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })() }, { provide: Fo, useFactory: function zF(n, t, e) { return new NF(n, t, e) }, deps: [Ac, qc, Ve] }], xD = [{ provide: Mp, useFactory: () => new RF }, { provide: gb, useValue: "BrowserAnimations" }, ...DD], UF = [{ provide: Mp, useClass: Qw }, { provide: gb, useValue: "NoopAnimations" }, ...DD]; let WF = (() => { class n { static withConfig(e) { return { ngModule: n, providers: e.disableAnimations ? UF : xD } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({ providers: xD, imports: [kw] }), n })(); function z(...n) { return ft(n, Xr(n)) } function As(n) { return !!n && (n instanceof $e || Ce(n.lift) && Ce(n.subscribe)) } const { isArray: qF } = Array, { getPrototypeOf: GF, prototype: KF, keys: QF } = Object; function CD(n) { if (1 === n.length) { const t = n[0]; if (qF(t)) return { args: t, keys: null }; if (function ZF(n) { return n && "object" == typeof n && GF(n) === KF }(t)) { const e = QF(t); return { args: e.map(i => t[i]), keys: e } } } return { args: n, keys: null } } const { isArray: YF } = Array; function SD(n) { return he(t => function XF(n, t) { return YF(t) ? n(...t) : n(t) }(n, t)) } function ED(n, t) { return n.reduce((e, i, s) => (e[i] = t[s], e), {}) } function jr(...n) { return function eN() { return Ks(1) }()(ft(n, Xr(n))) } function Kc(n) { return new $e(t => { Sn(n()).subscribe(t) }) } function ln(n) { return n <= 0 ? () => oi : Ye((t, e) => { let i = 0; t.subscribe(rt(e, s => { ++i <= n && (e.next(s), n <= i && e.complete()) })) }) } const Wp = { now: () => (Wp.delegate || Date).now(), delegate: void 0 }; class tN extends Ne { constructor(t = 1 / 0, e = 1 / 0, i = Wp) { super(), this._bufferSize = t, this._windowTime = e, this._timestampProvider = i, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = e === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, e) } next(t) { const { isStopped: e, _buffer: i, _infiniteTimeWindow: s, _timestampProvider: r, _windowTime: o } = this; e || (i.push(t), !s && i.push(r.now() + o)), this._trimBuffer(), super.next(t) } _subscribe(t) { this._throwIfClosed(), this._trimBuffer(); const e = this._innerSubscribe(t), { _infiniteTimeWindow: i, _buffer: s } = this, r = s.slice(); for (let o = 0; o < r.length && !t.closed; o += i ? 1 : 2)t.next(r[o]); return this._checkFinalizedStatuses(t), e } _trimBuffer() { const { _bufferSize: t, _timestampProvider: e, _buffer: i, _infiniteTimeWindow: s } = this, r = (s ? 1 : 2) * t; if (t < 1 / 0 && r < i.length && i.splice(0, i.length - r), !s) { const o = e.now(); let a = 0; for (let l = 1; l < i.length && i[l] <= o; l += 2)a = l; a && i.splice(0, a + 1) } } } function MD(n, t, e) { let i, s = !1; return n && "object" == typeof n ? ({ bufferSize: i = 1 / 0, windowTime: t = 1 / 0, refCount: s = !1, scheduler: e } = n) : i = n ?? 1 / 0, Zm({ connector: () => new tN(i, t, e), resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: s }) } function ks(n, t) { return Ce(t) ? ht(n, t, 1) : ht(n, 1) } function Wt(n, t) { return Ye((e, i) => { let s = null, r = 0, o = !1; const a = () => o && !s && i.complete(); e.subscribe(rt(i, l => { s?.unsubscribe(); let c = 0; const u = r++; Sn(n(l, u)).subscribe(s = rt(i, d => i.next(t ? t(l, d, u, c++) : d), () => { s = null, a() })) }, () => { o = !0, a() })) }) } class sa { } let TD = (() => { class n extends sa { getTranslation(e) { return z({}) } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = _l(n)))(i || n) } }(), n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class qp { } let AD = (() => { class n { handle(e) { return e.key } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); function Qc(n, t) { if (n === t) return !0; if (null === n || null === t) return !1; if (n != n && t != t) return !0; let s, r, o, e = typeof n; if (e == typeof t && "object" == e) { if (!Array.isArray(n)) { if (Array.isArray(t)) return !1; for (r in o = Object.create(null), n) { if (!Qc(n[r], t[r])) return !1; o[r] = !0 } for (r in t) if (!(r in o) && typeof t[r] < "u") return !1; return !0 } if (!Array.isArray(t)) return !1; if ((s = n.length) == t.length) { for (r = 0; r < s; r++)if (!Qc(n[r], t[r])) return !1; return !0 } } return !1 } function Zi(n) { return typeof n < "u" && null !== n } function Gp(n) { return n && "object" == typeof n && !Array.isArray(n) } function kD(n, t) { let e = Object.assign({}, n); return Gp(n) && Gp(t) && Object.keys(t).forEach(i => { Gp(t[i]) ? i in n ? e[i] = kD(n[i], t[i]) : Object.assign(e, { [i]: t[i] }) : Object.assign(e, { [i]: t[i] }) }), e } class Zc { } let ID = (() => { class n extends Zc { constructor() { super(...arguments), this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g } interpolate(e, i) { let s; return s = "string" == typeof e ? this.interpolateString(e, i) : "function" == typeof e ? this.interpolateFunction(e, i) : e, s } getValue(e, i) { let s = "string" == typeof i ? i.split(".") : [i]; i = ""; do { i += s.shift(), !Zi(e) || !Zi(e[i]) || "object" != typeof e[i] && s.length ? s.length ? i += "." : e = void 0 : (e = e[i], i = "") } while (s.length); return e } interpolateFunction(e, i) { return e(i) } interpolateString(e, i) { return i ? e.replace(this.templateMatcher, (s, r) => { let o = this.getValue(i, r); return Zi(o) ? o : s }) : e } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = _l(n)))(i || n) } }(), n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class Yc { } let PD = (() => { class n extends Yc { compile(e, i) { return e } compileTranslations(e, i) { return e } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = _l(n)))(i || n) } }(), n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class RD { constructor() { this.currentLang = this.defaultLang, this.translations = {}, this.langs = [], this.onTranslationChange = new Re, this.onLangChange = new Re, this.onDefaultLangChange = new Re } } const Kp = new W("USE_STORE"), Qp = new W("USE_DEFAULT_LANG"), Zp = new W("DEFAULT_LANGUAGE"), Yp = new W("USE_EXTEND"); let ra = (() => { class n { constructor(e, i, s, r, o, a = !0, l = !1, c = !1, u) { this.store = e, this.currentLoader = i, this.compiler = s, this.parser = r, this.missingTranslationHandler = o, this.useDefaultLang = a, this.isolate = l, this.extend = c, this.pending = !1, this._onTranslationChange = new Re, this._onLangChange = new Re, this._onDefaultLangChange = new Re, this._langs = [], this._translations = {}, this._translationRequests = {}, u && this.setDefaultLang(u) } get onTranslationChange() { return this.isolate ? this._onTranslationChange : this.store.onTranslationChange } get onLangChange() { return this.isolate ? this._onLangChange : this.store.onLangChange } get onDefaultLangChange() { return this.isolate ? this._onDefaultLangChange : this.store.onDefaultLangChange } get defaultLang() { return this.isolate ? this._defaultLang : this.store.defaultLang } set defaultLang(e) { this.isolate ? this._defaultLang = e : this.store.defaultLang = e } get currentLang() { return this.isolate ? this._currentLang : this.store.currentLang } set currentLang(e) { this.isolate ? this._currentLang = e : this.store.currentLang = e } get langs() { return this.isolate ? this._langs : this.store.langs } set langs(e) { this.isolate ? this._langs = e : this.store.langs = e } get translations() { return this.isolate ? this._translations : this.store.translations } set translations(e) { this.isolate ? this._translations = e : this.store.translations = e } setDefaultLang(e) { if (e === this.defaultLang) return; let i = this.retrieveTranslations(e); typeof i < "u" ? (null == this.defaultLang && (this.defaultLang = e), i.pipe(ln(1)).subscribe(s => { this.changeDefaultLang(e) })) : this.changeDefaultLang(e) } getDefaultLang() { return this.defaultLang } use(e) { if (e === this.currentLang) return z(this.translations[e]); let i = this.retrieveTranslations(e); return typeof i < "u" ? (this.currentLang || (this.currentLang = e), i.pipe(ln(1)).subscribe(s => { this.changeLang(e) }), i) : (this.changeLang(e), z(this.translations[e])) } retrieveTranslations(e) { let i; return (typeof this.translations[e] > "u" || this.extend) && (this._translationRequests[e] = this._translationRequests[e] || this.getTranslation(e), i = this._translationRequests[e]), i } getTranslation(e) { this.pending = !0; const i = this.currentLoader.getTranslation(e).pipe(MD(1), ln(1)); return this.loadingTranslations = i.pipe(he(s => this.compiler.compileTranslations(s, e)), MD(1), ln(1)), this.loadingTranslations.subscribe({ next: s => { this.translations[e] = this.extend && this.translations[e] ? { ...s, ...this.translations[e] } : s, this.updateLangs(), this.pending = !1 }, error: s => { this.pending = !1 } }), i } setTranslation(e, i, s = !1) { i = this.compiler.compileTranslations(i, e), this.translations[e] = (s || this.extend) && this.translations[e] ? kD(this.translations[e], i) : i, this.updateLangs(), this.onTranslationChange.emit({ lang: e, translations: this.translations[e] }) } getLangs() { return this.langs } addLangs(e) { e.forEach(i => { -1 === this.langs.indexOf(i) && this.langs.push(i) }) } updateLangs() { this.addLangs(Object.keys(this.translations)) } getParsedResult(e, i, s) { let r; if (i instanceof Array) { let o = {}, a = !1; for (let l of i) o[l] = this.getParsedResult(e, l, s), As(o[l]) && (a = !0); return a ? function JF(...n) { const t = qm(n), { args: e, keys: i } = CD(n), s = new $e(r => { const { length: o } = e; if (!o) return void r.complete(); const a = new Array(o); let l = o, c = o; for (let u = 0; u < o; u++) { let d = !1; Sn(e[u]).subscribe(rt(r, h => { d || (d = !0, c--), a[u] = h }, () => l--, void 0, () => { (!l || !d) && (c || r.next(i ? ED(i, a) : a), r.complete()) })) } }); return t ? s.pipe(SD(t)) : s }(i.map(c => As(o[c]) ? o[c] : z(o[c]))).pipe(he(c => { let u = {}; return c.forEach((d, h) => { u[i[h]] = d }), u })) : o } if (e && (r = this.parser.interpolate(this.parser.getValue(e, i), s)), typeof r > "u" && null != this.defaultLang && this.defaultLang !== this.currentLang && this.useDefaultLang && (r = this.parser.interpolate(this.parser.getValue(this.translations[this.defaultLang], i), s)), typeof r > "u") { let o = { key: i, translateService: this }; typeof s < "u" && (o.interpolateParams = s), r = this.missingTranslationHandler.handle(o) } return typeof r < "u" ? r : i } get(e, i) { if (!Zi(e) || !e.length) throw new Error('Parameter "key" required'); if (this.pending) return this.loadingTranslations.pipe(ks(s => As(s = this.getParsedResult(s, e, i)) ? s : z(s))); { let s = this.getParsedResult(this.translations[this.currentLang], e, i); return As(s) ? s : z(s) } } getStreamOnTranslationChange(e, i) { if (!Zi(e) || !e.length) throw new Error('Parameter "key" required'); return jr(Kc(() => this.get(e, i)), this.onTranslationChange.pipe(Wt(s => { const r = this.getParsedResult(s.translations, e, i); return "function" == typeof r.subscribe ? r : z(r) }))) } stream(e, i) { if (!Zi(e) || !e.length) throw new Error('Parameter "key" required'); return jr(Kc(() => this.get(e, i)), this.onLangChange.pipe(Wt(s => { const r = this.getParsedResult(s.translations, e, i); return As(r) ? r : z(r) }))) } instant(e, i) { if (!Zi(e) || !e.length) throw new Error('Parameter "key" required'); let s = this.getParsedResult(this.translations[this.currentLang], e, i); if (As(s)) { if (e instanceof Array) { let r = {}; return e.forEach((o, a) => { r[e[a]] = e[a] }), r } return e } return s } set(e, i, s = this.currentLang) { this.translations[s][e] = this.compiler.compile(i, s), this.updateLangs(), this.onTranslationChange.emit({ lang: s, translations: this.translations[s] }) } changeLang(e) { this.currentLang = e, this.onLangChange.emit({ lang: e, translations: this.translations[e] }), null == this.defaultLang && this.changeDefaultLang(e) } changeDefaultLang(e) { this.defaultLang = e, this.onDefaultLangChange.emit({ lang: e, translations: this.translations[e] }) } reloadLang(e) { return this.resetLang(e), this.getTranslation(e) } resetLang(e) { this._translationRequests[e] = void 0, this.translations[e] = void 0 } getBrowserLang() { if (typeof window > "u" || typeof window.navigator > "u") return; let e = window.navigator.languages ? window.navigator.languages[0] : null; return e = e || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, typeof e > "u" ? void 0 : (-1 !== e.indexOf("-") && (e = e.split("-")[0]), -1 !== e.indexOf("_") && (e = e.split("_")[0]), e) } getBrowserCultureLang() { if (typeof window > "u" || typeof window.navigator > "u") return; let e = window.navigator.languages ? window.navigator.languages[0] : null; return e = e || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, e } } return n.\u0275fac = function (e) { return new (e || n)(k(RD), k(sa), k(Yc), k(Zc), k(qp), k(Qp), k(Kp), k(Yp), k(Zp)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), Xc = (() => { class n { constructor(e, i) { this.translate = e, this._ref = i, this.value = "", this.lastKey = null, this.lastParams = [] } updateValue(e, i, s) { let r = o => { this.value = void 0 !== o ? o : e, this.lastKey = e, this._ref.markForCheck() }; if (s) { let o = this.translate.getParsedResult(s, e, i); As(o.subscribe) ? o.subscribe(r) : r(o) } this.translate.get(e, i).subscribe(r) } transform(e, ...i) { if (!e || !e.length) return e; if (Qc(e, this.lastKey) && Qc(i, this.lastParams)) return this.value; let s; if (Zi(i[0]) && i.length) if ("string" == typeof i[0] && i[0].length) { let r = i[0].replace(/(\')?([a-zA-Z0-9_]+)(\')?(\s)?:/g, '"$2":').replace(/:(\s)?(\')(.*?)(\')/g, ':"$3"'); try { s = JSON.parse(r) } catch { throw new SyntaxError(`Wrong parameter in TranslatePipe. Expected a valid Object, received: ${i[0]}`) } } else "object" == typeof i[0] && !Array.isArray(i[0]) && (s = i[0]); return this.lastKey = e, this.lastParams = i, this.updateValue(e, s), this._dispose(), this.onTranslationChange || (this.onTranslationChange = this.translate.onTranslationChange.subscribe(r => { this.lastKey && r.lang === this.translate.currentLang && (this.lastKey = null, this.updateValue(e, s, r.translations)) })), this.onLangChange || (this.onLangChange = this.translate.onLangChange.subscribe(r => { this.lastKey && (this.lastKey = null, this.updateValue(e, s, r.translations)) })), this.onDefaultLangChange || (this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(() => { this.lastKey && (this.lastKey = null, this.updateValue(e, s)) })), this.value } _dispose() { typeof this.onTranslationChange < "u" && (this.onTranslationChange.unsubscribe(), this.onTranslationChange = void 0), typeof this.onLangChange < "u" && (this.onLangChange.unsubscribe(), this.onLangChange = void 0), typeof this.onDefaultLangChange < "u" && (this.onDefaultLangChange.unsubscribe(), this.onDefaultLangChange = void 0) } ngOnDestroy() { this._dispose() } } return n.\u0275fac = function (e) { return new (e || n)(L(ra, 16), L(qo, 16)) }, n.\u0275pipe = It({ name: "translate", type: n, pure: !1 }), n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), nN = (() => { class n { static forRoot(e = {}) { return { ngModule: n, providers: [e.loader || { provide: sa, useClass: TD }, e.compiler || { provide: Yc, useClass: PD }, e.parser || { provide: Zc, useClass: ID }, e.missingTranslationHandler || { provide: qp, useClass: AD }, RD, { provide: Kp, useValue: e.isolate }, { provide: Qp, useValue: e.useDefaultLang }, { provide: Yp, useValue: e.extend }, { provide: Zp, useValue: e.defaultLanguage }, ra] } } static forChild(e = {}) { return { ngModule: n, providers: [e.loader || { provide: sa, useClass: TD }, e.compiler || { provide: Yc, useClass: PD }, e.parser || { provide: Zc, useClass: ID }, e.missingTranslationHandler || { provide: qp, useClass: AD }, { provide: Kp, useValue: e.isolate }, { provide: Qp, useValue: e.useDefaultLang }, { provide: Yp, useValue: e.extend }, { provide: Zp, useValue: e.defaultLanguage }, ra] } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({}), n })(); class Bn extends Ne { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return !e.closed && t.next(this._value), e } getValue() { const { hasError: t, thrownError: e, _value: i } = this; if (t) throw e; return this._throwIfClosed(), i } next(t) { super.next(this._value = t) } } function OD(...n) { const t = Xr(n), e = qm(n), { args: i, keys: s } = CD(n); if (0 === i.length) return ft([], t); const r = new $e(function iN(n, t, e = ls) { return i => { LD(t, () => { const { length: s } = n, r = new Array(s); let o = s, a = s; for (let l = 0; l < s; l++)LD(t, () => { const c = ft(n[l], t); let u = !1; c.subscribe(rt(i, d => { r[l] = d, u || (u = !0, a--), a || i.next(e(r.slice())) }, () => { --o || i.complete() })) }, i) }, i) } }(i, t, s ? o => ED(s, o) : ls)); return e ? r.pipe(SD(e)) : r } function LD(n, t, e) { n ? ri(e, n, t) : t() } function oa(n, t) { const e = Ce(n) ? n : () => n, i = s => s.error(e()); return new $e(t ? s => t.schedule(i, 0, s) : i) } const aa = Zr(n => function () { n(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function Xp() { return Ye((n, t) => { let e = null; n._refCount++; const i = rt(t, void 0, void 0, void 0, () => { if (!n || n._refCount <= 0 || 0 < --n._refCount) return void (e = null); const s = n._connection, r = e; e = null, s && (!r || s === r) && s.unsubscribe(), t.unsubscribe() }); n.subscribe(i), i.closed || (e = n.connect()) }) } class FD extends $e { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, Im(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new Qt; const e = this.getSubject(); t.add(this.source.subscribe(rt(e, void 0, () => { this._teardown(), e.complete() }, i => { this._teardown(), e.error(i) }, () => this._teardown()))), t.closed && (this._connection = null, t = Qt.EMPTY) } return t } refCount() { return Xp()(this) } } function ND(n, t, e, i, s) { return (r, o) => { let a = e, l = t, c = 0; r.subscribe(rt(o, u => { const d = c++; l = a ? n(l, u, d) : (a = !0, u), i && o.next(l) }, s && (() => { a && o.next(l), o.complete() }))) } } function jD(n, t) { return Ye(ND(n, t, arguments.length >= 2, !0)) } function qt(n, t) { return Ye((e, i) => { let s = 0; e.subscribe(rt(i, r => n.call(t, r, s++) && i.next(r))) }) } function Is(n) { return Ye((t, e) => { let r, i = null, s = !1; i = t.subscribe(rt(e, void 0, void 0, o => { r = Sn(n(o, Is(n)(t))), i ? (i.unsubscribe(), i = null, r.subscribe(e)) : s = !0 })), s && (i.unsubscribe(), i = null, r.subscribe(e)) }) } function Jp(n) { return n <= 0 ? () => oi : Ye((t, e) => { let i = []; t.subscribe(rt(e, s => { i.push(s), n < i.length && i.shift() }, () => { for (const s of i) e.next(s); e.complete() }, void 0, () => { i = null })) }) } function BD(n = rN) { return Ye((t, e) => { let i = !1; t.subscribe(rt(e, s => { i = !0, e.next(s) }, () => i ? e.complete() : e.error(n()))) }) } function rN() { return new aa } function eg(n) { return Ye((t, e) => { let i = !1; t.subscribe(rt(e, s => { i = !0, e.next(s) }, () => { i || e.next(n), e.complete() })) }) } function ti(n, t) { const e = arguments.length >= 2; return i => i.pipe(n ? qt((s, r) => n(s, r, i)) : ls, ln(1), e ? eg(t) : BD(() => new aa)) } function se(n, t, e) { const i = Ce(n) || t || e ? { next: n, error: t, complete: e } : n; return i ? Ye((s, r) => { var o; null === (o = i.subscribe) || void 0 === o || o.call(i); let a = !0; s.subscribe(rt(r, l => { var c; null === (c = i.next) || void 0 === c || c.call(i, l), r.next(l) }, () => { var l; a = !1, null === (l = i.complete) || void 0 === l || l.call(i), r.complete() }, l => { var c; a = !1, null === (c = i.error) || void 0 === c || c.call(i, l), r.error(l) }, () => { var l, c; a && (null === (l = i.unsubscribe) || void 0 === l || l.call(i)), null === (c = i.finalize) || void 0 === c || c.call(i) })) }) : ls } function VD(n) { return he(() => n) } function tg(n) { return Ye((t, e) => { try { t.subscribe(e) } finally { e.add(n) } }) } class wi { constructor(t, e) { this.id = t, this.url = e } } class ng extends wi { constructor(t, e, i = "imperative", s = null) { super(t, e), this.type = 0, this.navigationTrigger = i, this.restoredState = s } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Ps extends wi { constructor(t, e, i) { super(t, e), this.urlAfterRedirects = i, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Jc extends wi { constructor(t, e, i) { super(t, e), this.reason = i, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class HD extends wi { constructor(t, e, i) { super(t, e), this.error = i, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class aN extends wi { constructor(t, e, i, s) { super(t, e), this.urlAfterRedirects = i, this.state = s, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class lN extends wi { constructor(t, e, i, s) { super(t, e), this.urlAfterRedirects = i, this.state = s, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class cN extends wi { constructor(t, e, i, s, r) { super(t, e), this.urlAfterRedirects = i, this.state = s, this.shouldActivate = r, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class uN extends wi { constructor(t, e, i, s) { super(t, e), this.urlAfterRedirects = i, this.state = s, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class dN extends wi { constructor(t, e, i, s) { super(t, e), this.urlAfterRedirects = i, this.state = s, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class hN { constructor(t) { this.route = t, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class fN { constructor(t) { this.route = t, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class pN { constructor(t) { this.snapshot = t, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class gN { constructor(t) { this.snapshot = t, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class mN { constructor(t) { this.snapshot = t, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class yN { constructor(t) { this.snapshot = t, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class $D { constructor(t, e, i) { this.routerEvent = t, this.position = e, this.anchor = i, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const le = "primary"; class _N { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Br(n) { return new _N(n) } const ig = "Redirecting to ", zD = "ngNavigationCancelingError"; function sg(n) { const t = Error("NavigationCancelingError: " + (n || "")); return t[zD] = !0, t } function wN(n, t, e) { const i = e.path.split("/"); if (i.length > n.length || "full" === e.pathMatch && (t.hasChildren() || i.length < n.length)) return null; const s = {}; for (let r = 0; r < i.length; r++) { const o = i[r], a = n[r]; if (o.startsWith(":")) s[o.substring(1)] = a; else if (o !== a.path) return null } return { consumed: n.slice(0, i.length), posParams: s } } function ni(n, t) { const e = n ? Object.keys(n) : void 0, i = t ? Object.keys(t) : void 0; if (!e || !i || e.length != i.length) return !1; let s; for (let r = 0; r < e.length; r++)if (s = e[r], !UD(n[s], t[s])) return !1; return !0 } function UD(n, t) { if (Array.isArray(n) && Array.isArray(t)) { if (n.length !== t.length) return !1; const e = [...n].sort(), i = [...t].sort(); return e.every((s, r) => i[r] === s) } return n === t } function WD(n) { return Array.prototype.concat.apply([], n) } function qD(n) { return n.length > 0 ? n[n.length - 1] : null } function _t(n, t) { for (const e in n) n.hasOwnProperty(e) && t(n[e], e) } function Yi(n) { return J0(n) ? n : Wl(n) ? ft(Promise.resolve(n)) : z(n) } const CN = { exact: function QD(n, t, e) { if (!Os(n.segments, t.segments) || !eu(n.segments, t.segments, e) || n.numberOfChildren !== t.numberOfChildren) return !1; for (const i in t.children) if (!n.children[i] || !QD(n.children[i], t.children[i], e)) return !1; return !0 }, subset: ZD }, GD = { exact: function SN(n, t) { return ni(n, t) }, subset: function EN(n, t) { return Object.keys(t).length <= Object.keys(n).length && Object.keys(t).every(e => UD(n[e], t[e])) }, ignored: () => !0 }; function KD(n, t, e) { return CN[e.paths](n.root, t.root, e.matrixParams) && GD[e.queryParams](n.queryParams, t.queryParams) && !("exact" === e.fragment && n.fragment !== t.fragment) } function ZD(n, t, e) { return YD(n, t, t.segments, e) } function YD(n, t, e, i) { if (n.segments.length > e.length) { const s = n.segments.slice(0, e.length); return !(!Os(s, e) || t.hasChildren() || !eu(s, e, i)) } if (n.segments.length === e.length) { if (!Os(n.segments, e) || !eu(n.segments, e, i)) return !1; for (const s in t.children) if (!n.children[s] || !ZD(n.children[s], t.children[s], i)) return !1; return !0 } { const s = e.slice(0, n.segments.length), r = e.slice(n.segments.length); return !!(Os(n.segments, s) && eu(n.segments, s, i) && n.children[le]) && YD(n.children[le], t, r, i) } } function eu(n, t, e) { return t.every((i, s) => GD[e](n[s].parameters, i.parameters)) } class Rs { constructor(t, e, i) { this.root = t, this.queryParams = e, this.fragment = i } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Br(this.queryParams)), this._queryParamMap } toString() { return AN.serialize(this) } } class de { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, _t(e, (i, s) => i.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return tu(this) } } class la { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Br(this.parameters)), this._parameterMap } toString() { return nx(this) } } function Os(n, t) { return n.length === t.length && n.every((e, i) => e.path === t[i].path) } class XD { } class JD { parse(t) { const e = new jN(t); return new Rs(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { const e = `/${ca(t.root, !0)}`, i = function PN(n) { const t = Object.keys(n).map(e => { const i = n[e]; return Array.isArray(i) ? i.map(s => `${nu(e)}=${nu(s)}`).join("&") : `${nu(e)}=${nu(i)}` }).filter(e => !!e); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${e}${i}${"string" == typeof t.fragment ? `#${function kN(n) { return encodeURI(n) }(t.fragment)}` : ""}` } } const AN = new JD; function tu(n) { return n.segments.map(t => nx(t)).join("/") } function ca(n, t) { if (!n.hasChildren()) return tu(n); if (t) { const e = n.children[le] ? ca(n.children[le], !1) : "", i = []; return _t(n.children, (s, r) => { r !== le && i.push(`${r}:${ca(s, !1)}`) }), i.length > 0 ? `${e}(${i.join("//")})` : e } { const e = function TN(n, t) { let e = []; return _t(n.children, (i, s) => { s === le && (e = e.concat(t(i, s))) }), _t(n.children, (i, s) => { s !== le && (e = e.concat(t(i, s))) }), e }(n, (i, s) => s === le ? [ca(n.children[le], !1)] : [`${s}:${ca(i, !1)}`]); return 1 === Object.keys(n.children).length && null != n.children[le] ? `${tu(n)}/${e[0]}` : `${tu(n)}/(${e.join("//")})` } } function ex(n) { return encodeURIComponent(n).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function nu(n) { return ex(n).replace(/%3B/gi, ";") } function og(n) { return ex(n).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function iu(n) { return decodeURIComponent(n) } function tx(n) { return iu(n.replace(/\+/g, "%20")) } function nx(n) { return `${og(n.path)}${function IN(n) { return Object.keys(n).map(t => `;${og(t)}=${og(n[t])}`).join("") }(n.parameters)}` } const RN = /^[^\/()?;=#]+/; function su(n) { const t = n.match(RN); return t ? t[0] : "" } const ON = /^[^=?&#]+/, FN = /^[^&#]+/; class jN { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new de([], {}) : new de([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let i = {}; return this.peekStartsWith("(") && (i = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (i[le] = new de(t, e)), i } parseSegment() { const t = su(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new T(4009, !1); return this.capture(t), new la(iu(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = su(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const s = su(this.remaining); s && (i = s, this.capture(i)) } t[iu(e)] = iu(i) } parseQueryParam(t) { const e = function LN(n) { const t = n.match(ON); return t ? t[0] : "" }(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const o = function NN(n) { const t = n.match(FN); return t ? t[0] : "" }(this.remaining); o && (i = o, this.capture(i)) } const s = tx(e), r = tx(i); if (t.hasOwnProperty(s)) { let o = t[s]; Array.isArray(o) || (o = [o], t[s] = o), o.push(r) } else t[s] = r } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const i = su(this.remaining), s = this.remaining[i.length]; if ("/" !== s && ")" !== s && ";" !== s) throw new T(4010, !1); let r; i.indexOf(":") > -1 ? (r = i.slice(0, i.indexOf(":")), this.capture(r), this.capture(":")) : t && (r = le); const o = this.parseChildren(); e[r] = 1 === Object.keys(o).length ? o[le] : new de([], o), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new T(4011, !1) } } class ix { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = ag(t, this._root); return e ? e.children.map(i => i.value) : [] } firstChild(t) { const e = ag(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = lg(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(s => s.value).filter(s => s !== t) } pathFromRoot(t) { return lg(t, this._root).map(e => e.value) } } function ag(n, t) { if (n === t.value) return t; for (const e of t.children) { const i = ag(n, e); if (i) return i } return null } function lg(n, t) { if (n === t.value) return [t]; for (const e of t.children) { const i = lg(n, e); if (i.length) return i.unshift(t), i } return [] } class Di { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Vr(n) { const t = {}; return n && n.children.forEach(e => t[e.value.outlet] = e), t } class sx extends ix { constructor(t, e) { super(t), this.snapshot = e, cg(this, t) } toString() { return this.snapshot.toString() } } function rx(n, t) { const e = function BN(n, t) { const o = new ru([], {}, {}, "", {}, le, t, null, n.root, -1, {}); return new ax("", new Di(o, [])) }(n, t), i = new Bn([new la("", {})]), s = new Bn({}), r = new Bn({}), o = new Bn({}), a = new Bn(""), l = new Ls(i, s, o, a, r, le, t, e.root); return l.snapshot = e.root, new sx(new Di(l, []), e) } class Ls { constructor(t, e, i, s, r, o, a, l) { this.url = t, this.params = e, this.queryParams = i, this.fragment = s, this.data = r, this.outlet = o, this.component = a, this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(he(t => Br(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(he(t => Br(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function ox(n, t = "emptyOnly") { const e = n.pathFromRoot; let i = 0; if ("always" !== t) for (i = e.length - 1; i >= 1;) { const s = e[i], r = e[i - 1]; if (s.routeConfig && "" === s.routeConfig.path) i--; else { if (r.component) break; i-- } } return function VN(n) { return n.reduce((t, e) => ({ params: { ...t.params, ...e.params }, data: { ...t.data, ...e.data }, resolve: { ...e.data, ...t.resolve, ...e.routeConfig?.data, ...e._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(e.slice(i)) } class ru { constructor(t, e, i, s, r, o, a, l, c, u, d, h) { this.url = t, this.params = e, this.queryParams = i, this.fragment = s, this.data = r, this.outlet = o, this.component = a, this.routeConfig = l, this._urlSegment = c, this._lastPathIndex = u, this._correctedLastPathIndex = h ?? u, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Br(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Br(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(i => i.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class ax extends ix { constructor(t, e) { super(e), this.url = t, cg(this, e) } toString() { return lx(this._root) } } function cg(n, t) { t.value._routerState = n, t.children.forEach(e => cg(n, e)) } function lx(n) { const t = n.children.length > 0 ? ` { ${n.children.map(lx).join(", ")} } ` : ""; return `${n.value}${t}` } function ug(n) { if (n.snapshot) { const t = n.snapshot, e = n._futureSnapshot; n.snapshot = e, ni(t.queryParams, e.queryParams) || n.queryParams.next(e.queryParams), t.fragment !== e.fragment && n.fragment.next(e.fragment), ni(t.params, e.params) || n.params.next(e.params), function DN(n, t) { if (n.length !== t.length) return !1; for (let e = 0; e < n.length; ++e)if (!ni(n[e], t[e])) return !1; return !0 }(t.url, e.url) || n.url.next(e.url), ni(t.data, e.data) || n.data.next(e.data) } else n.snapshot = n._futureSnapshot, n.data.next(n._futureSnapshot.data) } function dg(n, t) { const e = ni(n.params, t.params) && function MN(n, t) { return Os(n, t) && n.every((e, i) => ni(e.parameters, t[i].parameters)) }(n.url, t.url); return e && !(!n.parent != !t.parent) && (!n.parent || dg(n.parent, t.parent)) } function ua(n, t, e) { if (e && n.shouldReuseRoute(t.value, e.value.snapshot)) { const i = e.value; i._futureSnapshot = t.value; const s = function $N(n, t, e) { return t.children.map(i => { for (const s of e.children) if (n.shouldReuseRoute(i.value, s.value.snapshot)) return ua(n, i, s); return ua(n, i) }) }(n, t, e); return new Di(i, s) } { if (n.shouldAttach(t.value)) { const r = n.retrieve(t.value); if (null !== r) { const o = r.route; return o.value._futureSnapshot = t.value, o.children = t.children.map(a => ua(n, a)), o } } const i = function zN(n) { return new Ls(new Bn(n.url), new Bn(n.params), new Bn(n.queryParams), new Bn(n.fragment), new Bn(n.data), n.outlet, n.component, n) }(t.value), s = t.children.map(r => ua(n, r)); return new Di(i, s) } } function ou(n) { return "object" == typeof n && null != n && !n.outlets && !n.segmentPath } function da(n) { return "object" == typeof n && null != n && n.outlets } function fg(n, t, e, i, s) { let r = {}; if (i && _t(i, (a, l) => { r[l] = Array.isArray(a) ? a.map(c => `${c}`) : `${a}` }), n === t) return new Rs(e, r, s); const o = cx(n, t, e); return new Rs(o, r, s) } function cx(n, t, e) { const i = {}; return _t(n.children, (s, r) => { i[r] = s === t ? e : cx(s, t, e) }), new de(n.segments, i) } class ux { constructor(t, e, i) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i, t && i.length > 0 && ou(i[0])) throw new T(4003, false); const s = i.find(da); if (s && s !== qD(i)) throw new T(4004, false) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class pg { constructor(t, e, i) { this.segmentGroup = t, this.processChildren = e, this.index = i } } function dx(n, t, e) { if (n || (n = new de([], {})), 0 === n.segments.length && n.hasChildren()) return au(n, t, e); const i = function QN(n, t, e) { let i = 0, s = t; const r = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < n.segments.length;) { if (i >= e.length) return r; const o = n.segments[s], a = e[i]; if (da(a)) break; const l = `${a}`, c = i < e.length - 1 ? e[i + 1] : null; if (s > 0 && void 0 === l) break; if (l && c && "object" == typeof c && void 0 === c.outlets) { if (!fx(l, c, o)) return r; i += 2 } else { if (!fx(l, {}, o)) return r; i++ } s++ } return { match: !0, pathIndex: s, commandIndex: i } }(n, t, e), s = e.slice(i.commandIndex); if (i.match && i.pathIndex < n.segments.length) { const r = new de(n.segments.slice(0, i.pathIndex), {}); return r.children[le] = new de(n.segments.slice(i.pathIndex), n.children), au(r, 0, s) } return i.match && 0 === s.length ? new de(n.segments, {}) : i.match && !n.hasChildren() ? gg(n, t, e) : i.match ? au(n, 0, s) : gg(n, t, e) } function au(n, t, e) { if (0 === e.length) return new de(n.segments, {}); { const i = function KN(n) { return da(n[0]) ? n[0].outlets : { [le]: n } }(e), s = {}; return _t(i, (r, o) => { "string" == typeof r && (r = [r]), null !== r && (s[o] = dx(n.children[o], t, r)) }), _t(n.children, (r, o) => { void 0 === i[o] && (s[o] = r) }), new de(n.segments, s) } } function gg(n, t, e) { const i = n.segments.slice(0, t); let s = 0; for (; s < e.length;) { const r = e[s]; if (da(r)) { const l = ZN(r.outlets); return new de(i, l) } if (0 === s && ou(e[0])) { i.push(new la(n.segments[t].path, hx(e[0]))), s++; continue } const o = da(r) ? r.outlets[le] : `${r}`, a = s < e.length - 1 ? e[s + 1] : null; o && a && ou(a) ? (i.push(new la(o, hx(a))), s += 2) : (i.push(new la(o, {})), s++) } return new de(i, {}) } function ZN(n) { const t = {}; return _t(n, (e, i) => { "string" == typeof e && (e = [e]), null !== e && (t[i] = gg(new de([], {}), 0, e)) }), t } function hx(n) { const t = {}; return _t(n, (e, i) => t[i] = `${e}`), t } function fx(n, t, e) { return n == e.path && ni(t, e.parameters) } class YN { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new ha, this.attachRef = null } } class ha { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const i = this.getOrCreateContext(t); i.outlet = e, this.contexts.set(t, i) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null, e.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new YN, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } const lu = !1; let mg = (() => { class n { constructor(e, i, s, r, o) { this.parentContexts = e, this.location = i, this.changeDetector = r, this.environmentInjector = o, this.activated = null, this._activatedRoute = null, this.activateEvents = new Re, this.deactivateEvents = new Re, this.attachEvents = new Re, this.detachEvents = new Re, this.name = s || le, e.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.getContext(this.name)?.outlet === this && this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const e = this.parentContexts.getContext(this.name); e && e.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.injector)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new T(4012, lu); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new T(4012, lu); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new T(4012, lu); this.location.detach(); const e = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e } attach(e, i) { this.activated = e, this._activatedRoute = i, this.location.insert(e.hostView), this.attachEvents.emit(e.instance) } deactivate() { if (this.activated) { const e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, i) { if (this.isActivated) throw new T(4013, lu); this._activatedRoute = e; const s = this.location, o = e._futureSnapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, l = new XN(e, a, s.injector); if (i && function JN(n) { return !!n.resolveComponentFactory }(i)) { const c = i.resolveComponentFactory(o); this.activated = s.createComponent(c, s.length, l) } else this.activated = s.createComponent(o, { index: s.length, injector: l, environmentInjector: i ?? this.environmentInjector }); this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return n.\u0275fac = function (e) { return new (e || n)(L(ha), L(Ln), lo("name"), L(qo), L(_s)) }, n.\u0275dir = mt({ type: n, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"] }), n })(); class XN { constructor(t, e, i) { this.route = t, this.childContexts = e, this.parent = i } get(t, e) { return t === Ls ? this.route : t === ha ? this.childContexts : this.parent.get(t, e) } } let px = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = Un({ type: n, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (e, i) { 1 & e && C(0, "router-outlet") }, dependencies: [mg], encapsulation: 2 }), n })(); function gx(n, t) { return n.providers && !n._injector && (n._injector = Jl(n.providers, t, `Route: ${n.path}`)), n._injector ?? t } function vg(n) { const t = n.children && n.children.map(vg), e = t ? { ...n, children: t } : { ...n }; return !e.component && !e.loadComponent && (t || e.loadChildren) && e.outlet && e.outlet !== le && (e.component = px), e } function _n(n) { return n.outlet || le } function mx(n, t) { const e = n.filter(i => _n(i) === t); return e.push(...n.filter(i => _n(i) !== t)), e } function yx(n) { if (!n) return null; if (n.routeConfig?._injector) return n.routeConfig._injector; for (let t = n.parent; t; t = t.parent) { const e = t.routeConfig; if (e?._loadedInjector) return e._loadedInjector; if (e?._injector) return e._injector } return null } class s5 { constructor(t, e, i, s) { this.routeReuseStrategy = t, this.futureState = e, this.currState = i, this.forwardEvent = s } activate(t) { const e = this.futureState._root, i = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, i, t), ug(this.futureState.root), this.activateChildRoutes(e, i, t) } deactivateChildRoutes(t, e, i) { const s = Vr(e); t.children.forEach(r => { const o = r.value.outlet; this.deactivateRoutes(r, s[o], i), delete s[o] }), _t(s, (r, o) => { this.deactivateRouteAndItsChildren(r, i) }) } deactivateRoutes(t, e, i) { const s = t.value, r = e ? e.value : null; if (s === r) if (s.component) { const o = i.getContext(s.outlet); o && this.deactivateChildRoutes(t, e, o.children) } else this.deactivateChildRoutes(t, e, i); else r && this.deactivateRouteAndItsChildren(e, i) } deactivateRouteAndItsChildren(t, e) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const i = e.getContext(t.value.outlet), s = i && t.value.component ? i.children : e, r = Vr(t); for (const o of Object.keys(r)) this.deactivateRouteAndItsChildren(r[o], s); if (i && i.outlet) { const o = i.outlet.detach(), a = i.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: o, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, e) { const i = e.getContext(t.value.outlet), s = i && t.value.component ? i.children : e, r = Vr(t); for (const o of Object.keys(r)) this.deactivateRouteAndItsChildren(r[o], s); i && i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated(), i.attachRef = null, i.resolver = null, i.route = null) } activateChildRoutes(t, e, i) { const s = Vr(e); t.children.forEach(r => { this.activateRoutes(r, s[r.value.outlet], i), this.forwardEvent(new yN(r.value.snapshot)) }), t.children.length && this.forwardEvent(new gN(t.value.snapshot)) } activateRoutes(t, e, i) { const s = t.value, r = e ? e.value : null; if (ug(s), s === r) if (s.component) { const o = i.getOrCreateContext(s.outlet); this.activateChildRoutes(t, e, o.children) } else this.activateChildRoutes(t, e, i); else if (s.component) { const o = i.getOrCreateContext(s.outlet); if (this.routeReuseStrategy.shouldAttach(s.snapshot)) { const a = this.routeReuseStrategy.retrieve(s.snapshot); this.routeReuseStrategy.store(s.snapshot, null), o.children.onOutletReAttached(a.contexts), o.attachRef = a.componentRef, o.route = a.route.value, o.outlet && o.outlet.attach(a.componentRef, a.route.value), ug(a.route.value), this.activateChildRoutes(t, null, o.children) } else { const a = yx(s.snapshot), l = a?.get(Lo) ?? null; o.attachRef = null, o.route = s, o.resolver = l, o.injector = a, o.outlet && o.outlet.activateWith(s, o.injector), this.activateChildRoutes(t, null, o.children) } } else this.activateChildRoutes(t, null, i) } } function cu(n) { return "function" == typeof n } function Fs(n) { return n instanceof Rs } const fa = Symbol("INITIAL_VALUE"); function pa() { return Wt(n => OD(n.map(t => t.pipe(ln(1), function sN(...n) { const t = Xr(n); return Ye((e, i) => { (t ? jr(n, e, t) : jr(n, e)).subscribe(i) }) }(fa)))).pipe(jD((t, e) => { let i = !1; return e.reduce((s, r, o) => s !== fa ? s : (r === fa && (i = !0), i || !1 !== r && o !== e.length - 1 && !Fs(r) ? s : r), t) }, fa), qt(t => t !== fa), he(t => Fs(t) ? t : !0 === t), ln(1))) } const vx = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function uu(n, t, e) { if ("" === t.path) return "full" === t.pathMatch && (n.hasChildren() || e.length > 0) ? { ...vx } : { matched: !0, consumedSegments: [], remainingSegments: e, parameters: {}, positionalParamSegments: {} }; const s = (t.matcher || wN)(e, n, t); if (!s) return { ...vx }; const r = {}; _t(s.posParams, (a, l) => { r[l] = a.path }); const o = s.consumed.length > 0 ? { ...r, ...s.consumed[s.consumed.length - 1].parameters } : r; return { matched: !0, consumedSegments: s.consumed, remainingSegments: e.slice(s.consumed.length), parameters: o, positionalParamSegments: s.posParams ?? {} } } function du(n, t, e, i, s = "corrected") { if (e.length > 0 && function h5(n, t, e) { return e.some(i => hu(n, t, i) && _n(i) !== le) }(n, e, i)) { const o = new de(t, function d5(n, t, e, i) { const s = {}; s[le] = i, i._sourceSegment = n, i._segmentIndexShift = t.length; for (const r of e) if ("" === r.path && _n(r) !== le) { const o = new de([], {}); o._sourceSegment = n, o._segmentIndexShift = t.length, s[_n(r)] = o } return s }(n, t, i, new de(e, n.children))); return o._sourceSegment = n, o._segmentIndexShift = t.length, { segmentGroup: o, slicedSegments: [] } } if (0 === e.length && function f5(n, t, e) { return e.some(i => hu(n, t, i)) }(n, e, i)) { const o = new de(n.segments, function u5(n, t, e, i, s, r) { const o = {}; for (const a of i) if (hu(n, e, a) && !s[_n(a)]) { const l = new de([], {}); l._sourceSegment = n, l._segmentIndexShift = "legacy" === r ? n.segments.length : t.length, o[_n(a)] = l } return { ...s, ...o } }(n, t, e, i, n.children, s)); return o._sourceSegment = n, o._segmentIndexShift = t.length, { segmentGroup: o, slicedSegments: e } } const r = new de(n.segments, n.children); return r._sourceSegment = n, r._segmentIndexShift = t.length, { segmentGroup: r, slicedSegments: e } } function hu(n, t, e) { return (!(n.hasChildren() || t.length > 0) || "full" !== e.pathMatch) && "" === e.path } function _x(n, t, e, i) { return !!(_n(n) === i || i !== le && hu(t, e, n)) && ("**" === n.path || uu(t, n, e).matched) } function bx(n, t, e) { return 0 === t.length && !n.children[e] } const fu = !1; class pu { constructor(t) { this.segmentGroup = t || null } } class wx { constructor(t) { this.urlTree = t } } function ga(n) { return oa(new pu(n)) } function Dx(n) { return oa(new wx(n)) } class y5 { constructor(t, e, i, s, r) { this.injector = t, this.configLoader = e, this.urlSerializer = i, this.urlTree = s, this.config = r, this.allowRedirects = !0 } apply() { const t = du(this.urlTree.root, [], [], this.config).segmentGroup, e = new de(t.segments, t.children); return this.expandSegmentGroup(this.injector, this.config, e, le).pipe(he(r => this.createUrlTree(_g(r), this.urlTree.queryParams, this.urlTree.fragment))).pipe(Is(r => { if (r instanceof wx) return this.allowRedirects = !1, this.match(r.urlTree); throw r instanceof pu ? this.noMatchError(r) : r })) } match(t) { return this.expandSegmentGroup(this.injector, this.config, t.root, le).pipe(he(s => this.createUrlTree(_g(s), t.queryParams, t.fragment))).pipe(Is(s => { throw s instanceof pu ? this.noMatchError(s) : s })) } noMatchError(t) { return new T(4002, fu) } createUrlTree(t, e, i) { const s = t.segments.length > 0 ? new de([], { [le]: t }) : t; return new Rs(s, e, i) } expandSegmentGroup(t, e, i, s) { return 0 === i.segments.length && i.hasChildren() ? this.expandChildren(t, e, i).pipe(he(r => new de([], r))) : this.expandSegment(t, i, e, i.segments, s, !0) } expandChildren(t, e, i) { const s = []; for (const r of Object.keys(i.children)) "primary" === r ? s.unshift(r) : s.push(r); return ft(s).pipe(ks(r => { const o = i.children[r], a = mx(e, r); return this.expandSegmentGroup(t, a, o, r).pipe(he(l => ({ segment: l, outlet: r }))) }), jD((r, o) => (r[o.outlet] = o.segment, r), {}), function oN(n, t) { const e = arguments.length >= 2; return i => i.pipe(n ? qt((s, r) => n(s, r, i)) : ls, Jp(1), e ? eg(t) : BD(() => new aa)) }()) } expandSegment(t, e, i, s, r, o) { return ft(i).pipe(ks(a => this.expandSegmentAgainstRoute(t, e, i, a, s, r, o).pipe(Is(c => { if (c instanceof pu) return z(null); throw c }))), ti(a => !!a), Is((a, l) => { if (a instanceof aa || "EmptyError" === a.name) return bx(e, s, r) ? z(new de([], {})) : ga(e); throw a })) } expandSegmentAgainstRoute(t, e, i, s, r, o, a) { return _x(s, e, r, o) ? void 0 === s.redirectTo ? this.matchSegmentAgainstRoute(t, e, s, r, o) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, i, s, r, o) : ga(e) : ga(e) } expandSegmentAgainstRouteUsingRedirect(t, e, i, s, r, o) { return "**" === s.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, i, s, o) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, s, r, o) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, i, s) { const r = this.applyRedirectCommands([], i.redirectTo, {}); return i.redirectTo.startsWith("/") ? Dx(r) : this.lineralizeSegments(i, r).pipe(ht(o => { const a = new de(o, {}); return this.expandSegment(t, a, e, o, s, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, s, r, o) { const { matched: a, consumedSegments: l, remainingSegments: c, positionalParamSegments: u } = uu(e, s, r); if (!a) return ga(e); const d = this.applyRedirectCommands(l, s.redirectTo, u); return s.redirectTo.startsWith("/") ? Dx(d) : this.lineralizeSegments(s, d).pipe(ht(h => this.expandSegment(t, e, i, h.concat(c), o, !1))) } matchSegmentAgainstRoute(t, e, i, s, r) { if ("**" === i.path) return t = gx(i, t), i.loadChildren ? (i._loadedRoutes ? z({ routes: i._loadedRoutes, injector: i._loadedInjector }) : this.configLoader.loadChildren(t, i)).pipe(he(d => (i._loadedRoutes = d.routes, i._loadedInjector = d.injector, new de(s, {})))) : z(new de(s, {})); const { matched: o, consumedSegments: a, remainingSegments: l } = uu(e, i, s); return o ? (t = gx(i, t), this.getChildConfig(t, i, s).pipe(ht(u => { const d = u.injector ?? t, h = u.routes, { segmentGroup: f, slicedSegments: p } = du(e, a, l, h), g = new de(f.segments, f.children); if (0 === p.length && g.hasChildren()) return this.expandChildren(d, h, g).pipe(he(v => new de(a, v))); if (0 === h.length && 0 === p.length) return z(new de(a, {})); const m = _n(i) === r; return this.expandSegment(d, g, h, p, m ? le : r, !0).pipe(he(b => new de(a.concat(b.segments), b.children))) }))) : ga(e) } getChildConfig(t, e, i) { return e.children ? z({ routes: e.children, injector: t }) : e.loadChildren ? void 0 !== e._loadedRoutes ? z({ routes: e._loadedRoutes, injector: e._loadedInjector }) : this.runCanLoadGuards(t, e, i).pipe(ht(s => s ? this.configLoader.loadChildren(t, e).pipe(se(r => { e._loadedRoutes = r.routes, e._loadedInjector = r.injector })) : function g5(n) { return oa(sg(fu)) }())) : z({ routes: [], injector: t }) } runCanLoadGuards(t, e, i) { const s = e.canLoad; return s && 0 !== s.length ? z(s.map(o => { const a = t.get(o); return Yi(function o5(n) { return n && cu(n.canLoad) }(a) ? a.canLoad(e, i) : a(e, i)) })).pipe(pa(), se(o => { if (!Fs(o)) return; const a = sg(ig + this.urlSerializer.serialize(o)); throw a.url = o, a }), he(o => !0 === o)) : z(!0) } lineralizeSegments(t, e) { let i = [], s = e.root; for (; ;) { if (i = i.concat(s.segments), 0 === s.numberOfChildren) return z(i); if (s.numberOfChildren > 1 || !s.children[le]) return oa(new T(4e3, fu)); s = s.children[le] } } applyRedirectCommands(t, e, i) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, i) } applyRedirectCreatreUrlTree(t, e, i, s) { const r = this.createSegmentGroup(t, e.root, i, s); return new Rs(r, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const i = {}; return _t(t, (s, r) => { if ("string" == typeof s && s.startsWith(":")) { const a = s.substring(1); i[r] = e[a] } else i[r] = s }), i } createSegmentGroup(t, e, i, s) { const r = this.createSegments(t, e.segments, i, s); let o = {}; return _t(e.children, (a, l) => { o[l] = this.createSegmentGroup(t, a, i, s) }), new de(r, o) } createSegments(t, e, i, s) { return e.map(r => r.path.startsWith(":") ? this.findPosParam(t, r, s) : this.findOrReturn(r, i)) } findPosParam(t, e, i) { const s = i[e.path.substring(1)]; if (!s) throw new T(4001, fu); return s } findOrReturn(t, e) { let i = 0; for (const s of e) { if (s.path === t.path) return e.splice(i), s; i++ } return t } } function _g(n) { const t = {}; for (const i of Object.keys(n.children)) { const r = _g(n.children[i]); (r.segments.length > 0 || r.hasChildren()) && (t[i] = r) } return function v5(n) { if (1 === n.numberOfChildren && n.children[le]) { const t = n.children[le]; return new de(n.segments.concat(t.segments), t.children) } return n }(new de(n.segments, t)) } class xx { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class gu { constructor(t, e) { this.component = t, this.route = e } } function b5(n, t, e) { const i = n._root; return ma(i, t ? t._root : null, e, [i.value]) } function mu(n, t, e) { return (yx(t) ?? e).get(n) } function ma(n, t, e, i, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = Vr(t); return n.children.forEach(o => { (function D5(n, t, e, i, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = n.value, o = t ? t.value : null, a = e ? e.getContext(n.value.outlet) : null; if (o && r.routeConfig === o.routeConfig) { const l = function x5(n, t, e) { if ("function" == typeof e) return e(n, t); switch (e) { case "pathParamsChange": return !Os(n.url, t.url); case "pathParamsOrQueryParamsChange": return !Os(n.url, t.url) || !ni(n.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !dg(n, t) || !ni(n.queryParams, t.queryParams); default: return !dg(n, t) } }(o, r, r.routeConfig.runGuardsAndResolvers); l ? s.canActivateChecks.push(new xx(i)) : (r.data = o.data, r._resolvedData = o._resolvedData), ma(n, t, r.component ? a ? a.children : null : e, i, s), l && a && a.outlet && a.outlet.isActivated && s.canDeactivateChecks.push(new gu(a.outlet.component, o)) } else o && ya(t, a, s), s.canActivateChecks.push(new xx(i)), ma(n, null, r.component ? a ? a.children : null : e, i, s) })(o, r[o.value.outlet], e, i.concat([o.value]), s), delete r[o.value.outlet] }), _t(r, (o, a) => ya(o, e.getContext(a), s)), s } function ya(n, t, e) { const i = Vr(n), s = n.value; _t(i, (r, o) => { ya(r, s.component ? t ? t.children.getContext(o) : null : t, e) }), e.canDeactivateChecks.push(new gu(s.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, s)) } class P5 { } function Cx(n) { return new $e(t => t.error(n)) } class O5 { constructor(t, e, i, s, r, o) { this.rootComponentType = t, this.config = e, this.urlTree = i, this.url = s, this.paramsInheritanceStrategy = r, this.relativeLinkResolution = o } recognize() { const t = du(this.urlTree.root, [], [], this.config.filter(o => void 0 === o.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, le); if (null === e) return null; const i = new ru([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, le, this.rootComponentType, null, this.urlTree.root, -1, {}), s = new Di(i, e), r = new ax(this.url, s); return this.inheritParamsAndData(r._root), r } inheritParamsAndData(t) { const e = t.value, i = ox(e, this.paramsInheritanceStrategy); e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), t.children.forEach(s => this.inheritParamsAndData(s)) } processSegmentGroup(t, e, i) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, i) } processChildren(t, e) { const i = []; for (const r of Object.keys(e.children)) { const o = e.children[r], a = mx(t, r), l = this.processSegmentGroup(a, o, r); if (null === l) return null; i.push(...l) } const s = Sx(i); return function L5(n) { n.sort((t, e) => t.value.outlet === le ? -1 : e.value.outlet === le ? 1 : t.value.outlet.localeCompare(e.value.outlet)) }(s), s } processSegment(t, e, i, s) { for (const r of t) { const o = this.processSegmentAgainstRoute(r, e, i, s); if (null !== o) return o } return bx(e, i, s) ? [] : null } processSegmentAgainstRoute(t, e, i, s) { if (t.redirectTo || !_x(t, e, i, s)) return null; let r, o = [], a = []; if ("**" === t.path) { const f = i.length > 0 ? qD(i).parameters : {}, p = Mx(e) + i.length; r = new ru(i, f, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Ax(t), _n(t), t.component ?? t._loadedComponent ?? null, t, Ex(e), p, kx(t), p) } else { const f = uu(e, t, i); if (!f.matched) return null; o = f.consumedSegments, a = f.remainingSegments; const p = Mx(e) + o.length; r = new ru(o, f.parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Ax(t), _n(t), t.component ?? t._loadedComponent ?? null, t, Ex(e), p, kx(t), p) } const l = function F5(n) { return n.children ? n.children : n.loadChildren ? n._loadedRoutes : [] }(t), { segmentGroup: c, slicedSegments: u } = du(e, o, a, l.filter(f => void 0 === f.redirectTo), this.relativeLinkResolution); if (0 === u.length && c.hasChildren()) { const f = this.processChildren(l, c); return null === f ? null : [new Di(r, f)] } if (0 === l.length && 0 === u.length) return [new Di(r, [])]; const d = _n(t) === s, h = this.processSegment(l, c, u, d ? le : s); return null === h ? null : [new Di(r, h)] } } function N5(n) { const t = n.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function Sx(n) { const t = [], e = new Set; for (const i of n) { if (!N5(i)) { t.push(i); continue } const s = t.find(r => i.value.routeConfig === r.value.routeConfig); void 0 !== s ? (s.children.push(...i.children), e.add(s)) : t.push(i) } for (const i of e) { const s = Sx(i.children); t.push(new Di(i.value, s)) } return t.filter(i => !e.has(i)) } function Ex(n) { let t = n; for (; t._sourceSegment;)t = t._sourceSegment; return t } function Mx(n) { let t = n, e = t._segmentIndexShift ?? 0; for (; t._sourceSegment;)t = t._sourceSegment, e += t._segmentIndexShift ?? 0; return e - 1 } function Ax(n) { return n.data || {} } function kx(n) { return n.resolve || {} } const wg = Symbol("RouteTitle"); function Ix(n) { return "string" == typeof n.title || null === n.title } function Dg(n) { return Wt(t => { const e = n(t); return e ? ft(e).pipe(he(() => t)) : z(t) }) } class q5 extends class W5 { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const xg = new W("ROUTES"); let Cg = (() => { class n { constructor(e, i) { this.injector = e, this.compiler = i, this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap } loadComponent(e) { if (this.componentLoaders.get(e)) return this.componentLoaders.get(e); if (e._loadedComponent) return z(e._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(e); const i = Yi(e.loadComponent()).pipe(se(r => { this.onLoadEndListener && this.onLoadEndListener(e), e._loadedComponent = r }), tg(() => { this.componentLoaders.delete(e) })), s = new FD(i, () => new Ne).pipe(Xp()); return this.componentLoaders.set(e, s), s } loadChildren(e, i) { if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i); if (i._loadedRoutes) return z({ routes: i._loadedRoutes, injector: i._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(i); const r = this.loadModuleFactoryOrRoutes(i.loadChildren).pipe(he(a => { this.onLoadEndListener && this.onLoadEndListener(i); let l, c, u = !1; Array.isArray(a) ? c = a : (l = a.create(e).injector, c = WD(l.get(xg, [], U.Self | U.Optional))); return { routes: c.map(vg), injector: l } }), tg(() => { this.childrenLoaders.delete(i) })), o = new FD(r, () => new Ne).pipe(Xp()); return this.childrenLoaders.set(i, o), o } loadModuleFactoryOrRoutes(e) { return Yi(e()).pipe(ht(i => i instanceof C1 || Array.isArray(i) ? z(i) : ft(this.compiler.compileModuleAsync(i)))) } } return n.\u0275fac = function (e) { return new (e || n)(k(Nt), k(jf)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class K5 { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Q5(n) { throw n } function Z5(n, t, e) { return t.parse("/") } const Y5 = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, X5 = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let bt = (() => { class n { constructor(e, i, s, r, o, a, l) { this.rootComponentType = e, this.urlSerializer = i, this.rootContexts = s, this.location = r, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new Ne, this.errorHandler = Q5, this.malformedUriErrorHandler = Z5, this.navigated = !1, this.lastSuccessfulId = -1, this.afterPreactivation = () => z(void 0), this.urlHandlingStrategy = new K5, this.routeReuseStrategy = new q5, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.configLoader = o.get(Cg), this.configLoader.onLoadEndListener = h => this.triggerEvent(new fN(h)), this.configLoader.onLoadStartListener = h => this.triggerEvent(new hN(h)), this.ngModule = o.get(zi), this.console = o.get(eR); const d = o.get(Ve); this.isNgZoneEnabled = d instanceof Ve && Ve.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = function xN() { return new Rs(new de([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = rx(this.currentUrlTree, this.rootComponentType), this.transitions = new Bn({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { return this.location.getState()?.\u0275routerPageId } setupNavigations(e) { const i = this.events; return e.pipe(qt(s => 0 !== s.id), he(s => ({ ...s, extractedUrl: this.urlHandlingStrategy.extract(s.rawUrl) })), Wt(s => { let r = !1, o = !1; return z(s).pipe(se(a => { this.currentNavigation = { id: a.id, initialUrl: a.rawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Wt(a => { const l = this.browserUrlTree.toString(), c = !this.navigated || a.extractedUrl.toString() !== l || l !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || c) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return Ox(a.source) && (this.browserUrlTree = a.extractedUrl), z(a).pipe(Wt(d => { const h = this.transitions.getValue(); return i.next(new ng(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), h !== this.transitions.getValue() ? oi : Promise.resolve(d) }), function _5(n, t, e, i) { return Wt(s => function m5(n, t, e, i, s) { return new y5(n, t, e, i, s).apply() }(n, t, e, s.extractedUrl, i).pipe(he(r => ({ ...s, urlAfterRedirects: r })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), se(d => { this.currentNavigation = { ...this.currentNavigation, finalUrl: d.urlAfterRedirects } }), function j5(n, t, e, i, s) { return ht(r => function R5(n, t, e, i, s = "emptyOnly", r = "legacy") { try { const o = new O5(n, t, e, i, s, r).recognize(); return null === o ? Cx(new P5) : z(o) } catch (o) { return Cx(o) } }(n, t, r.urlAfterRedirects, e(r.urlAfterRedirects), i, s).pipe(he(o => ({ ...r, targetSnapshot: o })))) }(this.rootComponentType, this.config, d => this.serializeUrl(d), this.paramsInheritanceStrategy, this.relativeLinkResolution), se(d => { if ("eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const f = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(f, d) } this.browserUrlTree = d.urlAfterRedirects } const h = new aN(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); i.next(h) })); if (c && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: h, extractedUrl: f, source: p, restoredState: g, extras: m } = a, y = new ng(h, this.serializeUrl(f), p, g); i.next(y); const b = rx(f, this.rootComponentType).snapshot; return z({ ...a, targetSnapshot: b, urlAfterRedirects: f, extras: { ...m, skipLocationChange: !1, replaceUrl: !1 } }) } return this.rawUrlTree = a.rawUrl, a.resolve(null), oi }), se(a => { const l = new lN(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(l) }), he(a => ({ ...a, guards: b5(a.targetSnapshot, a.currentSnapshot, this.rootContexts) })), function C5(n, t) { return ht(e => { const { targetSnapshot: i, currentSnapshot: s, guards: { canActivateChecks: r, canDeactivateChecks: o } } = e; return 0 === o.length && 0 === r.length ? z({ ...e, guardsResult: !0 }) : function S5(n, t, e, i) { return ft(n).pipe(ht(s => function I5(n, t, e, i, s) { const r = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return r && 0 !== r.length ? z(r.map(a => { const l = mu(a, t, s); return Yi(function c5(n) { return n && cu(n.canDeactivate) }(l) ? l.canDeactivate(n, t, e, i) : l(n, t, e, i)).pipe(ti()) })).pipe(pa()) : z(!0) }(s.component, s.route, e, t, i)), ti(s => !0 !== s, !0)) }(o, i, s, n).pipe(ht(a => a && function r5(n) { return "boolean" == typeof n }(a) ? function E5(n, t, e, i) { return ft(t).pipe(ks(s => jr(function T5(n, t) { return null !== n && t && t(new pN(n)), z(!0) }(s.route.parent, i), function M5(n, t) { return null !== n && t && t(new mN(n)), z(!0) }(s.route, i), function k5(n, t, e) { const i = t[t.length - 1], r = t.slice(0, t.length - 1).reverse().map(o => function w5(n) { const t = n.routeConfig ? n.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: n, guards: t } : null }(o)).filter(o => null !== o).map(o => Kc(() => z(o.guards.map(l => { const c = mu(l, o.node, e); return Yi(function l5(n) { return n && cu(n.canActivateChild) }(c) ? c.canActivateChild(i, n) : c(i, n)).pipe(ti()) })).pipe(pa()))); return z(r).pipe(pa()) }(n, s.path, e), function A5(n, t, e) { const i = t.routeConfig ? t.routeConfig.canActivate : null; if (!i || 0 === i.length) return z(!0); const s = i.map(r => Kc(() => { const o = mu(r, t, e); return Yi(function a5(n) { return n && cu(n.canActivate) }(o) ? o.canActivate(t, n) : o(t, n)).pipe(ti()) })); return z(s).pipe(pa()) }(n, s.route, e))), ti(s => !0 !== s, !0)) }(i, r, n, t) : z(a)), he(a => ({ ...e, guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), se(a => { if (Fs(a.guardsResult)) { const c = sg(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`); throw c.url = a.guardsResult, c } const l = new cN(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(l) }), qt(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, ""), !1)), Dg(a => { if (a.guards.canActivateChecks.length) return z(a).pipe(se(l => { const c = new uN(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(c) }), Wt(l => { let c = !1; return z(l).pipe(function B5(n, t) { return ht(e => { const { targetSnapshot: i, guards: { canActivateChecks: s } } = e; if (!s.length) return z(e); let r = 0; return ft(s).pipe(ks(o => function V5(n, t, e, i) { const s = n.routeConfig, r = n._resolve; return void 0 !== s?.title && !Ix(s) && (r[wg] = s.title), function H5(n, t, e, i) { const s = function $5(n) { return [...Object.keys(n), ...Object.getOwnPropertySymbols(n)] }(n); if (0 === s.length) return z({}); const r = {}; return ft(s).pipe(ht(o => function z5(n, t, e, i) { const s = mu(n, t, i); return Yi(s.resolve ? s.resolve(t, e) : s(t, e)) }(n[o], t, e, i).pipe(ti(), se(a => { r[o] = a }))), Jp(1), VD(r), Is(o => o instanceof aa ? oi : oa(o))) }(r, n, t, i).pipe(he(o => (n._resolvedData = o, n.data = ox(n, e).resolve, s && Ix(s) && (n.data[wg] = s.title), null))) }(o.route, i, n, t)), se(() => r++), Jp(1), ht(o => r === s.length ? z(e) : oi)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), se({ next: () => c = !0, complete: () => { c || (this.restoreHistory(l), this.cancelNavigationTransition(l, "At least one route resolver didn't emit any value.")) } })) }), se(l => { const c = new dN(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(c) })) }), Dg(a => { const l = c => { const u = []; c.routeConfig?.loadComponent && !c.routeConfig._loadedComponent && u.push(this.configLoader.loadComponent(c.routeConfig).pipe(se(d => { c.component = d }), he(() => { }))); for (const d of c.children) u.push(...l(d)); return u }; return OD(l(a.targetSnapshot.root)).pipe(eg(), ln(1)) }), Dg(() => this.afterPreactivation()), he(a => { const l = function HN(n, t, e) { const i = ua(n, t._root, e ? e._root : void 0); return new sx(i, t) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return { ...a, targetRouterState: l } }), se(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((n, t, e) => he(i => (new s5(t, i.targetRouterState, i.currentRouterState, e).activate(n), i)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), se({ next() { r = !0 }, complete() { r = !0 } }), tg(() => { r || o || this.cancelNavigationTransition(s, `Navigation ID ${s.id} is not equal to the current navigation id ${this.navigationId}`), this.currentNavigation?.id === s.id && (this.currentNavigation = null) }), Is(a => { if (o = !0, function bN(n) { return n && n[zD] }(a)) { const l = Fs(a.url); l || (this.navigated = !0, this.restoreHistory(s, !0)); const c = new Jc(s.id, this.serializeUrl(s.extractedUrl), a.message); if (i.next(c), l) { const u = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), d = { skipLocationChange: s.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || Ox(s.source) }; this.scheduleNavigation(u, "imperative", null, d, { resolve: s.resolve, reject: s.reject, promise: s.promise }) } else s.resolve(!1) } else { this.restoreHistory(s, !0); const l = new HD(s.id, this.serializeUrl(s.extractedUrl), a); i.next(l); try { s.resolve(this.errorHandler(a)) } catch (c) { s.reject(c) } } return oi })) })) } resetRootComponentType(e) { this.rootComponentType = e, this.routerState.root.component = this.rootComponentType } setTransition(e) { this.transitions.next({ ...this.transitions.value, ...e }) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => { const i = "popstate" === e.type ? "popstate" : "hashchange"; "popstate" === i && setTimeout(() => { const s = { replaceUrl: !0 }, r = e.state?.navigationId ? e.state : null; if (r) { const a = { ...r }; delete a.navigationId, delete a.\u0275routerPageId, 0 !== Object.keys(a).length && (s.state = a) } const o = this.parseUrl(e.url); this.scheduleNavigation(o, i, r, s) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(e) { this.events.next(e) } resetConfig(e) { this.config = e.map(vg), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(e, i = {}) { const { relativeTo: s, queryParams: r, fragment: o, queryParamsHandling: a, preserveFragment: l } = i, c = s || this.routerState.root, u = l ? this.currentUrlTree.fragment : o; let d = null; switch (a) { case "merge": d = { ...this.currentUrlTree.queryParams, ...r }; break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = r || null }return null !== d && (d = this.removeEmptyProps(d)), function UN(n, t, e, i, s) { if (0 === e.length) return fg(t.root, t.root, t.root, i, s); const r = function WN(n) { if ("string" == typeof n[0] && 1 === n.length && "/" === n[0]) return new ux(!0, 0, n); let t = 0, e = !1; const i = n.reduce((s, r, o) => { if ("object" == typeof r && null != r) { if (r.outlets) { const a = {}; return _t(r.outlets, (l, c) => { a[c] = "string" == typeof l ? l.split("/") : l }), [...s, { outlets: a }] } if (r.segmentPath) return [...s, r.segmentPath] } return "string" != typeof r ? [...s, r] : 0 === o ? (r.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? e = !0 : ".." === a ? t++ : "" != a && s.push(a)) }), s) : [...s, r] }, []); return new ux(e, t, i) }(e); return r.toRoot() ? fg(t.root, t.root, new de([], {}), i, s) : function o(l) { const c = function qN(n, t, e, i) { return n.isAbsolute ? new pg(t.root, !0, 0) : -1 === i ? new pg(e, e === t.root, 0) : function GN(n, t, e) { let i = n, s = t, r = e; for (; r > s;) { if (r -= s, i = i.parent, !i) throw new T(4005, !1); s = i.segments.length } return new pg(i, !1, s - r) }(e, i + (ou(n.commands[0]) ? 0 : 1), n.numberOfDoubleDots) }(r, t, n.snapshot?._urlSegment, l), u = c.processChildren ? au(c.segmentGroup, c.index, r.commands) : dx(c.segmentGroup, c.index, r.commands); return fg(t.root, c.segmentGroup, u, i, s) }(n.snapshot?._lastPathIndex) }(c, this.currentUrlTree, e, d, u ?? null) } navigateByUrl(e, i = { skipLocationChange: !1 }) { const s = Fs(e) ? e : this.parseUrl(e), r = this.urlHandlingStrategy.merge(s, this.rawUrlTree); return this.scheduleNavigation(r, "imperative", null, i) } navigate(e, i = { skipLocationChange: !1 }) { return function J5(n) { for (let t = 0; t < n.length; t++) { if (null == n[t]) throw new T(4008, !1) } }(e), this.navigateByUrl(this.createUrlTree(e, i), i) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { let i; try { i = this.urlSerializer.parse(e) } catch (s) { i = this.malformedUriErrorHandler(s, this.urlSerializer, e) } return i } isActive(e, i) { let s; if (s = !0 === i ? { ...Y5 } : !1 === i ? { ...X5 } : i, Fs(e)) return KD(this.currentUrlTree, e, s); const r = this.parseUrl(e); return KD(this.currentUrlTree, r, s) } removeEmptyProps(e) { return Object.keys(e).reduce((i, s) => { const r = e[s]; return null != r && (i[s] = r), i }, {}) } processNavigations() { this.navigations.subscribe(e => { this.navigated = !0, this.lastSuccessfulId = e.id, this.currentPageId = e.targetPageId, this.events.next(new Ps(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.titleStrategy?.updateTitle(this.routerState.snapshot), e.resolve(!0) }, e => { this.console.warn(`Unhandled Navigation Error: ${e}`) }) } scheduleNavigation(e, i, s, r, o) { if (this.disposed) return Promise.resolve(!1); let a, l, c; o ? (a = o.resolve, l = o.reject, c = o.promise) : c = new Promise((h, f) => { a = h, l = f }); const u = ++this.navigationId; let d; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (s = this.location.getState()), d = s && s.\u0275routerPageId ? s.\u0275routerPageId : r.replaceUrl || r.skipLocationChange ? this.browserPageId ?? 0 : (this.browserPageId ?? 0) + 1) : d = 0, this.setTransition({ id: u, targetPageId: d, source: i, restoredState: s, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: e, extras: r, resolve: a, reject: l, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(h => Promise.reject(h)) } setBrowserUrl(e, i) { const s = this.urlSerializer.serialize(e), r = { ...i.extras.state, ...this.generateNgRouterState(i.id, i.targetPageId) }; this.location.isCurrentPathEqualTo(s) || i.extras.replaceUrl ? this.location.replaceState(s, "", r) : this.location.go(s, "", r) } restoreHistory(e, i = !1) { if ("computed" === this.canceledNavigationResolution) { const s = this.currentPageId - e.targetPageId; "popstate" !== e.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== this.currentNavigation?.finalUrl || 0 === s ? this.currentUrlTree === this.currentNavigation?.finalUrl && 0 === s && (this.resetState(e), this.browserUrlTree = e.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(s) } else "replace" === this.canceledNavigationResolution && (i && this.resetState(e), this.resetUrlToCurrentUrlTree()) } resetState(e) { this.routerState = e.currentRouterState, this.currentUrlTree = e.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(e, i) { const s = new Jc(e.id, this.serializeUrl(e.extractedUrl), i); this.triggerEvent(s), e.resolve(!1) } generateNgRouterState(e, i) { return "computed" === this.canceledNavigationResolution ? { navigationId: e, \u0275routerPageId: i } : { navigationId: e } } } return n.\u0275fac = function (e) { Oh() }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); function Ox(n) { return "imperative" !== n } let Hr = (() => { class n { constructor(e, i, s, r, o) { this.router = e, this.route = i, this.tabIndexAttribute = s, this.renderer = r, this.el = o, this.commands = null, this.onChanges = new Ne, this.setTabIndexIfNotOnNativeEl("0") } setTabIndexIfNotOnNativeEl(e) { if (null != this.tabIndexAttribute) return; const i = this.renderer, s = this.el.nativeElement; null !== e ? i.setAttribute(s, "tabindex", e) : i.removeAttribute(s, "tabindex") } ngOnChanges(e) { this.onChanges.next(this) } set routerLink(e) { null != e ? (this.commands = Array.isArray(e) ? e : [e], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick() { if (null === this.urlTree) return !0; const e = { skipLocationChange: Fr(this.skipLocationChange), replaceUrl: Fr(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, e), !0 } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: Fr(this.preserveFragment) }) } } return n.\u0275fac = function (e) { return new (e || n)(L(bt), L(Ls), lo("tabindex"), L(No), L(Xn)) }, n.\u0275dir = mt({ type: n, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (e, i) { 1 & e && Pe("click", function () { return i.onClick() }) }, inputs: { queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo", routerLink: "routerLink" }, features: [Li] }), n })(), yu = (() => { class n { constructor(e, i, s) { this.router = e, this.route = i, this.locationStrategy = s, this.commands = null, this.href = null, this.onChanges = new Ne, this.subscription = e.events.subscribe(r => { r instanceof Ps && this.updateTargetUrlAndHref() }) } set routerLink(e) { this.commands = null != e ? Array.isArray(e) ? e : [e] : null } ngOnChanges(e) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(e, i, s, r, o) { if (0 !== e || i || s || r || o || "string" == typeof this.target && "_self" != this.target || null === this.urlTree) return !0; const a = { skipLocationChange: Fr(this.skipLocationChange), replaceUrl: Fr(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, a), !1 } updateTargetUrlAndHref() { this.href = null !== this.urlTree ? this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: Fr(this.preserveFragment) }) } } return n.\u0275fac = function (e) { return new (e || n)(L(bt), L(Ls), L(Ss)) }, n.\u0275dir = mt({ type: n, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (e, i) { 1 & e && Pe("click", function (r) { return i.onClick(r.button, r.ctrlKey, r.shiftKey, r.altKey, r.metaKey) }), 2 & e && cf("target", i.target)("href", i.href, hr) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo", routerLink: "routerLink" }, features: [Li] }), n })(); class Lx { buildTitle(t) { let e, i = t.root; for (; void 0 !== i;)e = this.getResolvedTitleForRoute(i) ?? e, i = i.children.find(s => s.outlet === le); return e } getResolvedTitleForRoute(t) { return t.data[wg] } } let n8 = (() => { class n extends Lx { constructor(e) { super(), this.title = e } updateTitle(e) { const i = this.buildTitle(e); void 0 !== i && this.title.setTitle(i) } } return n.\u0275fac = function (e) { return new (e || n)(k(Iw)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); class Fx { } let Nx = (() => { class n { constructor(e, i, s, r, o) { this.router = e, this.injector = s, this.preloadingStrategy = r, this.loader = o } setUpPreloading() { this.subscription = this.router.events.pipe(qt(e => e instanceof Ps), ks(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(e, i) { const s = []; for (const r of i) { r.providers && !r._injector && (r._injector = Jl(r.providers, e, `Route: ${r.path}`)); const o = r._injector ?? e, a = r._loadedInjector ?? o; r.loadChildren && !r._loadedRoutes || r.loadComponent && !r._loadedComponent ? s.push(this.preloadConfig(o, r)) : (r.children || r._loadedRoutes) && s.push(this.processRoutes(a, r.children ?? r._loadedRoutes)) } return ft(s).pipe(Ks()) } preloadConfig(e, i) { return this.preloadingStrategy.preload(i, () => { let s; s = i.loadChildren && void 0 === i.canLoad ? this.loader.loadChildren(e, i) : z(null); const r = s.pipe(ht(o => null === o ? z(void 0) : (i._loadedRoutes = o.routes, i._loadedInjector = o.injector, this.processRoutes(o.injector ?? e, o.routes)))); return i.loadComponent && !i._loadedComponent ? ft([r, this.loader.loadComponent(i)]).pipe(Ks()) : r }) } } return n.\u0275fac = function (e) { return new (e || n)(k(bt), k(jf), k(_s), k(Fx), k(Cg)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const jx = new W(""); let i8 = (() => { class n { constructor(e, i, s = {}) { this.router = e, this.viewportScroller = i, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(e => { e instanceof ng ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof Ps && (this.lastId = e.id, this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(e => { e instanceof $D && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, i) { this.router.triggerEvent(new $D(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, i)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return n.\u0275fac = function (e) { Oh() }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const Sg = new W("ROUTER_CONFIGURATION", { providedIn: "root", factory: () => ({}) }), Bx = new W("ROUTER_FORROOT_GUARD"), Vx = new W(""), s8 = [Xf, { provide: XD, useClass: JD }, { provide: bt, useFactory: function u8(n, t, e, i, s, r, o = {}, a, l, c, u) { const d = new bt(null, n, t, e, i, s, WD(r)); return c && (d.urlHandlingStrategy = c), u && (d.routeReuseStrategy = u), d.titleStrategy = l ?? a, function d8(n, t) { n.errorHandler && (t.errorHandler = n.errorHandler), n.malformedUriErrorHandler && (t.malformedUriErrorHandler = n.malformedUriErrorHandler), n.onSameUrlNavigation && (t.onSameUrlNavigation = n.onSameUrlNavigation), n.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = n.paramsInheritanceStrategy), n.relativeLinkResolution && (t.relativeLinkResolution = n.relativeLinkResolution), n.urlUpdateStrategy && (t.urlUpdateStrategy = n.urlUpdateStrategy), n.canceledNavigationResolution && (t.canceledNavigationResolution = n.canceledNavigationResolution) }(o, d), d }, deps: [XD, ha, Xf, Nt, jf, xg, Sg, n8, [Lx, new Bi], [class G5 { }, new Bi], [class U5 { }, new Bi]] }, ha, { provide: Ls, useFactory: function h8(n) { return n.routerState.root }, deps: [bt] }, Cg]; function r8() { return new Db("Router", bt) } let Hx = (() => { class n { constructor(e, i) { } static forRoot(e, i) { return { ngModule: n, providers: [s8, [], $x(e), { provide: Bx, useFactory: c8, deps: [[bt, new Bi, new mo]] }, { provide: Sg, useValue: i || {} }, i?.useHash ? { provide: Ss, useClass: WR } : { provide: Ss, useClass: qb }, { provide: jx, useFactory: () => { const n = gs(bt), t = gs(a4), e = gs(Sg); return e.scrollOffset && t.setOffset(e.scrollOffset), new i8(n, t, e) } }, i?.preloadingStrategy ? _8(i.preloadingStrategy) : [], { provide: Db, multi: !0, useFactory: r8 }, i?.initialNavigation ? p8(i) : [], [{ provide: zx, useFactory: f8 }, { provide: pb, multi: !0, useExisting: zx }]] } } static forChild(e) { return { ngModule: n, providers: [$x(e)] } } } return n.\u0275fac = function (e) { return new (e || n)(k(Bx, 8), k(bt, 8)) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({}), n })(); function c8(n) { return "guarded" } function $x(n) { return [{ provide: _M, multi: !0, useValue: n }, { provide: xg, multi: !0, useValue: n }] } function f8() { const n = gs(Nt); return t => { const e = n.get(Wo); if (t !== e.components[0]) return; const i = n.get(bt), s = n.get(Ux); null === n.get(Eg, null, U.Optional) && i.initialNavigation(), n.get(Vx, null, U.Optional)?.setUpPreloading(), n.get(jx, null, U.Optional)?.init(), i.resetRootComponentType(e.componentTypes[0]), s.next(), s.complete() } } const zx = new W(""); function p8(n) { return ["disabled" === n.initialNavigation ? [{ provide: ac, multi: !0, useFactory: () => { const n = gs(bt); return () => { n.setUpLocationChangeListener() } } }, { provide: Eg, useValue: "disabled" }] : [], "enabledBlocking" === n.initialNavigation ? [{ provide: Eg, useValue: "enabledBlocking" }, { provide: ac, multi: !0, deps: [Nt], useFactory: n => { const t = n.get($R, Promise.resolve(null)); let e = !1; return () => t.then(() => new Promise(s => { const r = n.get(bt), o = n.get(Ux); (function i(s) { const r = n.get(bt); r.events.pipe(qt(o => o instanceof Ps || o instanceof Jc || o instanceof HD), he(o => { if (o instanceof Ps) return !0; const a = r.navigationId !== o.id, l = o instanceof Jc && -1 !== o.reason.indexOf(ig); return !(!a && !l) && null }), qt(o => null !== o), ln(1)).subscribe(() => { s() }) })(() => { s(!0), e = !0 }), r.afterPreactivation = () => (s(!0), e || o.closed ? z(void 0) : o), r.initialNavigation() })) } }] : []] } const Ux = new W("", { factory: () => new Ne }), Eg = new W(""); function _8(n) { return [Nx, { provide: Vx, useExisting: Nx }, { provide: Fx, useExisting: n }] } let b8 = (() => { class n { constructor(e) { this.translate = e, e.setDefaultLang("en") } ngOnInit() { } } return n.\u0275fac = function (e) { return new (e || n)(L(ra)) }, n.\u0275cmp = Un({ type: n, selectors: [["app-root"]], decls: 1, vars: 0, template: function (e, i) { 1 & e && C(0, "router-outlet") }, dependencies: [mg] }), n })(); class w8 { constructor(t, e = "/assets/i18n/", i = ".json") { this.http = t, this.prefix = e, this.suffix = i } getTranslation(t) { return this.http.get(`${this.prefix}${t}${this.suffix}`) } } class Wx { } class qx { } class Ci { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(e => { const i = e.indexOf(":"); if (i > 0) { const s = e.slice(0, i), r = s.toLowerCase(), o = e.slice(i + 1).trim(); this.maybeSetNormalizedName(s, r), this.headers.has(r) ? this.headers.get(r).push(o) : this.headers.set(r, [o]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let i = t[e]; const s = e.toLowerCase(); "string" == typeof i && (i = [i]), i.length > 0 && (this.headers.set(s, i), this.maybeSetNormalizedName(e, s)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof Ci ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new Ci; return e.lazyInit = this.lazyInit && this.lazyInit instanceof Ci ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let i = t.value; if ("string" == typeof i && (i = [i]), 0 === i.length) return; this.maybeSetNormalizedName(t.name, e); const s = ("a" === t.op ? this.headers.get(e) : void 0) || []; s.push(...i), this.headers.set(e, s); break; case "d": const r = t.value; if (r) { let o = this.headers.get(e); if (!o) return; o = o.filter(a => -1 === r.indexOf(a)), 0 === o.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, o) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class D8 { encodeKey(t) { return Gx(t) } encodeValue(t) { return Gx(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } const C8 = /%(\d[a-f0-9])/gi, S8 = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function Gx(n) { return encodeURIComponent(n).replace(C8, (t, e) => S8[e] ?? t) } function vu(n) { return `${n}` } class Xi { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new D8, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function x8(n, t) { const e = new Map; return n.length > 0 && n.replace(/^\?/, "").split("&").forEach(s => { const r = s.indexOf("="), [o, a] = -1 == r ? [t.decodeKey(s), ""] : [t.decodeKey(s.slice(0, r)), t.decodeValue(s.slice(r + 1))], l = e.get(o) || []; l.push(a), e.set(o, l) }), e }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const i = t.fromObject[e], s = Array.isArray(i) ? i.map(vu) : [vu(i)]; this.map.set(e, s) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(i => { const s = t[i]; Array.isArray(s) ? s.forEach(r => { e.push({ param: i, value: r, op: "a" }) }) : e.push({ param: i, value: s, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(i => e + "=" + this.encoder.encodeValue(i)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new Xi({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(vu(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let i = this.map.get(t.param) || []; const s = i.indexOf(vu(t.value)); -1 !== s && i.splice(s, 1), i.length > 0 ? this.map.set(t.param, i) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class E8 { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } } function Kx(n) { return typeof ArrayBuffer < "u" && n instanceof ArrayBuffer } function Qx(n) { return typeof Blob < "u" && n instanceof Blob } function Zx(n) { return typeof FormData < "u" && n instanceof FormData } class va { constructor(t, e, i, s) { let r; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function M8(n) { switch (n) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || s ? (this.body = void 0 !== i ? i : null, r = s) : r = i, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.context && (this.context = r.context), r.params && (this.params = r.params)), this.headers || (this.headers = new Ci), this.context || (this.context = new E8), this.params) { const o = this.params.toString(); if (0 === o.length) this.urlWithParams = e; else { const a = e.indexOf("?"); this.urlWithParams = e + (-1 === a ? "?" : a < e.length - 1 ? "&" : "") + o } } else this.params = new Xi, this.urlWithParams = e } serializeBody() { return null === this.body ? null : Kx(this.body) || Qx(this.body) || Zx(this.body) || function T8(n) { return typeof URLSearchParams < "u" && n instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Xi ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Zx(this.body) ? null : Qx(this.body) ? this.body.type || null : Kx(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Xi ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { const e = t.method || this.method, i = t.url || this.url, s = t.responseType || this.responseType, r = void 0 !== t.body ? t.body : this.body, o = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let l = t.headers || this.headers, c = t.params || this.params; const u = t.context ?? this.context; return void 0 !== t.setHeaders && (l = Object.keys(t.setHeaders).reduce((d, h) => d.set(h, t.setHeaders[h]), l)), t.setParams && (c = Object.keys(t.setParams).reduce((d, h) => d.set(h, t.setParams[h]), c)), new va(e, i, r, { params: c, headers: l, context: u, reportProgress: a, responseType: s, withCredentials: o }) } } var it = (() => ((it = it || {})[it.Sent = 0] = "Sent", it[it.UploadProgress = 1] = "UploadProgress", it[it.ResponseHeader = 2] = "ResponseHeader", it[it.DownloadProgress = 3] = "DownloadProgress", it[it.Response = 4] = "Response", it[it.User = 5] = "User", it))(); class Mg { constructor(t, e = 200, i = "OK") { this.headers = t.headers || new Ci, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || i, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Tg extends Mg { constructor(t = {}) { super(t), this.type = it.ResponseHeader } clone(t = {}) { return new Tg({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class _u extends Mg { constructor(t = {}) { super(t), this.type = it.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new _u({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Yx extends Mg { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Ag(n, t) { return { body: t, headers: n.headers, context: n.context, observe: n.observe, params: n.params, reportProgress: n.reportProgress, responseType: n.responseType, withCredentials: n.withCredentials } } let Xx = (() => { class n { constructor(e) { this.handler = e } request(e, i, s = {}) { let r; if (e instanceof va) r = e; else { let l, c; l = s.headers instanceof Ci ? s.headers : new Ci(s.headers), s.params && (c = s.params instanceof Xi ? s.params : new Xi({ fromObject: s.params })), r = new va(e, i, void 0 !== s.body ? s.body : null, { headers: l, context: s.context, params: c, reportProgress: s.reportProgress, responseType: s.responseType || "json", withCredentials: s.withCredentials }) } const o = z(r).pipe(ks(l => this.handler.handle(l))); if (e instanceof va || "events" === s.observe) return o; const a = o.pipe(qt(l => l instanceof _u)); switch (s.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return a.pipe(he(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(he(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(he(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(he(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${s.observe}}`) } } delete(e, i = {}) { return this.request("DELETE", e, i) } get(e, i = {}) { return this.request("GET", e, i) } head(e, i = {}) { return this.request("HEAD", e, i) } jsonp(e, i) { return this.request("JSONP", e, { params: (new Xi).append(i, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, i = {}) { return this.request("OPTIONS", e, i) } patch(e, i, s = {}) { return this.request("PATCH", e, Ag(s, i)) } post(e, i, s = {}) { return this.request("POST", e, Ag(s, i)) } put(e, i, s = {}) { return this.request("PUT", e, Ag(s, i)) } } return n.\u0275fac = function (e) { return new (e || n)(k(Wx)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); class Jx { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const eC = new W("HTTP_INTERCEPTORS"); let A8 = (() => { class n { intercept(e, i) { return i.handle(e) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const k8 = /^\)\]\}',?\n/; let tC = (() => { class n { constructor(e) { this.xhrFactory = e } handle(e) { if ("JSONP" === e.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new $e(i => { const s = this.xhrFactory.build(); if (s.open(e.method, e.urlWithParams), e.withCredentials && (s.withCredentials = !0), e.headers.forEach((f, p) => s.setRequestHeader(f, p.join(","))), e.headers.has("Accept") || s.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { const f = e.detectContentTypeHeader(); null !== f && s.setRequestHeader("Content-Type", f) } if (e.responseType) { const f = e.responseType.toLowerCase(); s.responseType = "json" !== f ? f : "text" } const r = e.serializeBody(); let o = null; const a = () => { if (null !== o) return o; const f = s.statusText || "OK", p = new Ci(s.getAllResponseHeaders()), g = function I8(n) { return "responseURL" in n && n.responseURL ? n.responseURL : /^X-Request-URL:/m.test(n.getAllResponseHeaders()) ? n.getResponseHeader("X-Request-URL") : null }(s) || e.url; return o = new Tg({ headers: p, status: s.status, statusText: f, url: g }), o }, l = () => { let { headers: f, status: p, statusText: g, url: m } = a(), y = null; 204 !== p && (y = typeof s.response > "u" ? s.responseText : s.response), 0 === p && (p = y ? 200 : 0); let b = p >= 200 && p < 300; if ("json" === e.responseType && "string" == typeof y) { const v = y; y = y.replace(k8, ""); try { y = "" !== y ? JSON.parse(y) : null } catch (D) { y = v, b && (b = !1, y = { error: D, text: y }) } } b ? (i.next(new _u({ body: y, headers: f, status: p, statusText: g, url: m || void 0 })), i.complete()) : i.error(new Yx({ error: y, headers: f, status: p, statusText: g, url: m || void 0 })) }, c = f => { const { url: p } = a(), g = new Yx({ error: f, status: s.status || 0, statusText: s.statusText || "Unknown Error", url: p || void 0 }); i.error(g) }; let u = !1; const d = f => { u || (i.next(a()), u = !0); let p = { type: it.DownloadProgress, loaded: f.loaded }; f.lengthComputable && (p.total = f.total), "text" === e.responseType && !!s.responseText && (p.partialText = s.responseText), i.next(p) }, h = f => { let p = { type: it.UploadProgress, loaded: f.loaded }; f.lengthComputable && (p.total = f.total), i.next(p) }; return s.addEventListener("load", l), s.addEventListener("error", c), s.addEventListener("timeout", c), s.addEventListener("abort", c), e.reportProgress && (s.addEventListener("progress", d), null !== r && s.upload && s.upload.addEventListener("progress", h)), s.send(r), i.next({ type: it.Sent }), () => { s.removeEventListener("error", c), s.removeEventListener("abort", c), s.removeEventListener("load", l), s.removeEventListener("timeout", c), e.reportProgress && (s.removeEventListener("progress", d), null !== r && s.upload && s.upload.removeEventListener("progress", h)), s.readyState !== s.DONE && s.abort() } }) } } return n.\u0275fac = function (e) { return new (e || n)(k(pw)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const kg = new W("XSRF_COOKIE_NAME"), Ig = new W("XSRF_HEADER_NAME"); class nC { } let P8 = (() => { class n { constructor(e, i, s) { this.doc = e, this.platform = i, this.cookieName = s, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const e = this.doc.cookie || ""; return e !== this.lastCookieString && (this.parseCount++, this.lastToken = nw(e, this.cookieName), this.lastCookieString = e), this.lastToken } } return n.\u0275fac = function (e) { return new (e || n)(k(vt), k(Uo), k(kg)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), Pg = (() => { class n { constructor(e, i) { this.tokenService = e, this.headerName = i } intercept(e, i) { const s = e.url.toLowerCase(); if ("GET" === e.method || "HEAD" === e.method || s.startsWith("http://") || s.startsWith("https://")) return i.handle(e); const r = this.tokenService.getToken(); return null !== r && !e.headers.has(this.headerName) && (e = e.clone({ headers: e.headers.set(this.headerName, r) })), i.handle(e) } } return n.\u0275fac = function (e) { return new (e || n)(k(nC), k(Ig)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), R8 = (() => { class n { constructor(e, i) { this.backend = e, this.injector = i, this.chain = null } handle(e) { if (null === this.chain) { const i = this.injector.get(eC, []); this.chain = i.reduceRight((s, r) => new Jx(s, r), this.backend) } return this.chain.handle(e) } } return n.\u0275fac = function (e) { return new (e || n)(k(qx), k(Nt)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), O8 = (() => { class n { static disable() { return { ngModule: n, providers: [{ provide: Pg, useClass: A8 }] } } static withOptions(e = {}) { return { ngModule: n, providers: [e.cookieName ? { provide: kg, useValue: e.cookieName } : [], e.headerName ? { provide: Ig, useValue: e.headerName } : []] } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({ providers: [Pg, { provide: eC, useExisting: Pg, multi: !0 }, { provide: nC, useClass: P8 }, { provide: kg, useValue: "XSRF-TOKEN" }, { provide: Ig, useValue: "X-XSRF-TOKEN" }] }), n })(), L8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({ providers: [Xx, { provide: Wx, useClass: R8 }, tC, { provide: qx, useExisting: tC }], imports: [O8.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })] }), n })(); function iC(n) { return qt((t, e) => n <= e) } const N8 = (n, t) => (n.push(t), n); class B8 extends Qt { constructor(t, e) { super() } schedule(t, e = 0) { return this } } const bu = { setInterval(n, t, ...e) { const { delegate: i } = bu; return i?.setInterval ? i.setInterval(n, t, ...e) : setInterval(n, t, ...e) }, clearInterval(n) { const { delegate: t } = bu; return (t?.clearInterval || clearInterval)(n) }, delegate: void 0 }; class _a { constructor(t, e = _a.now) { this.schedulerActionCtor = t, this.now = e } schedule(t, e = 0, i) { return new this.schedulerActionCtor(this, t).schedule(i, e) } } _a.now = Wp.now; const sC = new class H8 extends _a { constructor(t, e = _a.now) { super(t, e), this.actions = [], this._active = !1, this._scheduled = void 0 } flush(t) { const { actions: e } = this; if (this._active) return void e.push(t); let i; this._active = !0; do { if (i = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this._active = !1, i) { for (; t = e.shift();)t.unsubscribe(); throw i } } }(class V8 extends B8 { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const i = this.id, s = this.scheduler; return null != i && (this.id = this.recycleAsyncId(s, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(s, this.id, e), this } requestAsyncId(t, e, i = 0) { return bu.setInterval(t.flush.bind(t, this), i) } recycleAsyncId(t, e, i = 0) { if (null != i && this.delay === i && !1 === this.pending) return e; bu.clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const i = this._execute(t, e); if (i) return i; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let s, i = !1; try { this.work(t) } catch (r) { i = !0, s = r || new Error("Scheduled action threw falsy error") } if (i) return this.unsubscribe(), s } unsubscribe() { if (!this.closed) { const { id: t, scheduler: e } = this, { actions: i } = e; this.work = this.state = this.scheduler = null, this.pending = !1, Gs(i, this), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null, super.unsubscribe() } } }), $8 = sC; function rC(n, t) { return t ? e => jr(t.pipe(ln(1), function z8() { return Ye((n, t) => { n.subscribe(rt(t, nd)) }) }()), e.pipe(rC(n))) : ht((e, i) => n(e, i).pipe(ln(1), VD(e))) } function G8(n, t) { } const K8 = function (n, t) { return { $implicit: n, index: t } }; function Q8(n, t) { if (1 & n && jt(0, G8, 0, 0, "ng-template", 4), 2 & n) { const e = lt(), i = e.$implicit, s = e.index, r = lt(); De("ngTemplateOutlet", i.tplRef)("ngTemplateOutletContext", ec(2, K8, r.preparePublicSlide(i), s)) } } const Z8 = function (n, t, e, i) { return { width: n, "margin-left": t, "margin-right": e, left: i } }; function Y8(n, t) { if (1 & n) { const e = Ds(); To(0), _(1, "div", 2), Pe("animationend", function () { const r = xt(e).$implicit; return Ct(lt().clear(r.id)) }), jt(2, Q8, 1, 5, null, 3), w(), Ao() } if (2 & n) { const e = t.$implicit; M(1), De("ngClass", e.classes)("ngStyle", O1(4, Z8, e.width + "px", e.marginL ? e.marginL + "px" : "", e.marginR ? e.marginR + "px" : "", e.left))("@autoHeight", e.heightState), M(1), De("ngIf", e.load) } } const X8 = function (n, t, e, i, s) { return { width: n, transform: t, transition: e, "padding-left": i, "padding-right": s } }, J8 = function (n, t) { return { isMouseDragable: n, isTouchDragable: t } }; function e6(n, t) { if (1 & n && (_(0, "div", 4), C(1, "owl-stage", 5), w()), 2 & n) { const e = lt(); M(1), De("owlDraggable", ec(3, J8, null == e.owlDOMData ? null : e.owlDOMData.isMouseDragable, null == e.owlDOMData ? null : e.owlDOMData.isTouchDragable))("stageData", e.stageData)("slidesData", e.slidesData) } } const t6 = function (n, t) { return { active: n, "owl-dot-text": t } }; function n6(n, t) { if (1 & n) { const e = Ds(); _(0, "div", 11), Pe("click", function () { const r = xt(e).$implicit; return Ct(lt(2).moveByDot(r.id)) }), C(1, "span", 12), w() } if (2 & n) { const e = t.$implicit; De("ngClass", ec(2, t6, e.active, e.showInnerContent)), M(1), De("innerHTML", e.innerContent, kl) } } const wu = function (n) { return { disabled: n } }; function i6(n, t) { if (1 & n) { const e = Ds(); To(0), _(1, "div", 6)(2, "div", 7), Pe("click", function () { return xt(e), Ct(lt().prev()) }), w(), _(3, "div", 8), Pe("click", function () { return xt(e), Ct(lt().next()) }), w()(), _(4, "div", 9), jt(5, n6, 2, 5, "div", 10), w(), Ao() } if (2 & n) { const e = lt(); M(1), De("ngClass", Bo(7, wu, null == e.navData ? null : e.navData.disabled)), M(1), De("ngClass", Bo(9, wu, null == e.navData || null == e.navData.prev ? null : e.navData.prev.disabled))("innerHTML", null == e.navData || null == e.navData.prev ? null : e.navData.prev.htmlText, kl), M(1), De("ngClass", Bo(11, wu, null == e.navData || null == e.navData.next ? null : e.navData.next.disabled))("innerHTML", null == e.navData || null == e.navData.next ? null : e.navData.next.htmlText, kl), M(1), De("ngClass", Bo(13, wu, null == e.dotsData ? null : e.dotsData.disabled)), M(1), De("ngForOf", null == e.dotsData ? null : e.dotsData.dots) } } const s6 = function (n, t, e, i, s) { return { "owl-rtl": n, "owl-loaded": t, "owl-responsive": e, "owl-drag": i, "owl-grab": s } }; class r6 { constructor() { this.items = 3, this.skip_validateItems = !1, this.loop = !1, this.center = !1, this.rewind = !1, this.mouseDrag = !0, this.touchDrag = !0, this.pullDrag = !0, this.freeDrag = !1, this.margin = 0, this.stagePadding = 0, this.merge = !1, this.mergeFit = !0, this.autoWidth = !1, this.startPosition = 0, this.rtl = !1, this.smartSpeed = 250, this.fluidSpeed = !1, this.dragEndSpeed = !1, this.responsive = {}, this.responsiveRefreshRate = 200, this.nav = !1, this.navText = ["prev", "next"], this.navSpeed = !1, this.slideBy = 1, this.dots = !0, this.dotsEach = !1, this.dotsData = !1, this.dotsSpeed = !1, this.autoplay = !1, this.autoplayTimeout = 5e3, this.autoplayHoverPause = !1, this.autoplaySpeed = !1, this.autoplayMouseleaveTimeout = 1, this.lazyLoad = !1, this.lazyLoadEager = 0, this.slideTransition = "", this.animateOut = !1, this.animateIn = !1, this.autoHeight = !1, this.URLhashListener = !1 } } class o6 { constructor() { this.items = "number", this.skip_validateItems = "boolean", this.loop = "boolean", this.center = "boolean", this.rewind = "boolean", this.mouseDrag = "boolean", this.touchDrag = "boolean", this.pullDrag = "boolean", this.freeDrag = "boolean", this.margin = "number", this.stagePadding = "number", this.merge = "boolean", this.mergeFit = "boolean", this.autoWidth = "boolean", this.startPosition = "number|string", this.rtl = "boolean", this.smartSpeed = "number", this.fluidSpeed = "boolean", this.dragEndSpeed = "number|boolean", this.responsive = {}, this.responsiveRefreshRate = "number", this.nav = "boolean", this.navText = "string[]", this.navSpeed = "number|boolean", this.slideBy = "number|string", this.dots = "boolean", this.dotsEach = "number|boolean", this.dotsData = "boolean", this.dotsSpeed = "number|boolean", this.autoplay = "boolean", this.autoplayTimeout = "number", this.autoplayHoverPause = "boolean", this.autoplaySpeed = "number|boolean", this.autoplayMouseleaveTimeout = "number", this.lazyLoad = "boolean", this.lazyLoadEager = "number", this.slideTransition = "string", this.animateOut = "string|boolean", this.animateIn = "string|boolean", this.autoHeight = "boolean", this.URLhashListener = "boolean" } } let Rg = (() => { class n { constructor(e) { this.errorHandler = e } log(e, ...i) { (function bR() { return Pb = !0, Ib })() && console.log(e, ...i) } error(e) { this.errorHandler.handleError(e) } warn(e, ...i) { console.warn(e, ...i) } } return n.\u0275fac = function (e) { return new (e || n)(k(ms)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); var Du = (() => { return (n = Du || (Du = {})).Event = "event", n.State = "state", Du; var n })(), $r = (() => { return (n = $r || ($r = {})).Default = "default", n.Inner = "inner", n.Outer = "outer", $r; var n })(); let Si = (() => { class n { constructor(e) { this.logger = e, this._viewSettingsShipper$ = new Ne, this._initializedCarousel$ = new Ne, this._changeSettingsCarousel$ = new Ne, this._changedSettingsCarousel$ = new Ne, this._translateCarousel$ = new Ne, this._translatedCarousel$ = new Ne, this._resizeCarousel$ = new Ne, this._resizedCarousel$ = new Ne, this._refreshCarousel$ = new Ne, this._refreshedCarousel$ = new Ne, this._dragCarousel$ = new Ne, this._draggedCarousel$ = new Ne, this.settings = { items: 0 }, this.owlDOMData = { rtl: !1, isResponsive: !1, isRefreshed: !1, isLoaded: !1, isLoading: !1, isMouseDragable: !1, isGrab: !1, isTouchDragable: !1 }, this.stageData = { transform: "translate3d(0px,0px,0px)", transition: "0s", width: 0, paddingL: 0, paddingR: 0 }, this._items = [], this._widths = [], this._supress = {}, this._plugins = {}, this._current = null, this._clones = [], this._mergers = [], this._speed = null, this._coordinates = [], this._breakpoint = null, this.clonedIdPrefix = "cloned-", this._options = {}, this._invalidated = {}, this._states = { current: {}, tags: { initializing: ["busy"], animating: ["busy"], dragging: ["interacting"] } }, this._pipe = [{ filter: ["width", "items", "settings"], run: i => { i.current = this._items && this._items[this.relative(this._current)].id } }, { filter: ["width", "items", "settings"], run: i => { const s = this.settings.margin || "", o = this.settings.rtl, a = { "margin-left": o ? s : "", "margin-right": o ? "" : s }; !this.settings.autoWidth || this.slidesData.forEach(l => { l.marginL = a["margin-left"], l.marginR = a["margin-right"] }), i.css = a } }, { filter: ["width", "items", "settings"], run: i => { const s = +(this.width() / this.settings.items).toFixed(3) - this.settings.margin, r = !this.settings.autoWidth, o = []; let a = null, l = this._items.length; for (i.items = { merge: !1, width: s }; l-- > 0;)a = this._mergers[l], a = this.settings.mergeFit && Math.min(a, this.settings.items) || a, i.items.merge = a > 1 || i.items.merge, o[l] = r ? s * a : this._items[l].width ? this._items[l].width : s; this._widths = o, this.slidesData.forEach((c, u) => { c.width = this._widths[u], c.marginR = i.css["margin-right"], c.marginL = i.css["margin-left"] }) } }, { filter: ["items", "settings"], run: () => { const i = [], s = this._items, r = this.settings, o = Math.max(2 * r.items, 4), a = 2 * Math.ceil(s.length / 2); let l = [], c = [], u = r.loop && s.length ? r.rewind ? o : Math.max(o, a) : 0; for (u /= 2; u-- > 0;)i.push(this.normalize(i.length / 2, !0)), l.push({ ...this.slidesData[i[i.length - 1]] }), i.push(this.normalize(s.length - 1 - (i.length - 1) / 2, !0)), c.unshift({ ...this.slidesData[i[i.length - 1]] }); this._clones = i, l = l.map(d => (d.id = `${this.clonedIdPrefix}${d.id}`, d.isActive = !1, d.isCloned = !0, d)), c = c.map(d => (d.id = `${this.clonedIdPrefix}${d.id}`, d.isActive = !1, d.isCloned = !0, d)), this.slidesData = c.concat(this.slidesData).concat(l) } }, { filter: ["width", "items", "settings"], run: () => { const i = this.settings.rtl ? 1 : -1, s = this._clones.length + this._items.length, r = []; let o = -1, a = 0, l = 0; for (; ++o < s;)a = r[o - 1] || 0, l = this._widths[this.relative(o)] + this.settings.margin, r.push(a + l * i); this._coordinates = r } }, { filter: ["width", "items", "settings"], run: () => { const i = this.settings.stagePadding, s = this._coordinates, r = { width: Math.ceil(Math.abs(s[s.length - 1])) + 2 * i, "padding-left": i || "", "padding-right": i || "" }; this.stageData.width = r.width, this.stageData.paddingL = r["padding-left"], this.stageData.paddingR = r["padding-right"] } }, { filter: ["width", "items", "settings"], run: i => { let s = i.current ? this.slidesData.findIndex(r => r.id === i.current) : 0; s = Math.max(this.minimum(), Math.min(this.maximum(), s)), this.reset(s) } }, { filter: ["position"], run: () => { this.animate(this.coordinates(this._current)) } }, { filter: ["width", "position", "items", "settings"], run: () => { const i = this.settings.rtl ? 1 : -1, s = 2 * this.settings.stagePadding, r = []; let o, a, l, c, u, d; if (o = this.coordinates(this.current()), "number" == typeof o ? o += s : o = 0, a = o + this.width() * i, -1 === i && this.settings.center) { const h = this._coordinates.filter(f => this.settings.items % 2 == 1 ? f >= o : f > o); o = h.length ? h[h.length - 1] : o } for (u = 0, d = this._coordinates.length; u < d; u++)l = Math.ceil(this._coordinates[u - 1] || 0), c = Math.ceil(Math.abs(this._coordinates[u]) + s * i), (this._op(l, "<=", o) && this._op(l, ">", a) || this._op(c, "<", o) && this._op(c, ">", a)) && r.push(u); this.slidesData.forEach(h => (h.isActive = !1, h)), r.forEach(h => { this.slidesData[h].isActive = !0 }), this.settings.center && (this.slidesData.forEach(h => (h.isCentered = !1, h)), this.slidesData[this.current()].isCentered = !0) } }] } get invalidated() { return this._invalidated } get states() { return this._states } getViewCurSettings() { return this._viewSettingsShipper$.asObservable() } getInitializedState() { return this._initializedCarousel$.asObservable() } getChangeState() { return this._changeSettingsCarousel$.asObservable() } getChangedState() { return this._changedSettingsCarousel$.asObservable() } getTranslateState() { return this._translateCarousel$.asObservable() } getTranslatedState() { return this._translatedCarousel$.asObservable() } getResizeState() { return this._resizeCarousel$.asObservable() } getResizedState() { return this._resizedCarousel$.asObservable() } getRefreshState() { return this._refreshCarousel$.asObservable() } getRefreshedState() { return this._refreshedCarousel$.asObservable() } getDragState() { return this._dragCarousel$.asObservable() } getDraggedState() { return this._draggedCarousel$.asObservable() } setOptions(e) { const i = new r6, s = this._validateOptions(e, i); this._options = { ...i, ...s } } _validateOptions(e, i) { const s = { ...e }, r = new o6, o = (a, l) => (this.logger.log(`options.${l} must be type of ${a}; ${l}=${e[l]} skipped to defaults: ${l}=${i[l]}`), i[l]); for (const a in s) if (s.hasOwnProperty(a)) if ("number" === r[a]) this._isNumeric(s[a]) ? (s[a] = +s[a], s[a] = "items" === a ? this._validateItems(s[a], s.skip_validateItems) : s[a]) : s[a] = o(r[a], a); else if ("boolean" === r[a] && "boolean" != typeof s[a]) s[a] = o(r[a], a); else if ("number|boolean" !== r[a] || this._isNumberOrBoolean(s[a])) if ("number|string" !== r[a] || this._isNumberOrString(s[a])) if ("string|boolean" !== r[a] || this._isStringOrBoolean(s[a])) { if ("string[]" === r[a]) if (Array.isArray(s[a])) { let l = !1; s[a].forEach(c => { l = "string" == typeof c }), l || (s[a] = o(r[a], a)) } else s[a] = o(r[a], a) } else s[a] = o(r[a], a); else s[a] = o(r[a], a); else s[a] = o(r[a], a); return s } _validateItems(e, i) { let s = e; return e > this._items.length ? i ? this.logger.log("The option 'items' in your options is bigger than the number of slides. The navigation got disabled") : (s = this._items.length, this.logger.log("The option 'items' in your options is bigger than the number of slides. This option is updated to the current number of slides and the navigation got disabled")) : e === this._items.length && (this.settings.dots || this.settings.nav) && this.logger.log("Option 'items' in your options is equal to the number of slides. So the navigation got disabled"), s } setCarouselWidth(e) { this._width = e } setup(e, i, s) { this.setCarouselWidth(e), this.setItems(i), this._defineSlidesData(), this.setOptions(s), this.settings = { ...this._options }, this.setOptionsForViewport(), this._trigger("change", { property: { name: "settings", value: this.settings } }), this.invalidate("settings"), this._trigger("changed", { property: { name: "settings", value: this.settings } }) } setOptionsForViewport() { const e = this._width, i = this._options.responsive; let s = -1; if (!Object.keys(i).length) return; if (!e) return void (this.settings.items = 1); for (const o in i) i.hasOwnProperty(o) && +o <= e && +o > s && (s = Number(o)); this.settings = { ...this._options, ...i[s], items: i[s] && i[s].items ? this._validateItems(i[s].items, this._options.skip_validateItems) : this._options.items }, delete this.settings.responsive, this.owlDOMData.isResponsive = !0, this.owlDOMData.isMouseDragable = this.settings.mouseDrag, this.owlDOMData.isTouchDragable = this.settings.touchDrag; const r = []; this._items.forEach(o => { r.push(this.settings.merge ? o.dataMerge : 1) }), this._mergers = r, this._breakpoint = s, this.invalidate("settings") } initialize(e) { this.enter("initializing"), this.owlDOMData.rtl = this.settings.rtl, this._mergers.length && (this._mergers = []), e.forEach(i => { this._mergers.push(this.settings.merge ? i.dataMerge : 1) }), this._clones = [], this.reset(this._isNumeric(this.settings.startPosition) ? +this.settings.startPosition : 0), this.invalidate("items"), this.refresh(), this.owlDOMData.isLoaded = !0, this.owlDOMData.isMouseDragable = this.settings.mouseDrag, this.owlDOMData.isTouchDragable = this.settings.touchDrag, this.sendChanges(), this.leave("initializing"), this._trigger("initialized") } sendChanges() { this._viewSettingsShipper$.next({ owlDOMData: this.owlDOMData, stageData: this.stageData, slidesData: this.slidesData, navData: this.navData, dotsData: this.dotsData }) } _optionsLogic() { this.settings.autoWidth && (this.settings.stagePadding = 0, this.settings.merge = !1) } update() { let e = 0; const i = this._pipe.length, s = o => this._invalidated[o], r = {}; for (; e < i;) { const o = this._pipe[e].filter.filter(s); (this._invalidated.all || o.length > 0) && this._pipe[e].run(r), e++ } this.slidesData.forEach(o => o.classes = this.setCurSlideClasses(o)), this.sendChanges(), this._invalidated = {}, this.is("valid") || this.enter("valid") } width(e) { switch (e = e || $r.Default) { case $r.Inner: case $r.Outer: return this._width; default: return this._width - 2 * this.settings.stagePadding + this.settings.margin } } refresh() { this.enter("refreshing"), this._trigger("refresh"), this._defineSlidesData(), this.setOptionsForViewport(), this._optionsLogic(), this.update(), this.leave("refreshing"), this._trigger("refreshed") } onResize(e) { if (!this._items.length) return !1; this.setCarouselWidth(e), this.enter("resizing"), this._trigger("resize"), this.invalidate("width"), this.refresh(), this.leave("resizing"), this._trigger("resized") } prepareDragging(e) { let s, i = null; return s = this.stageData.transform.replace(/.*\(|\)| |[^,-\d]\w|\)/g, "").split(","), i = { x: +s[0], y: +s[1] }, this.is("animating") && this.invalidate("position"), "mousedown" === e.type && (this.owlDOMData.isGrab = !0), this.speed(0), i } enterDragging() { this.enter("dragging"), this._trigger("drag") } defineNewCoordsDrag(e, i) { let s = null, r = null, o = null; const a = this.difference(i.pointer, this.pointer(e)), l = this.difference(i.stage.start, a); return !!this.is("dragging") && (this.settings.loop ? (s = this.coordinates(this.minimum()), r = +this.coordinates(this.maximum() + 1) - s, l.x = ((l.x - s) % r + r) % r + s) : (s = this.coordinates(this.settings.rtl ? this.maximum() : this.minimum()), r = this.coordinates(this.settings.rtl ? this.minimum() : this.maximum()), o = this.settings.pullDrag ? -1 * a.x / 5 : 0, l.x = Math.max(Math.min(l.x, s + o), r + o)), l) } finishDragging(e, i, s) { const o = this.difference(i.pointer, this.pointer(e)), a = i.stage.current, l = ["right", "left"][+(this.settings.rtl ? o.x < +this.settings.rtl : o.x > +this.settings.rtl)]; let c, u, d; (0 !== o.x && this.is("dragging") || !this.is("valid")) && (this.speed(+this.settings.dragEndSpeed || this.settings.smartSpeed), c = this.closest(a.x, 0 !== o.x ? l : i.direction), u = this.current(), d = this.current(-1 === c ? void 0 : c), u !== d && (this.invalidate("position"), this.update()), i.direction = l, (Math.abs(o.x) > 3 || (new Date).getTime() - i.time > 300) && s()), this.is("dragging") && (this.leave("dragging"), this._trigger("dragged")) } closest(e, i) { const r = this.width(); let o = this.coordinates(), a = -1; this.settings.center && (o = o.map(l => (0 === l && (l += 1e-6), l))); for (let l = 0; l < o.length && ("left" === i && e > o[l] - 30 && e < o[l] + 30 ? a = l : "right" === i && e > o[l] - r - 30 && e < o[l] - r + 30 ? a = l + 1 : this._op(e, "<", o[l]) && this._op(e, ">", o[l + 1] || o[l] - r) ? a = "left" === i ? l + 1 : l : null === i && e > o[l] - 30 && e < o[l] + 30 && (a = l), -1 === a); l++); return this.settings.loop || (this._op(e, ">", o[this.minimum()]) ? a = e = this.minimum() : this._op(e, "<", o[this.maximum()]) && (a = e = this.maximum())), a } animate(e) { const i = this.speed() > 0; this.is("animating") && this.onTransitionEnd(), i && (this.enter("animating"), this._trigger("translate")), this.stageData.transform = "translate3d(" + e + "px,0px,0px)", this.stageData.transition = this.speed() / 1e3 + "s" + (this.settings.slideTransition ? " " + this.settings.slideTransition : "") } is(e) { return this._states.current[e] && this._states.current[e] > 0 } current(e) { return void 0 === e ? this._current : 0 !== this._items.length ? (e = this.normalize(e), this._current !== e && (this._trigger("change", { property: { name: "position", value: e } }), this._current = e, this.invalidate("position"), this._trigger("changed", { property: { name: "position", value: this._current } })), this._current) : void 0 } invalidate(e) { return "string" == typeof e && (this._invalidated[e] = !0, this.is("valid") && this.leave("valid")), Object.keys(this._invalidated) } reset(e) { void 0 !== (e = this.normalize(e)) && (this._speed = 0, this._current = e, this._suppress(["translate", "translated"]), this.animate(this.coordinates(e)), this._release(["translate", "translated"])) } normalize(e, i) { const s = this._items.length, r = i ? 0 : this._clones.length; return !this._isNumeric(e) || s < 1 ? e = void 0 : (e < 0 || e >= s + r) && (e = ((e - r / 2) % s + s) % s + r / 2), e } relative(e) { return this.normalize(e -= this._clones.length / 2, !0) } maximum(e = !1) { const i = this.settings; let r, o, a, s = this._coordinates.length; if (i.loop) s = this._clones.length / 2 + this._items.length - 1; else if (i.autoWidth || i.merge) { for (r = this._items.length, o = this.slidesData[--r].width, a = this._width; r-- > 0 && (o += +this.slidesData[r].width + this.settings.margin, !(o > a));); s = r + 1 } else s = i.center ? this._items.length - 1 : this._items.length - i.items; return e && (s -= this._clones.length / 2), Math.max(s, 0) } minimum(e = !1) { return e ? 0 : this._clones.length / 2 } items(e) { return void 0 === e ? this._items.slice() : (e = this.normalize(e, !0), [this._items[e]]) } mergers(e) { return void 0 === e ? this._mergers.slice() : (e = this.normalize(e, !0), this._mergers[e]) } clones(e) { const i = this._clones.length / 2, s = i + this._items.length, r = o => o % 2 == 0 ? s + o / 2 : i - (o + 1) / 2; return void 0 === e ? this._clones.map((o, a) => r(a)) : this._clones.map((o, a) => o === e ? r(a) : null).filter(o => o) } speed(e) { return void 0 !== e && (this._speed = e), this._speed } coordinates(e) { let r, o, i = 1, s = e - 1; return void 0 === e ? (o = this._coordinates.map((a, l) => this.coordinates(l)), o) : (this.settings.center ? (this.settings.rtl && (i = -1, s = e + 1), r = this._coordinates[e], r += (this.width() - r + (this._coordinates[s] || 0)) / 2 * i) : r = this._coordinates[s] || 0, r = Math.ceil(r), r) } _duration(e, i, s) { return 0 === s ? 0 : Math.min(Math.max(Math.abs(i - e), 1), 6) * Math.abs(+s || this.settings.smartSpeed) } to(e, i) { let s = this.current(), r = null, o = e - this.relative(s), a = this.maximum(), l = 0; const c = +(o > 0) - +(o < 0), u = this._items.length, d = this.minimum(); this.settings.loop ? (!this.settings.rewind && Math.abs(o) > u / 2 && (o += -1 * c * u), r = (((e = s + o) - d) % u + u) % u + d, r !== e && r - o <= a && r - o > 0 && (s = r - o, e = r, l = 30, this.reset(s), this.sendChanges())) : this.settings.rewind ? (a += 1, e = (e % a + a) % a) : e = Math.max(d, Math.min(a, e)), setTimeout(() => { this.speed(this._duration(s, e, i)), this.current(e), this.update() }, l) } next(e) { e = e || !1, this.to(this.relative(this.current()) + 1, e) } prev(e) { e = e || !1, this.to(this.relative(this.current()) - 1, e) } onTransitionEnd(e) { if (void 0 !== e) return !1; this.leave("animating"), this._trigger("translated") } _viewport() { let e; return this._width ? e = this._width : this.logger.log("Can not detect viewport width."), e } setItems(e) { this._items = e } _defineSlidesData() { let e; this.slidesData && this.slidesData.length && (e = new Map, this.slidesData.forEach(i => { i.load && e.set(i.id, i.load) })), this.slidesData = this._items.map(i => ({ id: `${i.id}`, isActive: !1, tplRef: i.tplRef, dataMerge: i.dataMerge, width: 0, isCloned: !1, load: !!e && e.get(i.id), hashFragment: i.dataHash })) } setCurSlideClasses(e) { const i = { active: e.isActive, center: e.isCentered, cloned: e.isCloned, animated: e.isAnimated, "owl-animated-in": e.isDefAnimatedIn, "owl-animated-out": e.isDefAnimatedOut }; return this.settings.animateIn && (i[this.settings.animateIn] = e.isCustomAnimatedIn), this.settings.animateOut && (i[this.settings.animateOut] = e.isCustomAnimatedOut), i } _op(e, i, s) { const r = this.settings.rtl; switch (i) { case "<": return r ? e > s : e < s; case ">": return r ? e < s : e > s; case ">=": return r ? e <= s : e >= s; case "<=": return r ? e >= s : e <= s } } _trigger(e, i, s, r, o) { switch (e) { case "initialized": this._initializedCarousel$.next(e); break; case "change": this._changeSettingsCarousel$.next(i); break; case "changed": this._changedSettingsCarousel$.next(i); break; case "drag": this._dragCarousel$.next(e); break; case "dragged": this._draggedCarousel$.next(e); break; case "resize": this._resizeCarousel$.next(e); break; case "resized": this._resizedCarousel$.next(e); break; case "refresh": this._refreshCarousel$.next(e); break; case "refreshed": this._refreshedCarousel$.next(e); break; case "translate": this._translateCarousel$.next(e); break; case "translated": this._translatedCarousel$.next(e) } } enter(e) { [e].concat(this._states.tags[e] || []).forEach(i => { void 0 === this._states.current[i] && (this._states.current[i] = 0), this._states.current[i]++ }) } leave(e) { [e].concat(this._states.tags[e] || []).forEach(i => { (0 === this._states.current[i] || this._states.current[i]) && this._states.current[i]-- }) } register(e) { e.type === Du.State && (this._states.tags[e.name] = this._states.tags[e.name] ? this._states.tags[e.name].concat(e.tags) : e.tags, this._states.tags[e.name] = this._states.tags[e.name].filter((i, s) => this._states.tags[e.name].indexOf(i) === s)) } _suppress(e) { e.forEach(i => { this._supress[i] = !0 }) } _release(e) { e.forEach(i => { delete this._supress[i] }) } pointer(e) { const i = { x: null, y: null }; return (e = (e = e.originalEvent || e || window.event).touches && e.touches.length ? e.touches[0] : e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e).pageX ? (i.x = e.pageX, i.y = e.pageY) : (i.x = e.clientX, i.y = e.clientY), i } _isNumeric(e) { return !isNaN(parseFloat(e)) } _isNumberOrBoolean(e) { return this._isNumeric(e) || "boolean" == typeof e } _isNumberOrString(e) { return this._isNumeric(e) || "string" == typeof e } _isStringOrBoolean(e) { return "string" == typeof e || "boolean" == typeof e } difference(e, i) { return null === e || null === i ? { x: 0, y: 0 } : { x: e.x - i.x, y: e.y - i.y } } } return n.\u0275fac = function (e) { return new (e || n)(k(Rg)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), oC = (() => { class n { constructor(e) { this.carouselService = e, this._initialized = !1, this._pages = [], this._navData = { disabled: !1, prev: { disabled: !1, htmlText: "" }, next: { disabled: !1, htmlText: "" } }, this._dotsData = { disabled: !1, dots: [] }, this.spyDataStreams() } ngOnDestroy() { this.navSubscription.unsubscribe() } spyDataStreams() { const r = $n(this.carouselService.getInitializedState().pipe(se(o => { this.initialize(), this._updateNavPages(), this.draw(), this.update(), this.carouselService.sendChanges() })), this.carouselService.getChangedState().pipe(qt(o => "position" === o.property.name), se(o => { this.update() })), this.carouselService.getRefreshedState().pipe(se(() => { this._updateNavPages(), this.draw(), this.update(), this.carouselService.sendChanges() }))); this.navSubscription = r.subscribe(() => { }) } initialize() { this._navData.disabled = !0, this._navData.prev.htmlText = this.carouselService.settings.navText[0], this._navData.next.htmlText = this.carouselService.settings.navText[1], this._dotsData.disabled = !0, this.carouselService.navData = this._navData, this.carouselService.dotsData = this._dotsData } _updateNavPages() { let e, i, s; const r = this.carouselService.clones().length / 2, o = r + this.carouselService.items().length, a = this.carouselService.maximum(!0), l = [], c = this.carouselService.settings; let u = c.center || c.autoWidth || c.dotsData ? 1 : Math.floor(Number(c.dotsEach)) || Math.floor(c.items); if (u = +u, "page" !== c.slideBy && (c.slideBy = Math.min(+c.slideBy, c.items)), c.dots || "page" === c.slideBy) for (e = r, i = 0, s = 0; e < o; e++) { if (i >= u || 0 === i) { if (l.push({ start: Math.min(a, e - r), end: e - r + u - 1 }), Math.min(a, e - r) === a) break; i = 0, ++s } i += this.carouselService.mergers(this.carouselService.relative(e)) } this._pages = l } draw() { let e; const i = this.carouselService.settings, s = this.carouselService.items(), r = s.length <= i.items; if (this._navData.disabled = !i.nav || r, this._dotsData.disabled = !i.dots || r, i.dots) if (e = this._pages.length - this._dotsData.dots.length, i.dotsData && 0 !== e) this._dotsData.dots = [], s.forEach(o => { this._dotsData.dots.push({ active: !1, id: `dot-${o.id}`, innerContent: o.dotContent, showInnerContent: !0 }) }); else if (e > 0) { const o = this._dotsData.dots.length > 0 ? this._dotsData.dots.length : 0; for (let a = 0; a < e; a++)this._dotsData.dots.push({ active: !1, id: `dot-${a + o}`, innerContent: "", showInnerContent: !1 }) } else e < 0 && this._dotsData.dots.splice(e, Math.abs(e)); this.carouselService.navData = this._navData, this.carouselService.dotsData = this._dotsData } update() { this._updateNavButtons(), this._updateDots() } _updateNavButtons() { const e = this.carouselService.settings, i = e.loop || e.rewind, s = this.carouselService.relative(this.carouselService.current()); e.nav && (this._navData.prev.disabled = !i && s <= this.carouselService.minimum(!0), this._navData.next.disabled = !i && s >= this.carouselService.maximum(!0)), this.carouselService.navData = this._navData } _updateDots() { let e; !this.carouselService.settings.dots || (this._dotsData.dots.forEach(i => { !0 === i.active && (i.active = !1) }), e = this._current(), this._dotsData.dots.length && (this._dotsData.dots[e].active = !0), this.carouselService.dotsData = this._dotsData) } _current() { const e = this.carouselService.relative(this.carouselService.current()); let i; const s = this._pages.filter((r, o) => r.start <= e && r.end >= e).pop(); return i = this._pages.findIndex(r => r.start === s.start && r.end === s.end), i } _getPosition(e) { let i, s; const r = this.carouselService.settings; return "page" === r.slideBy ? (i = this._current(), s = this._pages.length, e ? ++i : --i, i = this._pages[(i % s + s) % s].start) : (i = this.carouselService.relative(this.carouselService.current()), s = this.carouselService.items().length, e ? i += +r.slideBy : i -= +r.slideBy), i } next(e) { this.carouselService.to(this._getPosition(!0), e) } prev(e) { this.carouselService.to(this._getPosition(!1), e) } to(e, i, s) { let r; !s && this._pages.length ? (r = this._pages.length, this.carouselService.to(this._pages[(e % r + r) % r].start, i)) : this.carouselService.to(e, i) } moveByDot(e) { const i = this._dotsData.dots.findIndex(s => e === s.id); this.to(i, this.carouselService.settings.dotsSpeed) } toSlideById(e) { const i = this.carouselService.slidesData.findIndex(s => s.id === e && !1 === s.isCloned); -1 === i || i === this.carouselService.current() || this.carouselService.to(this.carouselService.relative(i), !1) } } return n.\u0275fac = function (e) { return new (e || n)(k(Si)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(); const aC = new W("WindowToken"); class Og { get nativeWindow() { throw new Error("Not implemented.") } } const c6 = [{ provide: Og, useClass: (() => { class n extends Og { constructor() { super() } get nativeWindow() { return window } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })() }, { provide: aC, useFactory: function l6(n, t) { return hw(t) ? n.nativeWindow : { setTimeout: (i, s) => { }, clearTimeout: i => { } } }, deps: [Og, Uo] }], Lg = new W("DocumentToken"); class Fg { get nativeDocument() { throw new Error("Not implemented.") } } const h6 = [{ provide: Fg, useClass: (() => { class n extends Fg { constructor() { super() } get nativeDocument() { return document } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })() }, { provide: Lg, useFactory: function d6(n, t) { return hw(t) ? n.nativeDocument : { hidden: !1, visibilityState: "visible" } }, deps: [Fg, Uo] }]; let lC = (() => { class n { constructor(e, i, s, r) { this.carouselService = e, this.ngZone = r, this._timeout = null, this._paused = !1, this._isAutoplayStopped = !1, this.winRef = i, this.docRef = s, this.spyDataStreams() } get isAutoplayStopped() { return this._isAutoplayStopped } set isAutoplayStopped(e) { this._isAutoplayStopped = e } ngOnDestroy() { this.autoplaySubscription.unsubscribe() } spyDataStreams() { const r = $n(this.carouselService.getInitializedState().pipe(se(() => { this.carouselService.settings.autoplay && this.play() })), this.carouselService.getChangedState().pipe(se(o => { this._handleChangeObservable(o) })), this.carouselService.getResizedState().pipe(se(() => { this.carouselService.settings.autoplay && !this._isAutoplayStopped ? this.play() : this.stop() }))); this.autoplaySubscription = r.subscribe(() => { }) } play(e, i) { this._paused && (this._paused = !1, this._setAutoPlayInterval(this.carouselService.settings.autoplayMouseleaveTimeout)), !this.carouselService.is("rotating") && (this.carouselService.enter("rotating"), this._setAutoPlayInterval()) } _getNextTimeout(e, i) { return this._timeout && this.winRef.clearTimeout(this._timeout), this._isArtificialAutoplayTimeout = !!e, this.ngZone.runOutsideAngular(() => this.winRef.setTimeout(() => { this.ngZone.run(() => { this._paused || this.carouselService.is("busy") || this.carouselService.is("interacting") || this.docRef.hidden || this.carouselService.next(i || this.carouselService.settings.autoplaySpeed) }) }, e || this.carouselService.settings.autoplayTimeout)) } _setAutoPlayInterval(e) { this._timeout = this._getNextTimeout(e) } stop() { !this.carouselService.is("rotating") || (this._paused = !0, this.winRef.clearTimeout(this._timeout), this.carouselService.leave("rotating")) } pause() { !this.carouselService.is("rotating") || (this._paused = !0) } _handleChangeObservable(e) { "settings" === e.property.name ? this.carouselService.settings.autoplay ? this.play() : this.stop() : "position" === e.property.name && this.carouselService.settings.autoplay && this._setAutoPlayInterval() } _playAfterTranslated() { z("translated").pipe(Wt(e => this.carouselService.getTranslatedState()), ti(), qt(() => this._isArtificialAutoplayTimeout), se(() => this._setAutoPlayInterval())).subscribe(() => { }) } startPausing() { this.carouselService.settings.autoplayHoverPause && this.carouselService.is("rotating") && this.pause() } startPlayingMouseLeave() { this.carouselService.settings.autoplayHoverPause && this.carouselService.is("rotating") && (this.play(), this._playAfterTranslated()) } startPlayingTouchEnd() { this.carouselService.settings.autoplayHoverPause && this.carouselService.is("rotating") && (this.play(), this._playAfterTranslated()) } } return n.\u0275fac = function (e) { return new (e || n)(k(Si), k(aC), k(Lg), k(Ve)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), cC = (() => { class n { constructor(e) { this.carouselService = e, this.spyDataStreams() } ngOnDestroy() { this.lazyLoadSubscription.unsubscribe() } spyDataStreams() { const r = $n(this.carouselService.getInitializedState().pipe(se(() => { const o = this.carouselService.settings && !this.carouselService.settings.lazyLoad; this.carouselService.slidesData.forEach(a => a.load = !!o) })), this.carouselService.getChangeState(), this.carouselService.getResizedState()).pipe(se(o => this._defineLazyLoadSlides(o))); this.lazyLoadSubscription = r.subscribe(() => { }) } _defineLazyLoadSlides(e) { if (this.carouselService.settings && this.carouselService.settings.lazyLoad && (e.property && "position" === e.property.name || "initialized" === e || "resized" === e)) { const i = this.carouselService.settings, s = this.carouselService.clones().length; let r = i.center && Math.ceil(i.items / 2) || i.items, o = i.center && -1 * r || 0, a = (e.property && void 0 !== e.property.value ? e.property.value : this.carouselService.current()) + o; for (i.lazyLoadEager > 0 && (r += i.lazyLoadEager, i.loop && (a -= i.lazyLoadEager, r++)); o++ < r;)this._load(s / 2 + this.carouselService.relative(a)), s && this.carouselService.clones(this.carouselService.relative(a)).forEach(l => this._load(l)), a++ } } _load(e) { this.carouselService.slidesData[e].load || (this.carouselService.slidesData[e].load = !0) } } return n.\u0275fac = function (e) { return new (e || n)(k(Si)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), Ng = (() => { class n { constructor(e) { this.carouselService = e, this.swapping = !0, this.previous = void 0, this.next = void 0, this.spyDataStreams() } ngOnDestroy() { this.animateSubscription.unsubscribe() } spyDataStreams() { const e = this.carouselService.getChangeState().pipe(se(c => { "position" === c.property.name && (this.previous = this.carouselService.current(), this.next = c.property.value) })), o = $n(this.carouselService.getDragState(), this.carouselService.getDraggedState(), this.carouselService.getTranslatedState()).pipe(se(c => this.swapping = "translated" === c)), l = $n(e, this.carouselService.getTranslateState().pipe(se(c => { this.swapping && (this.carouselService._options.animateOut || this.carouselService._options.animateIn) && this._swap() })), o).pipe(); this.animateSubscription = l.subscribe(() => { }) } _swap() { if (1 !== this.carouselService.settings.items) return; let e; this.carouselService.speed(0); const i = this.carouselService.slidesData[this.previous], s = this.carouselService.slidesData[this.next], r = this.carouselService.settings.animateIn, o = this.carouselService.settings.animateOut; this.carouselService.current() !== this.previous && (o && (e = +this.carouselService.coordinates(this.previous) - +this.carouselService.coordinates(this.next), this.carouselService.slidesData.forEach(a => { a.id === i.id && (a.left = `${e}px`, a.isAnimated = !0, a.isDefAnimatedOut = !0, a.isCustomAnimatedOut = !0) })), r && this.carouselService.slidesData.forEach(a => { a.id === s.id && (a.isAnimated = !0, a.isDefAnimatedIn = !0, a.isCustomAnimatedIn = !0) })) } clear(e) { this.carouselService.slidesData.forEach(i => { i.id === e && (i.left = "", i.isAnimated = !1, i.isDefAnimatedOut = !1, i.isCustomAnimatedOut = !1, i.isDefAnimatedIn = !1, i.isCustomAnimatedIn = !1, i.classes = this.carouselService.setCurSlideClasses(i)) }), this.carouselService.onTransitionEnd() } } return n.\u0275fac = function (e) { return new (e || n)(k(Si)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), uC = (() => { class n { constructor(e) { this.carouselService = e, this.spyDataStreams() } ngOnDestroy() { this.autoHeightSubscription.unsubscribe() } spyDataStreams() { const r = $n(this.carouselService.getInitializedState().pipe(se(o => { this.carouselService.settings.autoHeight ? this.update() : this.carouselService.slidesData.forEach(a => a.heightState = "full") })), this.carouselService.getChangedState().pipe(se(o => { this.carouselService.settings.autoHeight && "position" === o.property.name && this.update() })), this.carouselService.getRefreshedState().pipe(se(o => { this.carouselService.settings.autoHeight && this.update() }))); this.autoHeightSubscription = r.subscribe(() => { }) } update() { const e = this.carouselService.settings.items; let i = this.carouselService.current(), s = i + e; this.carouselService.settings.center && (i = e % 2 == 1 ? i - (e - 1) / 2 : i - e / 2, s = e % 2 == 1 ? i + e : i + e + 1), this.carouselService.slidesData.forEach((r, o) => { r.heightState = o >= i && o < s ? "full" : "nulled" }) } } return n.\u0275fac = function (e) { return new (e || n)(k(Si)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), dC = (() => { class n { constructor(e, i, s) { this.carouselService = e, this.route = i, this.router = s, this.spyDataStreams(), this.route || (this.route = { fragment: z("no route").pipe(ln(1)) }), this.router || (this.router = { navigate: (r, o) => { } }) } ngOnDestroy() { this.hashSubscription.unsubscribe() } spyDataStreams() { const s = $n(this.carouselService.getInitializedState().pipe(se(() => this.listenToRoute())), this.carouselService.getChangedState().pipe(se(r => { if (this.carouselService.settings.URLhashListener && "position" === r.property.name) { const o = this.carouselService.current(), a = this.carouselService.slidesData[o].hashFragment; if (!a || a === this.currentHashFragment) return; this.router.navigate(["./"], { fragment: a, relativeTo: this.route }) } }))); this.hashSubscription = s.subscribe(() => { }) } rewind(e) { const i = this.carouselService.slidesData.findIndex(s => s.hashFragment === e && !1 === s.isCloned); -1 === i || i === this.carouselService.current() || this.carouselService.to(this.carouselService.relative(i), !1) } listenToRoute() { this.route.fragment.pipe(iC("URLHash" === this.carouselService.settings.startPosition ? 0 : 2)).subscribe(i => { this.currentHashFragment = i, this.rewind(i) }) } } return n.\u0275fac = function (e) { return new (e || n)(k(Si), k(Ls, 8), k(bt, 8)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), f6 = 0, jg = (() => { class n { constructor(e) { this.tplRef = e, this.id = "owl-slide-" + f6++, this._dataMerge = 1, this.width = 0, this.dotContent = "", this.dataHash = "" } set dataMerge(e) { this._dataMerge = this.isNumeric(e) ? e : 1 } get dataMerge() { return this._dataMerge } isNumeric(e) { return !isNaN(parseFloat(e)) } } return n.\u0275fac = function (e) { return new (e || n)(L(Jn)) }, n.\u0275dir = mt({ type: n, selectors: [["ng-template", "carouselSlide", ""]], inputs: { id: "id", dataMerge: "dataMerge", width: "width", dotContent: "dotContent", dataHash: "dataHash" } }), n })(), hC = (() => { class n { constructor(e) { this.eventManager = e, this.resizeSubject = new Ne, this.eventManager.addGlobalEventListener("window", "resize", this.onResize.bind(this)), this.eventManager.addGlobalEventListener("window", "onload", this.onLoaded.bind(this)) } get onResize$() { return this.resizeSubject.asObservable() } onResize(e) { this.resizeSubject.next(e.target) } onLoaded(e) { this.windowWidth = e.target } } return n.\u0275fac = function (e) { return new (e || n)(k(Xo)) }, n.\u0275prov = V({ token: n, factory: n.\u0275fac }), n })(), p6 = (() => { class n { constructor(e, i, s, r, o) { this.zone = e, this.el = i, this.renderer = s, this.carouselService = r, this.animateService = o, this._drag = { time: null, target: null, pointer: null, stage: { start: null, current: null }, direction: null, active: !1, moving: !1 }, this._oneDragMove$ = new Ne, this.preparePublicSlide = a => { const l = { ...a }; return delete l.tplRef, l }, this.bindOneMouseTouchMove = a => { this._oneMouseTouchMove(a) }, this.bindOnDragMove = a => { this._onDragMove(a) }, this.bindOnDragEnd = a => { this._onDragEnd(a) }, this._oneClickHandler = () => { this.listenerOneClick = this.renderer.listen(this._drag.target, "click", () => !1), this.listenerOneClick() } } onMouseDown(e) { this.owlDraggable.isMouseDragable && this._onDragStart(e) } onTouchStart(e) { if (e.targetTouches.length >= 2) return !1; this.owlDraggable.isTouchDragable && this._onDragStart(e) } onTouchCancel(e) { this._onDragEnd(e) } onDragStart() { if (this.owlDraggable.isMouseDragable) return !1 } onSelectStart() { if (this.owlDraggable.isMouseDragable) return !1 } ngOnInit() { this._oneMoveSubsription = this._oneDragMove$.pipe(ti()).subscribe(() => { this._sendChanges() }) } ngOnDestroy() { this._oneMoveSubsription.unsubscribe() } _onDragStart(e) { let i = null; 3 !== e.which && (i = this._prepareDragging(e), this._drag.time = (new Date).getTime(), this._drag.target = e.target, this._drag.stage.start = i, this._drag.stage.current = i, this._drag.pointer = this._pointer(e), this.listenerMouseUp = this.renderer.listen(document, "mouseup", this.bindOnDragEnd), this.listenerTouchEnd = this.renderer.listen(document, "touchend", this.bindOnDragEnd), this.zone.runOutsideAngular(() => { this.listenerOneMouseMove = this.renderer.listen(document, "mousemove", this.bindOneMouseTouchMove), this.listenerOneTouchMove = this.renderer.listen(document, "touchmove", this.bindOneMouseTouchMove) })) } _oneMouseTouchMove(e) { const i = this._difference(this._drag.pointer, this._pointer(e)); this.listenerATag && this.listenerATag(), !(Math.abs(i.x) < 3 && Math.abs(i.y) < 3 && this._is("valid")) && (Math.abs(i.x) < 3 && Math.abs(i.x) < Math.abs(i.y) && this._is("valid") || (this.listenerOneMouseMove(), this.listenerOneTouchMove(), this._drag.moving = !0, this.blockClickAnchorInDragging(e), this.listenerMouseMove = this.renderer.listen(document, "mousemove", this.bindOnDragMove), this.listenerTouchMove = this.renderer.listen(document, "touchmove", this.bindOnDragMove), e.preventDefault(), this._enterDragging(), this._oneDragMove$.next(e))) } blockClickAnchorInDragging(e) { let i = e.target; for (; i && !(i instanceof HTMLAnchorElement);)i = i.parentElement; i instanceof HTMLAnchorElement && (this.listenerATag = this.renderer.listen(i, "click", () => !1)) } _onDragMove(e) { let i; const s = this.carouselService.defineNewCoordsDrag(e, this._drag); !1 !== s && (i = s, e.preventDefault(), this._drag.stage.current = i, this._animate(i.x - this._drag.stage.start.x)) } _animate(e) { this.renderer.setStyle(this.el.nativeElement.children[0], "transform", `translate3d(${e}px,0px,0px`), this.renderer.setStyle(this.el.nativeElement.children[0], "transition", "0s") } _onDragEnd(e) { this.carouselService.owlDOMData.isGrab = !1, this.listenerOneMouseMove(), this.listenerOneTouchMove(), this._drag.moving && (this.renderer.setStyle(this.el.nativeElement.children[0], "transform", ""), this.renderer.setStyle(this.el.nativeElement.children[0], "transition", this.carouselService.speed(+this.carouselService.settings.dragEndSpeed || this.carouselService.settings.smartSpeed) / 1e3 + "s"), this._finishDragging(e), this.listenerMouseMove(), this.listenerTouchMove()), this._drag = { time: null, target: null, pointer: null, stage: { start: null, current: null }, direction: null, active: !1, moving: !1 }, this.listenerMouseUp(), this.listenerTouchEnd() } _prepareDragging(e) { return this.carouselService.prepareDragging(e) } _finishDragging(e) { this.carouselService.finishDragging(e, this._drag, this._oneClickHandler) } _pointer(e) { return this.carouselService.pointer(e) } _difference(e, i) { return this.carouselService.difference(e, i) } _is(e) { return this.carouselService.is(e) } _enter(e) { this.carouselService.enter(e) } _sendChanges() { this.carouselService.sendChanges() } onTransitionEnd() { this.carouselService.onTransitionEnd() } _enterDragging() { this.carouselService.enterDragging() } clear(e) { this.animateService.clear(e) } } return n.\u0275fac = function (e) { return new (e || n)(L(Ve), L(Xn), L(No), L(Si), L(Ng)) }, n.\u0275cmp = Un({ type: n, selectors: [["owl-stage"]], hostBindings: function (e, i) { 1 & e && Pe("mousedown", function (r) { return i.onMouseDown(r) })("touchstart", function (r) { return i.onTouchStart(r) })("touchcancel", function (r) { return i.onTouchCancel(r) })("dragstart", function () { return i.onDragStart() })("selectstart", function () { return i.onSelectStart() }) }, inputs: { owlDraggable: "owlDraggable", stageData: "stageData", slidesData: "slidesData" }, decls: 3, vars: 8, consts: [[1, "owl-stage", 3, "ngStyle", "transitionend"], [4, "ngFor", "ngForOf"], [1, "owl-item", 3, "ngClass", "ngStyle", "animationend"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function (e, i) { 1 & e && (_(0, "div")(1, "div", 0), Pe("transitionend", function () { return i.onTransitionEnd() }), jt(2, Y8, 3, 9, "ng-container", 1), w()()), 2 & e && (M(1), De("ngStyle", Cf(2, X8, i.stageData.width + "px", i.stageData.transform, i.stageData.transition, i.stageData.paddingL ? i.stageData.paddingL + "px" : "", i.stageData.paddingR ? i.stageData.paddingR + "px" : "")), M(1), De("ngForOf", i.slidesData)) }, dependencies: [lp, Zo, Sc, cw, lw], encapsulation: 2, data: { animation: [W4("autoHeight", [Nw("nulled", kc({ height: 0 })), Nw("full", kc({ height: "*" })), jw("full => nulled", [Lw("700ms 350ms")]), jw("nulled => full", [Lw(350)])])] } }), n })(), fC = (() => { class n { constructor(e, i, s, r, o, a, l, c, u, d, h, f) { this.el = e, this.resizeService = i, this.carouselService = s, this.navigationService = r, this.autoplayService = o, this.lazyLoadService = a, this.animateService = l, this.autoHeightService = c, this.hashService = u, this.logger = d, this.changeDetectorRef = h, this.translated = new Re, this.dragging = new Re, this.change = new Re, this.changed = new Re, this.initialized = new Re, this.slidesData = [], this.carouselLoaded = !1, this.docRef = f } onVisibilityChange(e) { if (this.carouselService.settings.autoplay) switch (this.docRef.visibilityState) { case "visible": !this.autoplayService.isAutoplayStopped && this.autoplayService.play(); break; case "hidden": this.autoplayService.pause() } } ngOnInit() { this.spyDataStreams(), this.carouselWindowWidth = this.el.nativeElement.querySelector(".owl-carousel").clientWidth } ngOnChanges() { this.prevOptions !== this.options && (this.prevOptions && this.slides?.toArray().length ? (this.carouselService.setup(this.carouselWindowWidth, this.slides.toArray(), this.options), this.carouselService.initialize(this.slides.toArray())) : (this.carouselLoaded = !1, this.logger.log("There are no slides to show. So the carousel won't be re-rendered")), this.prevOptions = this.options) } ngAfterContentInit() { this.slides.toArray().length ? (this.carouselService.setup(this.carouselWindowWidth, this.slides.toArray(), this.options), this.carouselService.initialize(this.slides.toArray()), this._winResizeWatcher()) : this.logger.log("There are no slides to show. So the carousel won't be rendered"), this._slidesChangesSubscription = this.slides.changes.pipe(se(e => { e.toArray().length ? (this.carouselService.setup(this.carouselWindowWidth, e.toArray(), this.options), this.carouselService.initialize(e.toArray())) : (this.carouselLoaded = !1, this.logger.log("There are no slides to show. So the carousel won't be re-rendered")) })).subscribe(() => { }) } ngOnDestroy() { this.resizeSubscription && this.resizeSubscription.unsubscribe(), this._slidesChangesSubscription && this._slidesChangesSubscription.unsubscribe(), this._allObservSubscription && this._allObservSubscription.unsubscribe() } spyDataStreams() { this._viewCurSettings$ = this.carouselService.getViewCurSettings().pipe(se(e => { this.owlDOMData = e.owlDOMData, this.stageData = e.stageData, this.slidesData = e.slidesData, this.carouselLoaded || (this.carouselLoaded = !0), this.navData = e.navData, this.dotsData = e.dotsData, this.changeDetectorRef.markForCheck() })), this._initializedCarousel$ = this.carouselService.getInitializedState().pipe(se(() => { this.gatherTranslatedData(), this.initialized.emit(this.slidesOutputData) })), this._translatedCarousel$ = this.carouselService.getTranslatedState().pipe(se(() => { this.gatherTranslatedData(), this.translated.emit(this.slidesOutputData) })), this._changeCarousel$ = this.carouselService.getChangeState().pipe(se(() => { this.gatherTranslatedData(), this.change.emit(this.slidesOutputData) })), this._changedCarousel$ = this.carouselService.getChangeState().pipe(Wt(e => $n(z(e).pipe(qt(() => "position" === e.property.name), Wt(() => ft(this.slidesData)), iC(e.property.value), ln(this.carouselService.settings.items), he(s => { const r = this.carouselService.clonedIdPrefix, o = s.id.indexOf(r) >= 0 ? s.id.slice(r.length) : s.id; return { ...s, id: o, isActive: !0 } }), function j8() { return Ye((n, t) => { (function F8(n, t) { return Ye(ND(n, t, arguments.length >= 2, !1, !0)) })(N8, [])(n).subscribe(t) }) }(), he(s => ({ slides: s, startPosition: this.carouselService.relative(e.property.value) }))))), se(e => { this.gatherTranslatedData(), this.changed.emit(e.slides.length ? e : this.slidesOutputData) })), this._draggingCarousel$ = this.carouselService.getDragState().pipe(se(() => { this.gatherTranslatedData(), this.dragging.emit({ dragging: !0, data: this.slidesOutputData }) }), Wt(() => this.carouselService.getDraggedState().pipe(he(() => !!this.carouselService.is("animating")))), Wt(e => e ? this.carouselService.getTranslatedState().pipe(ti()) : z("not animating")), se(() => { this.dragging.emit({ dragging: !1, data: this.slidesOutputData }) })), this._carouselMerge$ = $n(this._viewCurSettings$, this._translatedCarousel$, this._draggingCarousel$, this._changeCarousel$, this._changedCarousel$, this._initializedCarousel$), this._allObservSubscription = this._carouselMerge$.subscribe(() => { }) } _winResizeWatcher() { Object.keys(this.carouselService._options.responsive).length && (this.resizeSubscription = this.resizeService.onResize$.pipe(qt(() => this.carouselWindowWidth !== this.el.nativeElement.querySelector(".owl-carousel").clientWidth), function q8(n, t = sC) { const e = function W8(n = 0, t, e = $8) { let i = -1; return null != t && (Wm(t) ? e = t : i = t), new $e(s => { let r = function U8(n) { return n instanceof Date && !isNaN(n) }(n) ? +n - e.now() : n; r < 0 && (r = 0); let o = 0; return e.schedule(function () { s.closed || (s.next(o++), 0 <= i ? this.schedule(void 0, i) : s.complete()) }, r) }) }(n, t); return rC(() => e) }(this.carouselService.settings.responsiveRefreshRate)).subscribe(() => { this.carouselService.onResize(this.el.nativeElement.querySelector(".owl-carousel").clientWidth), this.carouselWindowWidth = this.el.nativeElement.querySelector(".owl-carousel").clientWidth })) } onTransitionEnd() { this.carouselService.onTransitionEnd() } next() { !this.carouselLoaded || this.navigationService.next(this.carouselService.settings.navSpeed) } prev() { !this.carouselLoaded || this.navigationService.prev(this.carouselService.settings.navSpeed) } moveByDot(e) { !this.carouselLoaded || this.navigationService.moveByDot(e) } to(e) { !this.carouselLoaded || this.navigationService.toSlideById(e) } gatherTranslatedData() { let e; const i = this.carouselService.clonedIdPrefix, s = this.slidesData.filter(r => !0 === r.isActive).map(r => ({ id: r.id.indexOf(i) >= 0 ? r.id.slice(i.length) : r.id, width: r.width, marginL: r.marginL, marginR: r.marginR, center: r.isCentered })); e = this.carouselService.relative(this.carouselService.current()), this.slidesOutputData = { startPosition: e, slides: s } } startPausing() { this.autoplayService.startPausing() } startPlayML() { this.autoplayService.startPlayingMouseLeave() } startPlayTE() { this.autoplayService.startPlayingTouchEnd() } stopAutoplay() { this.autoplayService.isAutoplayStopped = !0, this.autoplayService.stop() } startAutoplay() { this.autoplayService.isAutoplayStopped = !1, this.autoplayService.play() } } return n.\u0275fac = function (e) { return new (e || n)(L(Xn), L(hC), L(Si), L(oC), L(lC), L(cC), L(Ng), L(uC), L(dC), L(Rg), L(qo), L(Lg)) }, n.\u0275cmp = Un({ type: n, selectors: [["owl-carousel-o"]], contentQueries: function (e, i, s) { if (1 & e && ic(s, jg, 4), 2 & e) { let r; nc(r = function sc() { return function PP(n, t) { return n[19].queries[t].queryList }(E(), yy()) }()) && (i.slides = r) } }, hostBindings: function (e, i) { 1 & e && Pe("visibilitychange", function (r) { return i.onVisibilityChange(r) }, 0, mv) }, inputs: { options: "options" }, outputs: { translated: "translated", dragging: "dragging", change: "change", changed: "changed", initialized: "initialized" }, features: [D1([oC, lC, Si, cC, Ng, uC, dC]), Li], decls: 4, vars: 9, consts: [[1, "owl-carousel", "owl-theme", 3, "ngClass", "mouseover", "mouseleave", "touchstart", "touchend"], ["owlCarousel", ""], ["class", "owl-stage-outer", 4, "ngIf"], [4, "ngIf"], [1, "owl-stage-outer"], [3, "owlDraggable", "stageData", "slidesData"], [1, "owl-nav", 3, "ngClass"], [1, "owl-prev", 3, "ngClass", "innerHTML", "click"], [1, "owl-next", 3, "ngClass", "innerHTML", "click"], [1, "owl-dots", 3, "ngClass"], ["class", "owl-dot", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], [1, "owl-dot", 3, "ngClass", "click"], [3, "innerHTML"]], template: function (e, i) { 1 & e && (_(0, "div", 0, 1), Pe("mouseover", function () { return i.startPausing() })("mouseleave", function () { return i.startPlayML() })("touchstart", function () { return i.startPausing() })("touchend", function () { return i.startPlayTE() }), jt(2, e6, 2, 6, "div", 2), jt(3, i6, 6, 15, "ng-container", 3), w()), 2 & e && (De("ngClass", Cf(3, s6, null == i.owlDOMData ? null : i.owlDOMData.rtl, null == i.owlDOMData ? null : i.owlDOMData.isLoaded, null == i.owlDOMData ? null : i.owlDOMData.isResponsive, null == i.owlDOMData ? null : i.owlDOMData.isMouseDragable, null == i.owlDOMData ? null : i.owlDOMData.isGrab)), M(2), De("ngIf", i.carouselLoaded), M(1), De("ngIf", i.slides.toArray().length)) }, dependencies: [lp, Zo, Sc, p6], styles: [".owl-theme[_ngcontent-%COMP%]{display:block}"], changeDetection: 0 }), n })(), g6 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({ providers: [c6, hC, h6, Rg], imports: [fp] }), n })(), m6 = (() => { class n { constructor() { } ngOnInit() { } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = Un({ type: n, selectors: [["app-not-found"]], decls: 143, vars: 3, consts: [[1, "flex", "item-center", "justify-center"], [1, "w-5/12"], ["id", "freepik_stories-404-error", "xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "viewBox", "0 0 500 500", "version", "1.1", 0, "xmlns", "svgjs", "http://svgjs.com/svgjs", 1, "animated"], ["id", "freepik--background-simple--inject-39", 1, "animable", 2, "transform-origin", "247.503px 244.785px"], ["d", "M44.31,258.15s2.35,73,63.27,121.6,145.32,52.12,213.65,56.74S442,402.43,450,344s-44.3-75.63-72.63-142.2-25.81-88.44-85.75-129.38S137.86,56.57,88.7,126.71,44.31,258.15,44.31,258.15Z", "id", "elbenw2jzlsfb", 1, "animable", 2, "fill", "#407BFF", "transform-origin", "247.503px 244.785px"], ["id", "elrof624krgij"], ["d", "M44.31,258.15s2.35,73,63.27,121.6,145.32,52.12,213.65,56.74S442,402.43,450,344s-44.3-75.63-72.63-142.2-25.81-88.44-85.75-129.38S137.86,56.57,88.7,126.71,44.31,258.15,44.31,258.15Z", "id", "el57b0j5hubnm", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "opacity", "0.7", "transform-origin", "247.503px 244.785px"], ["id", "freepik--Hole--inject-39", 1, "animable", 2, "transform-origin", "341.485px 385.785px"], ["cx", "341.49", "cy", "385.79", "rx", "72.2", "ry", "21.42", "id", "elfank3nufd3v", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "341.49px 385.79px"], ["d", "M341.49,374.22c34.15,0,62.75,7,70.26,16.49a8,8,0,0,0,1.94-4.92c0-11.84-32.33-21.43-72.2-21.43s-72.21,9.59-72.21,21.43a8,8,0,0,0,1.94,4.92C278.73,381.26,307.33,374.22,341.49,374.22Z", "id", "el0602pehnbpew", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "341.485px 377.535px"], ["d", "M331.63,404.52c-24.12-1.09-42.32-6-42.32-12a3.33,3.33,0,0,1,.59-1.83", "id", "elwd6j35xu4x", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "310.47px 397.605px"], ["d", "M387.6,386.68c4.13,1.75,6.49,3.75,6.49,5.88,0,6.73-23.46,12.18-52.39,12.18h-1.25", "id", "elmwnyhp35cja", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "367.27px 395.71px"], ["d", "M296.36,386.45c9.07-3.63,26-6.08,45.34-6.08a184.43,184.43,0,0,1,32.84,2.69", "id", "elc7smvird50u", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "335.45px 383.407px"], ["d", "M330.94,396.74c-6.11-.85-10.2-2.4-10.2-4.18,0-2.69,9.39-4.87,21-4.87s20.95,2.18,20.95,4.87c0,2.31-6.9,4.24-16.16,4.74", "id", "elj76xu08rxv", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "341.715px 392.495px"], ["id", "freepik--Landscape--inject-39", 1, "animable", 2, "transform-origin", "245.315px 277.033px"], ["d", "M51.52,299.68c31.49-8.95,97.75-26.61,134.32-27.94C235,270,318,305.68,369.82,311.93s86.64,4.47,86.64,4.47", "id", "elvcyb0umj0xg", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "253.99px 294.156px"], ["d", "M34,304.79s2.72-.83,7.49-2.22", "id", "elloyyxfs92y", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "37.745px 303.68px"], ["d", "M442.47,249.12a228.34,228.34,0,0,0-55.3-5.23c-38.42,1.29-80,6.37-131.41,13s-124.62-30-174.4-16.41-46,17.68-46,17.68", "id", "eljnz5mplmwig", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "238.882px 247.795px"], ["d", "M456.63,252.8s-1.94-.64-5.45-1.57", "id", "el2i1y193wt1v", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "453.905px 252.015px"], ["id", "freepik--Clouds--inject-39", 1, "animable", 2, "transform-origin", "320.68px 155.815px"], ["d", "M364.45,158.35a10.35,10.35,0,0,0-20.1,0Z", "id", "elath0vdjd25p", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "354.4px 154.412px"], ["d", "M466,158.35a12.81,12.81,0,0,0-11-9.77A30,30,0,0,0,425.42,113a30.08,30.08,0,0,0-29.61,24.79,19.22,19.22,0,0,0-31.06,15.16,19.41,19.41,0,0,0,.79,5.42Z", "id", "elna6msigw37", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "415.375px 135.685px"], ["d", "M185.57,182.49a5.25,5.25,0,0,0-10.21,0Z", "id", "el9mv45nx8xd9", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "180.465px 180.478px"], ["d", "M237.12,182.49a6.52,6.52,0,0,0-5.59-5,15.27,15.27,0,1,0-30-5.48,9.76,9.76,0,0,0-15.77,7.69,10.06,10.06,0,0,0,.4,2.76Z", "id", "elahbwae7ba6g", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "211.44px 170.584px"], ["d", "M231.93,198.63a3.31,3.31,0,0,0-6.44,0Z", "id", "el23x0yywrysak", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "228.71px 197.358px"], ["d", "M264.47,198.63a4.1,4.1,0,0,0-3.53-3.13,9.48,9.48,0,0,0,.16-1.77A9.64,9.64,0,0,0,242,192a6.16,6.16,0,0,0-9.95,4.86,6.25,6.25,0,0,0,.25,1.74Z", "id", "elr8mib8oqh1", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "248.26px 191.42px"], ["id", "freepik--Character--inject-39", 1, "animable", 2, "transform-origin", "237.675px 286.678px"], ["d", "M162.65,313.83a1.89,1.89,0,0,1-1-.27,2,2,0,0,1-.7-2.67c.49-.86,124.13-135.69,180.7-185.13a1,1,0,0,1,1.36.1,1,1,0,0,1-.1,1.38C286.62,176.47,164.81,312,164.32,312.85A1.92,1.92,0,0,1,162.65,313.83Z", "id", "el9oet6wq24cv", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "251.97px 219.685px"], ["d", "M169.48,287s6.13-6.54,9.81-6.54,10.63,6.13,10.22,9.4-6.54.41-6.54.41-5.73,7.77-11.45,6.54S169.48,287,169.48,287Z", "id", "el1yl6orjiaufj", 1, "animable", 2, "fill", "#407BFF", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "178.921px 288.701px"], ["d", "M183,290.25s3.75,2.6,4.08,4.43-4.16,7-9.15,8.16-7.66-1.67-6.16-4.33S179.22,290.49,183,290.25Z", "id", "eloxfklhcg4e", 1, "animable", 2, "fill", "#407BFF", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "179.225px 296.679px"], ["d", "M337,266.56V131.27s-2.73,9.79-2.73,10.5", "id", "el2lgexz4zrpd", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "335.635px 198.915px"], ["x", "289.68", "y", "273.69", "width", "103.74", "height", "83.12", "id", "eloqichr9kqtj", 1, "animable", 2, "fill", "#407BFF", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "341.55px 315.25px"], ["d", "M338.48,273.34v-4.76a1.19,1.19,0,0,0-2.38,0v4.76Z", "id", "elk7f1xdb8qxg", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "337.29px 270.365px"], ["d", "M348,261.76l0,.24a1.15,1.15,0,0,0-1-.61,1.2,1.2,0,0,0-1.2,1.2V275.3a3.67,3.67,0,0,1-3.66,3.67,3.57,3.57,0,0,1-1.46-.31,2,2,0,0,0,.3,2.58,6.34,6.34,0,0,0,1.16.11,6.05,6.05,0,0,0,6.05-6.05v-5.89h2.74Z", "id", "elzasg4dg6qkq", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "345.635px 271.37px"], ["d", "M337.1,130s2.12-7.53.24-6.83S337.1,130,337.1,130Z", "id", "eldmn1ec6lpdo", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "337.277px 126.562px"], ["d", "M337.1,130s-8-2.83-7.29-.24S337.1,130,337.1,130Z", "id", "ell7ebag4e4mi", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "333.433px 129.822px"], ["d", "M164.59,195.63s-9.87-5.53-29.23-2.76-23.05,18.73-19.89,35.32,21.47,30.64,24.24,29.46-.79-38.32,5.53-45.43,26.86-5.92,28-11.45S164.59,195.63,164.59,195.63Z", "id", "elv3mm84y7hp", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "143.899px 224.906px"], ["d", "M130.18,205.48l2,13.07s-12.4,33.85-10.39,38.55,20.77,6.36,20.77,6.36,30.5,3.69,39.55,0,4.36-14.41,3.35-17.42-6.7-27.15-6.7-27.15,2-5.7,2-8.71-.34-11.4-1.68-13.41-24.8-4.36-35.19-2.68S128.84,198.45,130.18,205.48Z", "id", "elbu6n6vfjf2f", 1, "animable", 2, "fill", "rgb(117, 117, 117)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "154.572px 229.308px"], ["d", "M135.55,220.57s-.34,29.15,1.34,34.85,8.38,12.4,22.45,10.72,15.42-15.08,15.42-15.08l-1-31.16Z", "id", "elbpvxgd8vcia", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "155.141px 243.151px"], ["d", "M159.68,241.51a2.52,2.52,0,1,1-2.52-2.51A2.51,2.51,0,0,1,159.68,241.51Z", "id", "elrtq074qpy7", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-miterlimit", "10", "stroke-width", "1.193px", "transform-origin", "157.16px 241.52px"], ["d", "M159.34,252.07a1.68,1.68,0,1,1-1.67-1.68A1.67,1.67,0,0,1,159.34,252.07Z", "id", "el40b51rl8wad", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "157.66px 252.07px"], ["d", "M149.22,230.76c1.07,1.16,1.44,2.55.84,3.12s-2,.09-3.05-1.06-1.45-2.54-.84-3.11S148.15,229.61,149.22,230.76Z", "id", "elvgu5pfam0e8", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "148.115px 231.794px"], ["d", "M162.83,230.76c-1.07,1.16-1.45,2.55-.84,3.12s2,.09,3-1.06,1.45-2.54.84-3.11S163.9,229.61,162.83,230.76Z", "id", "elk08g1pln65i", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "163.903px 231.794px"], ["d", "M142.06,226.81a6.4,6.4,0,0,1,7-2.58", "id", "elz96qxvnxmsa", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "145.56px 225.405px"], ["d", "M162.3,224.6s4.78-1.47,6.26,2.58", "id", "el6542hc9wuij", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "165.43px 225.76px"], ["d", "M178.44,411.62s5.27-3.16,8.19-4.4a8,8,0,0,1,.84-.33c2.58-.86,9.89-.43,16.76-4.73s3.44-9.46-1.72-10.75-10.74-3-10.74-3l-1.29-20.21s-15.48,4.3-20.64,6.45-2.15,32.67-1.72,35.25S168.55,414.2,178.44,411.62Z", "id", "el7oaefukauzn", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "187.468px 390.548px"], ["d", "M195.64,402.16c-9,1.72-9,3.44-18.92,5.16a38.38,38.38,0,0,1-8.83.72c.1.92.18,1.57.23,1.86.43,2.58.43,4.3,10.32,1.72,0,0,5.27-3.16,8.19-4.4a8,8,0,0,1,.84-.33c2.58-.86,9.89-.43,16.76-4.73,2.21-1.37,3.34-2.84,3.71-4.24A51.56,51.56,0,0,1,195.64,402.16Z", "id", "elr9qggyok5p", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "187.915px 405.408px"], ["d", "M199.22,391.15s-.33,23.46-1,28.48.33,11.4,8,11.4,22.79-5,28.15-6,14.08-3.36,17.76-11.73-18.76-7.38-18.76-7.38l1.34-17.09S211.62,393.49,199.22,391.15Z", "id", "el61bzb7zdrvj", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "225.292px 409.93px"], ["d", "M252.17,413.27a3.74,3.74,0,0,0,.28-2.63,21,21,0,0,1-9,7c-8,3.35-23.13,7-34.52,8.72-5.21.76-8.51-.09-10.58-1.23.74,3.25,2.91,5.92,7.9,5.92,7.71,0,22.79-5,28.15-6S248.49,421.64,252.17,413.27Z", "id", "elu2jd0ww0h6n", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "225.461px 420.845px"], ["d", "M233.41,405.89s1.67,5.7-3,9.39", "id", "elkhb5u06g759", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "232.055px 410.585px"], ["d", "M196.88,378.75s-.52,10.19.05,12.23c2.14,7.74,2.82,5.93,18.91,5.59s22.59-6.76,24.27-10.78,0-12.74-.67-15.76-6-4-8.05-3.68S197.88,375.4,196.88,378.75Z", "id", "elcfsiz0pq4ja", 1, "animable", 2, "fill", "rgb(117, 117, 117)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "218.749px 381.644px"], ["d", "M86.28,404.22v22.52A4.84,4.84,0,0,0,88.9,431l36.2,18.69a4.81,4.81,0,0,0,4.19.12l53.33-20.33a4.84,4.84,0,0,0,2.86-4.41V397.85l-61,18.43Z", "id", "elz2p95xhs31", 1, "animable", 2, "fill", "#407BFF", "transform-origin", "135.88px 424.041px"], ["id", "el2i7izz55erp", 1, "animable", 2, "clip-path", 'url("#freepik--clip-path--inject-39")', "transform-origin", "106.725px 427.225px"], ["id", "el10000c8n45gj"], ["d", "M127.17,415.47l-2.68.81L86.28,404.22v22.52A4.84,4.84,0,0,0,88.9,431l36.2,18.69a4.76,4.76,0,0,0,2.07.54Z", "id", "elwm8xuxf0jo", 1, "animable", 2, "opacity", "0.18", "transform-origin", "106.725px 427.225px"], ["d", "M86.28,404.22v22.52A4.84,4.84,0,0,0,88.9,431l36.2,18.69a4.81,4.81,0,0,0,4.19.12l53.33-20.33a4.84,4.84,0,0,0,2.86-4.41V397.85l-61,18.43Z", "id", "eldgojbvy2f0r", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "135.88px 424.041px"], ["d", "M142,366.2,83.5,385a2.26,2.26,0,0,0-1.57,2.16v16.68a2.27,2.27,0,0,0,1.29,2L124,425.25a2.27,2.27,0,0,0,1.77.08L187,402.42a2.27,2.27,0,0,0,1.48-2.12l.11-15.65a2.29,2.29,0,0,0-1.79-2.22l-43.64-16.29A2.36,2.36,0,0,0,142,366.2Z", "id", "el60mebyhjr4f", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "transform-origin", "135.26px 395.783px"], ["id", "elojaep73lfu", 1, "animable", 2, "clip-path", 'url("#freepik--clip-path-2--inject-39")', "transform-origin", "135.26px 404.335px"], ["d", "M123.93,425.24h0a2.27,2.27,0,0,0,1.77.08L187,402.42a2.27,2.27,0,0,0,1.48-2.12l.11-15.65a2.2,2.2,0,0,0-.54-1.45l-63.25,23.36Z", "id", "elax5ffq33atl", 1, "animable", 2, "fill", "#407BFF", "transform-origin", "156.26px 404.331px"], ["id", "elu46f7smkx4r"], ["d", "M123.93,425.24h0a2.27,2.27,0,0,0,1.77.08L187,402.42a2.27,2.27,0,0,0,1.48-2.12l.11-15.65a2.2,2.2,0,0,0-.54-1.45l-63.25,23.36Z", "id", "elb1xq1vey2cu", 1, "animable", 2, "fill", "rgb(255, 255, 255)", "opacity", "0.5", "transform-origin", "156.26px 404.331px"], ["d", "M81.93,387.11v16.68a2.27,2.27,0,0,0,1.29,2L124,425.25a2.24,2.24,0,0,0,.87.22V406.56L82,386.72A1.67,1.67,0,0,0,81.93,387.11Z", "id", "elkqtg91x4cw9", 1, "animable", 2, "fill", "#407BFF", "transform-origin", "103.4px 406.095px"], ["d", "M142,366.2,83.5,385a2.26,2.26,0,0,0-1.57,2.16v16.68a2.27,2.27,0,0,0,1.29,2L124,425.25a2.27,2.27,0,0,0,1.77.08L187,402.42a2.27,2.27,0,0,0,1.48-2.12l.11-15.65a2.29,2.29,0,0,0-1.79-2.22l-43.64-16.29A2.36,2.36,0,0,0,142,366.2Z", "id", "elk4y0fi526z", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "135.26px 395.783px"], ["d", "M222.35,335.52s7.7,3.68,11.73,11.06,1,21.44-1.35,25.8-18.09,6.37-23.45,6.37-6.37-.67-6.37-.67-17.09,3.35-27.82,5.36-8-23.12-4.69-34.52,22.12-17.09,29.83-17.09S222.35,335.52,222.35,335.52Z", "id", "el86wzbfsbjg", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "201.751px 357.692px"], ["d", "M202.91,378.08s14.41-5,20.44-17.76", "id", "el14fjftqoilq", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "213.13px 369.2px"], ["d", "M216.65,370.7a38.27,38.27,0,0,0,12.4-8.37", "id", "elbfpa2y6sjmc", 1, "animable", 2, "fill", "none", "stroke", "rgb(255, 255, 255)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "222.85px 366.515px"], ["d", "M182.8,346.58s4,21.11,2,29.82-13.74,10.06-16.42,9.05-1.34-21.78-1.34-32.17S177.44,343.56,182.8,346.58Z", "id", "elvkrs6z80otf", 1, "animable", 2, "fill", "rgb(117, 117, 117)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "176.033px 365.185px"], ["d", "M97.34,290.27S95,304,96.67,310.72a28.62,28.62,0,0,0,4.69,10.39s-8.38,12.4-6.7,22.78,6,11.73,6,11.73-3.68,19.11,3,25.81,21.45,14.07,37.87,11.06,27.48-3.69,30.83-9.39,1.34-30.83,1.34-30.83-.67-27.81-1.34-44.91-3-30.83-11.06-37.53-43.57,3.69-54.29,10.72S97.34,290.27,97.34,290.27Z", "id", "ell3hztah0e", 1, "animable", 2, "fill", "#407BFF", "transform-origin", "134.368px 330.426px"], ["id", "eledmhftp578d", 1, "animable", 2, "clip-path", 'url("#freepik--clip-path-3--inject-39")', "transform-origin", "136.803px 330.426px"], ["id", "el3uwe0mojbw4"], ["d", "M99.73,290.27s-2.35,13.74-.67,20.45a28.43,28.43,0,0,0,4.69,10.39s-8.38,12.4-6.7,22.78,6,11.73,6,11.73-3.69,19.11,3,25.81S127.54,395.5,144,392.49s27.49-3.69,30.84-9.39,1.34-30.83,1.34-30.83-.67-27.81-1.34-44.91-3-30.83-11.06-37.53-43.57,3.69-54.29,10.72S99.73,290.27,99.73,290.27Z", "id", "eladn59dowvaf", 1, "animable", 2, "opacity", "0.3", "transform-origin", "136.803px 330.426px"], ["d", "M97.34,290.27S95,304,96.67,310.72a28.62,28.62,0,0,0,4.69,10.39s-8.38,12.4-6.7,22.78,6,11.73,6,11.73-3.68,19.11,3,25.81,21.45,14.07,37.87,11.06,27.48-3.69,30.83-9.39,1.34-30.83,1.34-30.83-.67-27.81-1.34-44.91-3-30.83-11.06-37.53-43.57,3.69-54.29,10.72S97.34,290.27,97.34,290.27Z", "id", "elswejbqec52e", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "134.368px 330.426px"], ["d", "M101.36,321.11a40.77,40.77,0,0,0,35.86,5", "id", "el8nym6qdq5z", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "119.29px 324.655px"], ["d", "M100.69,355.62s17.09,16.76,45.25.67", "id", "elpx7hjwt11p", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "123.315px 359.446px"], ["d", "M167.38,273.85s-6.36-9.72-15.08-15.08-31.16-9.38-40.21-11.06-18.77-1-21.45,9-2.35,26.81.33,34.18,13.74,11.73,22.46,6.71,32.84-24.47,41.22-25.47S166.71,277.54,167.38,273.85Z", "id", "el7i12ujm9q5u", 1, "animable", 2, "fill", "rgb(117, 117, 117)", "transform-origin", "128.084px 273.379px"], ["id", "elbp0fdmm94i", 1, "animable", 2, "clip-path", 'url("#freepik--clip-path-4--inject-39")', "transform-origin", "120.171px 274.303px"], ["id", "elotszo2e78r"], ["d", "M148.79,272c5.11-2.13-7.67,1.7-8.52.42s8.94-7.66,11.07-8.51-12.35,2.13-11.92,0,14.05-2.56,4.68-4.69-40-7.67-46-9.8a4.94,4.94,0,0,1-1.29-.64,11.92,11.92,0,0,0-6.17,8c-2.68,10.05-2.35,26.81.33,34.18,2.34,6.42,11,10.55,19,8.2,3.69-3,7.1-6.94,12.87-10.57C134.31,281.33,143.68,274.09,148.79,272Z", "id", "el28cqgmsstmy", 1, "animable", 2, "opacity", "0.3", "transform-origin", "120.171px 274.303px"], ["d", "M167.38,273.85s-6.36-9.72-15.08-15.08-31.16-9.38-40.21-11.06-18.77-1-21.45,9-2.35,26.81.33,34.18,13.74,11.73,22.46,6.71,32.84-24.47,41.22-25.47S166.71,277.54,167.38,273.85Z", "id", "el2ipp6s41ivh", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "128.084px 273.379px"], ["d", "M203.58,319.43s7.71,1,12.73,3,8.38,14.41,6.37,16.08-6-.33-6-.33a49.07,49.07,0,0,1-9.72,2.34C202.91,340.88,198.55,321.78,203.58,319.43Z", "id", "ele0jg1wj54ed", 1, "animable", 2, "fill", "#407BFF", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "212.295px 329.978px"], ["d", "M178.11,318.42s1.34,0,8.71-3.35,13.41-3.35,18.1,4,6.7,16.43,4,21.79-12.73,9.05-18.1,9.05-6-7-6-7-.67-11.06-4-15.08S176.77,319.43,178.11,318.42Z", "id", "elx2pc7ecy1vi", 1, "animable", 2, "fill", "rgb(117, 117, 117)", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "193.804px 331.412px"], ["d", "M153.31,273.85c7.37-2.68,16.76-1,20.11,8.38s6.36,36.86,6.36,36.86,8.38,1,11.73,4.7,5,13.07,4.36,17.76-12.4,13.4-25.8,13.74-23.13-6-27.82-23.13S139.42,289,139.42,289s1.7-7.67,4.26-9.38", "id", "el6p4gsdya14p", 1, "animable", 2, "fill", "#407BFF", "transform-origin", "167.531px 314px"], ["id", "elte1a6cz61tc", 1, "animable", 2, "clip-path", 'url("#freepik--clip-path-5--inject-39")', "transform-origin", "167.578px 322.846px"], ["id", "elmw7efrec11h"], ["d", "M195.87,341.55c.67-4.69-1-14.08-4.36-17.76-.13-.15-.29-.29-.43-.43a85.25,85.25,0,0,1,.72,9.08c.67,19.67-26.82,16.38-32.36,2.13-3-7.67-3.84-41.32-12.78-43.87-5.16-1.47-6.92,2.57-7.48,6.26-.18,9.65.14,24.52,3.07,35.2,4.69,17.1,14.41,23.46,27.82,23.13S195.2,346.24,195.87,341.55Z", "id", "el8qmw7fa8vnw", 1, "animable", 2, "opacity", "0.3", "transform-origin", "167.578px 322.846px"], ["d", "M153.31,273.85c7.37-2.68,16.76-1,20.11,8.38s6.36,36.86,6.36,36.86,8.38,1,11.73,4.7,5,13.07,4.36,17.76-12.4,13.4-25.8,13.74-23.13-6-27.82-23.13S139.42,289,139.42,289s1.7-7.67,4.26-9.38", "id", "ele7j3jbprvtg", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "167.531px 314px"], ["d", "M179.78,319.09S182.4,331.3,168.94,338", "id", "el5havdlqkwkw", 1, "animable", 2, "fill", "none", "stroke", "rgb(38, 50, 56)", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.193px", "transform-origin", "174.463px 328.545px"], ["id", "freepik--Text--inject-39", 1, "animable", 2, "transform-origin", "247.09px 221.265px"], ["d", "M113.1,106.25c0-2.78,1.28-4.83,4.17-4.83s4.23,2,4.23,4.83V116c0,2.78-1.29,4.83-4.23,4.83s-4.17-2-4.17-4.83Zm1.25,9.84c0,2.08.82,3.6,2.92,3.6s3-1.52,3-3.6v-9.92c0-2.07-.84-3.6-3-3.6s-2.92,1.53-2.92,3.6Z", "id", "el39tkhlrrsrl", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "117.3px 111.125px"], ["d", "M123.49,106.25c0-2.78,1.28-4.83,4.17-4.83s4.23,2,4.23,4.83V116c0,2.78-1.28,4.83-4.23,4.83s-4.17-2-4.17-4.83Zm1.25,9.84c0,2.08.82,3.6,2.92,3.6s3-1.52,3-3.6v-9.92c0-2.07-.84-3.6-3-3.6s-2.92,1.53-2.92,3.6Z", "id", "elcu0y8nzhtmq", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "127.69px 111.125px"], ["d", "M137.92,101.59c2.94,0,4.09,1.85,4.09,4.63v2.08c0,3-1.4,4.52-4.42,4.52h-2.37v7.86H134V101.59Zm-.33,10.09c2.21,0,3.16-1,3.16-3.3v-2.24c0-2.07-.71-3.41-2.83-3.41h-2.7v9Z", "id", "ely6oev6z0ssa", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "138.005px 111.135px"], ["d", "M151.93,106.2v.4h-1.2v-.49c0-2-.76-3.54-2.83-3.54s-2.84,1.5-2.84,3.52c0,4.63,6.9,4.71,6.9,10,0,2.75-1.2,4.77-4.12,4.77s-4.11-2-4.11-4.77v-1h1.2v1.06c0,2,.79,3.52,2.89,3.52s2.89-1.48,2.89-3.52c0-4.58-6.9-4.66-6.9-10,0-2.86,1.25-4.72,4.06-4.75S151.93,103.44,151.93,106.2Z", "id", "elwv1xr6b21no", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "147.845px 111.13px"], ["d", "M155.07,118.28v2.4h-1.22v-2.4Z", "id", "elyxp76y3094c", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "154.46px 119.48px"], ["d", "M158.48,118.28v2.4h-1.22v-2.4Z", "id", "elvsbk9zdatto", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "157.87px 119.48px"], ["d", "M161.89,118.28v2.4h-1.23v-2.4Z", "id", "ellpjybitfyfo", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "161.275px 119.48px"], ["d", "M117.13,129.36c3,0,4.09,1.85,4.09,4.64v2.07c0,3-1.39,4.53-4.41,4.53h-2.38v7.85h-1.25V129.36Zm-.32,10.09c2.2,0,3.16-1,3.16-3.3v-2.24c0-2.07-.71-3.4-2.84-3.4h-2.7v8.94Z", "id", "elhk1w3cab5iq", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "117.2px 138.905px"], ["d", "M124.58,144.22l-1,4.23h-1.15l4.17-19.12h1.83l4.25,19.12h-1.25l-1-4.23Zm.19-1.09h5.56l-2.81-12.35Z", "id", "elrlrifv5deh", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "127.555px 138.89px"], ["d", "M142.77,134v1.42h-1.2v-1.5c0-2-.79-3.6-2.89-3.6s-2.89,1.56-2.89,3.6v9.93c0,2,.79,3.57,2.89,3.57s2.89-1.53,2.89-3.57v-4.12H139v-1.14h3.73v5.18c0,2.75-1.2,4.82-4.12,4.82s-4.11-2.07-4.11-4.82V134c0-2.75,1.2-4.82,4.11-4.82S142.77,131.27,142.77,134Z", "id", "el3et4u7yxo63", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "138.635px 138.885px"], ["d", "M151.34,138.2v1.14h-5.21v8h6.27v1.15h-7.53V129.36h7.53v1.15h-6.27v7.69Z", "id", "el2b1ejg1lp5f", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "148.635px 138.925px"], ["d", "M159.82,148.45h-1.15V129.36h1.64L166,145.48V129.36h1.14v19.09h-1.39l-6-17Z", "id", "elv71ykfrz3p", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "162.905px 138.905px"], ["d", "M169.26,134c0-2.78,1.28-4.82,4.17-4.82s4.23,2,4.23,4.82v9.77c0,2.78-1.29,4.82-4.23,4.82s-4.17-2-4.17-4.82Zm1.25,9.85c0,2.07.82,3.6,2.92,3.6s3-1.53,3-3.6v-9.93c0-2.07-.84-3.6-3-3.6s-2.92,1.53-2.92,3.6Z", "id", "eltkn21g2zgbk", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "173.46px 138.885px"], ["d", "M183,148.45V130.51h-3.87v-1.15h9v1.15h-3.9v17.94Z", "id", "elezq6evuc11v", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "183.63px 138.905px"], ["d", "M200.08,138.66v1.14h-4.94v8.65h-1.25V129.36h7.25v1.15h-6v8.15Z", "id", "elv6jz5dw8jeg", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "197.515px 138.905px"], ["d", "M203,134c0-2.78,1.28-4.82,4.17-4.82s4.23,2,4.23,4.82v9.77c0,2.78-1.28,4.82-4.23,4.82s-4.17-2-4.17-4.82Zm1.25,9.85c0,2.07.82,3.6,2.92,3.6s3-1.53,3-3.6v-9.93c0-2.07-.84-3.6-3-3.6s-2.92,1.53-2.92,3.6Z", "id", "el2gxvqkhwqi", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "207.2px 138.885px"], ["d", "M214.64,143.84c0,2,.77,3.63,2.87,3.63s2.86-1.58,2.86-3.63V129.36h1.17v14.43c0,2.72-1.14,4.82-4.06,4.82s-4.09-2.1-4.09-4.82V129.36h1.25Z", "id", "elyovg5r1w71", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "217.465px 138.985px"], ["d", "M224.84,148.45H223.7V129.36h1.63l5.73,16.12V129.36h1.15v19.09h-1.4l-6-17Z", "id", "el4pp3emgir1d", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "227.955px 138.905px"], ["d", "M238.56,129.36c2.95,0,4.23,1.94,4.23,4.75v9.59c0,2.81-1.28,4.75-4.23,4.75h-4.2V129.36Zm0,17.94c2.13,0,3-1.44,3-3.54v-9.71c0-2.1-.9-3.54-3-3.54h-2.91V147.3Z", "id", "eldf69dilxr9g", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "238.575px 138.905px"], ["d", "M302,325.13,315.61,293h8.15v32.13h3.53v6.79h-3.53v8.63h-7.34v-8.63H302Zm14.4,0V307.27l-7.54,17.86Z", "id", "elrmmnmgastdf", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "314.645px 316.775px"], ["d", "M330.08,304.41c0-7.6,4-12,11.34-12s11.34,4.35,11.34,12v24.72c0,7.61-4,12-11.34,12s-11.34-4.35-11.34-12Zm7.47,25.2c0,3.4,1.49,4.69,3.87,4.69s3.87-1.29,3.87-4.69V303.94c0-3.4-1.5-4.69-3.87-4.69s-3.87,1.29-3.87,4.69Z", "id", "ellrdavhpkusp", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "341.42px 316.77px"], ["d", "M355.82,325.13,369.4,293h8.15v32.13h3.53v6.79h-3.53v8.63h-7.34v-8.63H355.82Zm14.39,0V307.27l-7.53,17.86Z", "id", "el0qvpypxddu0e", 1, "animable", 2, "fill", "rgb(38, 50, 56)", "transform-origin", "368.45px 316.775px"], ["id", "freepik--clip-path--inject-39"], ["d", "M86.28,404.22v22.52A4.84,4.84,0,0,0,88.9,431l36.2,18.69a4.81,4.81,0,0,0,4.19.12l53.33-20.33a4.84,4.84,0,0,0,2.86-4.41V397.85l-61,18.43Z", 2, "fill", "#92E3A9", "stroke", "#263238", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.1930027515339008px"], ["id", "freepik--clip-path-2--inject-39"], ["d", "M142,366.2,83.5,385a2.26,2.26,0,0,0-1.57,2.16v16.68a2.27,2.27,0,0,0,1.29,2L124,425.25a2.27,2.27,0,0,0,1.77.08L187,402.42a2.27,2.27,0,0,0,1.48-2.12l.11-15.65a2.29,2.29,0,0,0-1.79-2.22l-43.64-16.29A2.36,2.36,0,0,0,142,366.2Z", 2, "fill", "#fff", "stroke", "#263238", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.1930027515339008px"], ["id", "freepik--clip-path-3--inject-39"], ["d", "M97.34,290.27S95,304,96.67,310.72a28.62,28.62,0,0,0,4.69,10.39s-8.38,12.4-6.7,22.78,6,11.73,6,11.73-3.68,19.11,3,25.81,21.45,14.07,37.87,11.06,27.48-3.69,30.83-9.39,1.34-30.83,1.34-30.83-.67-27.81-1.34-44.91-3-30.83-11.06-37.53-43.57,3.69-54.29,10.72S97.34,290.27,97.34,290.27Z", 2, "fill", "#92E3A9", "stroke", "#263238", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.1930027515339008px"], ["id", "freepik--clip-path-4--inject-39"], ["d", "M167.38,273.85s-6.36-9.72-15.08-15.08-31.16-9.38-40.21-11.06-18.77-1-21.45,9-2.35,26.81.33,34.18,13.74,11.73,22.46,6.71,32.84-24.47,41.22-25.47S166.71,277.54,167.38,273.85Z", 2, "fill", "#757575", "stroke", "#263238", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.1930027515339008px"], ["id", "freepik--clip-path-5--inject-39"], ["d", "M153.31,273.85c7.37-2.68,16.76-1,20.11,8.38s6.36,36.86,6.36,36.86,8.38,1,11.73,4.7,5,13.07,4.36,17.76-12.4,13.4-25.8,13.74-23.13-6-27.82-23.13S139.42,289,139.42,289s1.7-7.67,4.26-9.38", 2, "fill", "#92E3A9", "stroke", "#263238", "stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "1.1930027515339008px"], ["id", "active", "height", "200%"], ["in", "SourceAlpha", "result", "DILATED", "operator", "dilate", "radius", "2"], ["flood-color", "#32DFEC", "flood-opacity", "1", "result", "PINK"], ["in", "PINK", "in2", "DILATED", "operator", "in", "result", "OUTLINE"], ["in", "OUTLINE"], ["in", "SourceGraphic"], ["id", "hover", "height", "200%"], ["flood-color", "#ff0000", "flood-opacity", "0.5", "result", "PINK"], ["type", "matrix", "values", "0   0   0   0   0                0   1   0   0   0                0   0   0   0   0                0   0   0   1   0 "], [1, "flex", "items-center", "justify-center"], ["routerLink", "/", "type", "button", 1, "text-white", "bg-blue-700", "hover:bg-blue-800", "focus:ring-4", "focus:outline-none", "focus:ring-blue-300", "font-medium", "rounded-lg", "text-sm", "px-5", "py-2.5", "text-center", "inline-flex", "items-center", "dark:bg-blue-600", "dark:hover:bg-blue-700", "dark:focus:ring-blue-800"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "2", 1, "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M10 19l-7-7m0 0l7-7m-7 7h18"]], template: function (e, i) { 1 & e && (_(0, "div", 0)(1, "div", 1), Je(), _(2, "svg", 2)(3, "g", 3), C(4, "path", 4), _(5, "g", 5), C(6, "path", 6), w()(), _(7, "g", 7), C(8, "ellipse", 8)(9, "path", 9)(10, "path", 10)(11, "path", 11)(12, "path", 12)(13, "path", 13), w(), _(14, "g", 14), C(15, "path", 15)(16, "path", 16)(17, "path", 17)(18, "path", 18), w(), _(19, "g", 19), C(20, "path", 20)(21, "path", 21)(22, "path", 22)(23, "path", 23)(24, "path", 24)(25, "path", 25), w(), _(26, "g", 26), C(27, "path", 27)(28, "path", 28)(29, "path", 29)(30, "path", 30)(31, "rect", 31)(32, "path", 32)(33, "path", 33)(34, "path", 34)(35, "path", 35)(36, "path", 36)(37, "path", 37)(38, "path", 38)(39, "path", 39)(40, "path", 40)(41, "path", 41)(42, "path", 42)(43, "path", 43)(44, "path", 44)(45, "path", 45)(46, "path", 46)(47, "path", 47)(48, "path", 48)(49, "path", 49)(50, "path", 50)(51, "path", 51), _(52, "g", 52)(53, "g", 53), C(54, "path", 54), w()(), C(55, "path", 55)(56, "path", 56), _(57, "g", 57), C(58, "path", 58), _(59, "g", 59), C(60, "path", 60), w(), C(61, "path", 61), w(), C(62, "path", 62)(63, "path", 63)(64, "path", 64)(65, "path", 65)(66, "path", 66)(67, "path", 67), _(68, "g", 68)(69, "g", 69), C(70, "path", 70), w()(), C(71, "path", 71)(72, "path", 72)(73, "path", 73)(74, "path", 74), _(75, "g", 75)(76, "g", 76), C(77, "path", 77), w()(), C(78, "path", 78)(79, "path", 79)(80, "path", 80)(81, "path", 81), _(82, "g", 82)(83, "g", 83), C(84, "path", 84), w()(), C(85, "path", 85)(86, "path", 86), w(), _(87, "g", 87), C(88, "path", 88)(89, "path", 89)(90, "path", 90)(91, "path", 91)(92, "path", 92)(93, "path", 93)(94, "path", 94)(95, "path", 95)(96, "path", 96)(97, "path", 97)(98, "path", 98)(99, "path", 99)(100, "path", 100)(101, "path", 101)(102, "path", 102)(103, "path", 103)(104, "path", 104)(105, "path", 105)(106, "path", 106)(107, "path", 107)(108, "path", 108)(109, "path", 109), w(), _(110, "defs")(111, "clipPath", 110), C(112, "path", 111), w(), _(113, "clipPath", 112), C(114, "path", 113), w(), _(115, "clipPath", 114), C(116, "path", 115), w(), _(117, "clipPath", 116), C(118, "path", 117), w(), _(119, "clipPath", 118), C(120, "path", 119), w()(), _(121, "defs")(122, "filter", 120), C(123, "feMorphology", 121)(124, "feFlood", 122)(125, "feComposite", 123), _(126, "feMerge"), C(127, "feMergeNode", 124)(128, "feMergeNode", 125), w()(), _(129, "filter", 126), C(130, "feMorphology", 121)(131, "feFlood", 127)(132, "feComposite", 123), _(133, "feMerge"), C(134, "feMergeNode", 124)(135, "feMergeNode", 125), w(), C(136, "feColorMatrix", 128), w()()()()(), yt(), _(137, "div", 129)(138, "button", 130), I(139), R(140, "translate"), Je(), _(141, "svg", 131), C(142, "path", 132), w()()()), 2 & e && (M(139), fe(" ", O(140, 1, "notfound.back"), " ")) }, dependencies: [Hr, Xc], styles: ["svg#freepik_stories-404-error[_ngcontent-%COMP%]:not(.animated)   .animable[_ngcontent-%COMP%] {opacity: 0;}svg#freepik_stories-404-error.animated[_ngcontent-%COMP%]   #freepik--Hole--inject-39[_ngcontent-%COMP%] {animation: 1.5s Infinite  linear heartbeat;animation-delay: 0s;}svg#freepik_stories-404-error.animated[_ngcontent-%COMP%]   #freepik--Clouds--inject-39[_ngcontent-%COMP%] {animation: 3s Infinite  linear floating;animation-delay: 0s;}svg#freepik_stories-404-error.animated[_ngcontent-%COMP%]   #freepik--Text--inject-39[_ngcontent-%COMP%] {animation: 3s Infinite  linear shake;animation-delay: 0s;}            @keyframes heartbeat {                0% {                    transform: scale(1);                }                10% {                    transform: scale(1.1);                }                30% {                    transform: scale(1);                }                40% {                    transform: scale(1);                }                50% {                    transform: scale(1.1);                }                60% {                    transform: scale(1);                }                100% {                    transform: scale(1);                }            }                    @keyframes floating {                0% {                    opacity: 1;                    transform: translateY(0px);                }                50% {                    transform: translateY(-10px);                }                100% {                    opacity: 1;                    transform: translateY(0px);                }            }                    @keyframes shake {                10%, 90% {                    transform: translate3d(-1px, 0, 0);                  }                  20%, 80% {                    transform: translate3d(2px, 0, 0);                  }                  30%, 50%, 70% {                    transform: translate3d(-4px, 0, 0);                  }                  40%, 60% {                    transform: translate3d(4px, 0, 0);                  }            }"] }), n })(); function y6(n, t) { if (1 & n && (_(0, "div", 41), C(1, "img", 42), w()), 2 & n) { const e = lt().$implicit; M(1), De("src", "../../assets/resources/public/LVS/" + e, hr) } } function v6(n, t) { 1 & n && jt(0, y6, 2, 1, "ng-template", 40) } function _6(n, t) { if (1 & n && (_(0, "div", 41), C(1, "img", 42), w()), 2 & n) { const e = lt().$implicit; M(1), De("src", "../../assets/resources/public/LVS/alt/" + e, hr) } } function b6(n, t) { 1 & n && jt(0, _6, 2, 1, "ng-template", 40) } let w6 = (() => { class n { constructor() { this.imgUrls = ["Login and register.gif", "lesson.gif", "Tabla de posiciones.gif", "Foro.gif"], this.imgAltUrls = ["1.jpg", "2.jpg", "3.jpg", "4.jpg", "5.jpg", "6.jpg", "7.jpg", "8.jpg", "9.jpg", "10.jpg", "11.jpg", "12.jpg", "13.jpg"], this.customOptions = { autoWidth: !0, loop: !0, mouseDrag: !0, touchDrag: !0, pullDrag: !0, dots: !0, navSpeed: 700, autoplay: !0, autoplayTimeout: 15e3, navText: ["\u25c0\ufe0f", "\u25b6\ufe0f"], responsive: { 0: { items: 1 } }, nav: !0 } } ngOnInit() { document.getElementById("up").scrollIntoView() } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = Un({ type: n, selectors: [["app-lvs"]], decls: 96, vars: 43, consts: [["id", "up"], [1, "max-w-2xl", "mx-auto", "pt-10", "pb-16", "px-4", "sm:px-6", "lg:max-w-7xl", "lg:pt-16", "lg:pb-24", "lg:px-8", "lg:grid", "lg:grid-cols-3", "lg:grid-rows-[auto,auto,1fr]", "lg:gap-x-8"], [1, "lg:col-span-2", "lg:border-r", "lg:border-gray-200", "lg:pr-8"], [1, "text-2xl", "font-extrabold", "tracking-tight", "text-gray-900", "sm:text-3xl"], [1, "mt-4", "lg:mt-0", "lg:row-span-3"], [1, "mt-10"], [1, "text-sm", "text-gray-900", "font-medium"], [1, "mt-4"], [1, "sr-only"], [1, "flex", "items-center", "space-x-3"], ["src", "../../assets/resources/public/LVS/Color Palette.jpg", "alt", "Colors"], [1, "bg-white", "flex", "items-stretch", "justify-center"], [1, "mt-1", "flex", "items-center"], ["src", "../../assets/resources/public/LVS/LVS.png", "alt", "Colors", 1, "w-1/3"], ["src", "../../assets/resources/public/LVS/LogoLogin.png", "alt", "Colors", 1, "w-1/2"], [1, "py-10", "lg:pt-6", "lg:pb-16", "lg:col-start-1", "lg:col-span-2", "lg:border-r", "lg:border-gray-200", "lg:pr-8"], [1, "space-y-6"], [1, "text-base", "text-gray-900"], [1, "text-2xl", "font-medium", "text-gray-900"], [1, "mt-4", "space-y-6"], [1, "text-xl", "text-gray-600"], ["aria-labelledby", "dropdownUsersButton", 1, "overflow-y-auto", "py-1", "h-50", "text-gray-700", "dark:text-gray-200"], ["href", "https://www.mysql.com", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/mysql.svg", "alt", "Mysql", 1, "mr-2", "w-20", "h-10"], ["href", "https://www.java.com/es/", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/Java.svg", "alt", "Java", 1, "mr-2", "w-20", "h-10"], ["href", "https://openjfx.io/", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/JavaFX.png", "alt", "JavaFX", 1, "mr-2", "w-20", "h-10"], ["href", "https://github.com/sshahine/JFoenix", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/JFoenix.png", "alt", "JFoenix", 1, "mr-2", "w-20", "h-15"], [1, "py-12", "bg-white"], [1, "max-w-7xl", "mx-auto", "px-4", "sm:px-6", "lg:px-8"], [1, "lg:text-center"], [1, "text-center", "mb-4", "text-3xl", "font-extrabold", "tracking-tight"], [3, "options"], [4, "ngFor", "ngForOf"], [1, "flex", "items-center", "justify-center"], ["routerLink", "/", "type", "button", 1, "text-white", "bg-blue-700", "hover:bg-blue-800", "focus:ring-4", "focus:outline-none", "focus:ring-blue-300", "font-medium", "rounded-lg", "text-sm", "px-5", "py-2.5", "text-center", "inline-flex", "items-center", "dark:bg-blue-600", "dark:hover:bg-blue-700", "dark:focus:ring-blue-800"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "2", 1, "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M10 19l-7-7m0 0l7-7m-7 7h18"], ["carouselSlide", ""], [1, "flex", "flex-wrap", "justify-center"], [1, "px-20", "bg-white", "border", "rounded", "md", 3, "src"]], template: function (e, i) { 1 & e && (C(0, "div", 0), _(1, "div", 1)(2, "div", 2)(3, "h1", 3), I(4), R(5, "translate"), w()(), _(6, "div", 4)(7, "div", 5)(8, "div")(9, "h3", 6), I(10), R(11, "translate"), w(), _(12, "fieldset", 7)(13, "legend", 8), I(14), R(15, "translate"), w(), _(16, "div", 9), C(17, "img", 10), w()()(), C(18, "div", 11), _(19, "div")(20, "h3", 6), I(21, "Logos"), w(), _(22, "div", 12), C(23, "img", 13)(24, "img", 14), w()()()(), _(25, "div", 15)(26, "div")(27, "h3", 8), I(28), R(29, "translate"), w(), _(30, "div", 16)(31, "p", 17), I(32), R(33, "translate"), w()()(), _(34, "div", 5)(35, "h2", 18), I(36), R(37, "translate"), w(), _(38, "div", 19)(39, "p", 20), I(40), R(41, "translate"), w()()(), _(42, "div", 5)(43, "h3", 18), I(44), R(45, "translate"), w(), _(46, "div", 7)(47, "ul", 21)(48, "li")(49, "a", 22), C(50, "img", 23), I(51, " MySQL "), w()(), _(52, "li")(53, "a", 24), C(54, "img", 25), I(55, " Java SE "), w()(), _(56, "li")(57, "a", 26), C(58, "img", 27), I(59, " Java FX "), w()(), _(60, "li")(61, "a", 28), C(62, "img", 29), I(63, " JFoenix "), w()()()()(), _(64, "div", 5)(65, "h2", 18), I(66), R(67, "translate"), w(), _(68, "div", 19)(69, "p", 20), I(70), R(71, "translate"), w()()()()(), _(72, "div")(73, "div", 30)(74, "div", 31)(75, "div", 32)(76, "div")(77, "h2", 33), I(78), R(79, "translate"), w()(), _(80, "div")(81, "owl-carousel-o", 34), jt(82, v6, 1, 0, null, 35), w()(), _(83, "div")(84, "h2", 33), I(85), R(86, "translate"), w()(), _(87, "div")(88, "owl-carousel-o", 34), jt(89, b6, 1, 0, null, 35), w()()()()()(), _(90, "div", 36)(91, "button", 37), I(92), R(93, "translate"), Je(), _(94, "svg", 38), C(95, "path", 39), w()()()), 2 & e && (M(4), fe("", O(5, 17, "startingpage.title1lvs"), " "), M(6), q(O(11, 19, "lvs.colors")), M(4), q(O(15, 21, "lvs.colorpalette")), M(14), q(O(29, 23, "startingpage.description")), M(4), q(O(33, 25, "startingpage.descriptionlvs")), M(4), q(O(37, 27, "lvs.why")), M(4), q(O(41, 29, "lvs.descriptionwhy")), M(4), q(O(45, 31, "lvs.titletechnologies")), M(22), q(O(67, 33, "lvs.titlecollaborators")), M(4), q(O(71, 35, "lvs.collaborators")), M(8), fe(" ", O(79, 37, "lvs.screen"), " "), M(3), De("options", i.customOptions), M(1), De("ngForOf", i.imgUrls), M(3), fe(" ", O(86, 39, "lvs.prototype"), " "), M(3), De("options", i.customOptions), M(1), De("ngForOf", i.imgAltUrls), M(3), fe(" ", O(93, 41, "notfound.back"), " ")) }, dependencies: [Zo, fC, jg, Hr, Xc] }), n })(), D6 = (() => { class n { constructor() { } ngOnInit() { document.getElementById("up").scrollIntoView() } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = Un({ type: n, selectors: [["app-medicom"]], decls: 184, vars: 90, consts: [["id", "up"], [1, "py-12", "bg-white"], [1, "max-w-7xl", "mx-auto", "px-4", "sm:px-6", "lg:px-8"], [1, "lg:text-center"], [1, "mt-2", "text-3xl", "leading-8", "font-extrabold", "tracking-tight", "text-gray-900", "sm:text-4xl"], [1, "mt-4", "max-w-2xl", "text-xl", "text-gray-500", "lg:mx-auto"], [1, "mt-10"], [1, "space-y-10", "md:space-y-0", "md:grid", "md:grid-cols-2", "md:gap-x-8", "md:gap-y-10"], [1, "relative"], [1, "absolute", "flex", "items-center", "justify-center", "h-12", "w-12", "rounded-md", "bg-blue-500", "text-white"], ["xmlns", "http://www.w3.org/2000/svg", "className", "h-6 w-6", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "strokeWidth", "{2}", 1, "h-6", "w-6"], ["strokeLinecap", "round", "strokeLinejoin", "round", "d", "M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"], [1, "ml-16", "text-lg", "leading-6", "font-medium", "text-gray-900"], [1, "mt-2", "ml-16", "text-base", "text-gray-500"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "2", 1, "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke-width", "2", "stroke", "currentColor", "aria-hidden", "true", 1, "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M13 10V3L4 14h7v7l9-11h-7z"], [1, "mt-10", "lg:text-center"], [1, "text-2xl", "font-medium", "text-gray-900"], [1, "flex", "flex-row", "min-h-auto", "justify-center", "items-center"], ["aria-labelledby", "dropdownUsersButton", 1, "overflow-y-auto", "py-1", "h-50", "text-gray-700", "dark:text-gray-200"], ["href", "https://www.mysql.com", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/mysql.svg", "alt", "Mysql", 1, "mr-2", "w-20", "h-10"], ["href", "https://www.java.com/es/", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/Java.svg", "alt", "Java", 1, "mr-2", "w-20", "h-10"], ["href", "https://openjfx.io/", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/JavaFX.png", "alt", "JavaFX", 1, "mr-2", "w-20", "h-10"], ["href", "https://github.com/sshahine/JFoenix", 1, "flex", "items-center", "py-2", "px-4", "hover:bg-gray-100", "dark:hover:bg-gray-600", "dark:hover:text-white"], ["src", "../../assets/resources/public/tecnologis/JFoenix.png", "alt", "JFoenix", 1, "mr-2", "w-20", "h-15"], [1, "bg-gray-100"], [1, "max-w-2xl", "mx-auto", "py-16", "sm:py-24", "lg:py-32", "lg:max-w-none"], [1, "text-2xl", "font-extrabold", "text-gray-900"], [1, "mt-6", "text-sm", "text-gray-500"], [1, "absolute", "inset-0"], [1, "mt-6", "space-y-12", "lg:space-y-0", "lg:grid", "lg:grid-cols-3", "lg:gap-x-6"], [1, "group", "relative"], [1, "relative", "w-full", "h-80", "bg-white", "rounded-lg", "overflow-hidden", "group-hover:opacity-75", "sm:aspect-w-2", "sm:aspect-h-1", "sm:h-64", "lg:aspect-w-1", "lg:aspect-h-1"], ["src", "../../assets/resources/public/medicom/Login.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], [1, "text-base", "font-semibold", "text-gray-900"], ["src", "../../assets/resources/public/medicom/User registration.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Menu.jpeg", "alt", "Collection of four insulated travel bottles on wooden shelf.", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Recommendations.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Search.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Search results.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Medical control record.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Successful.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], ["src", "../../assets/resources/public/medicom/Error.jpeg", "alt", "", 1, "w-full", "h-full", "object-center", "object-cover"], [1, "flex", "items-center", "justify-center"], ["routerLink", "/", "type", "button", 1, "text-white", "bg-blue-700", "hover:bg-blue-800", "focus:ring-4", "focus:outline-none", "focus:ring-blue-300", "font-medium", "rounded-lg", "text-sm", "px-5", "py-2.5", "text-center", "inline-flex", "items-center", "dark:bg-blue-600", "dark:hover:bg-blue-700", "dark:focus:ring-blue-800"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M10 19l-7-7m0 0l7-7m-7 7h18"]], template: function (e, i) { 1 & e && (C(0, "div", 0), _(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "p", 4), I(5), R(6, "translate"), w(), _(7, "p", 5), I(8), R(9, "translate"), w()(), _(10, "div", 6)(11, "dl", 7)(12, "div", 8)(13, "dt")(14, "div", 9), Je(), _(15, "svg", 10), C(16, "path", 11), w()(), yt(), _(17, "p", 12), I(18), R(19, "translate"), w()(), _(20, "dd", 13), I(21), R(22, "translate"), w()(), _(23, "div", 8)(24, "dt")(25, "div", 9), Je(), _(26, "svg", 14), C(27, "path", 15), w()(), yt(), _(28, "p", 12), I(29), R(30, "translate"), w()(), _(31, "dd", 13), I(32), R(33, "translate"), w()(), _(34, "div", 8)(35, "dt")(36, "div", 9), Je(), _(37, "svg", 16), C(38, "path", 17), w()(), yt(), _(39, "p", 12), I(40), R(41, "translate"), w()(), _(42, "dd", 13), I(43), R(44, "translate"), w()()()()()(), _(45, "div", 18)(46, "h3", 19), I(47), R(48, "translate"), w(), _(49, "div", 20)(50, "ul", 21)(51, "li")(52, "a", 22), C(53, "img", 23), I(54, " MySQL "), w()(), _(55, "li")(56, "a", 24), C(57, "img", 25), I(58, " Java SE "), w()(), _(59, "li")(60, "a", 26), C(61, "img", 27), I(62, " Java FX "), w()(), _(63, "li")(64, "a", 28), C(65, "img", 29), I(66, " JFoenix "), w()()()()(), _(67, "div", 30)(68, "div", 2)(69, "div", 31)(70, "h2", 32), I(71), R(72, "translate"), w(), _(73, "h3", 33)(74, "a"), C(75, "span", 34), I(76), R(77, "translate"), w()(), _(78, "div", 35)(79, "div", 36)(80, "div", 37), C(81, "img", 38), w(), _(82, "p", 39), I(83), R(84, "translate"), w(), _(85, "h3", 33)(86, "a"), C(87, "span", 34), I(88), R(89, "translate"), w()()(), _(90, "div", 36)(91, "div", 37), C(92, "img", 40), w(), _(93, "p", 39), I(94), R(95, "translate"), w(), _(96, "h3", 33)(97, "a"), C(98, "span", 34), I(99), R(100, "translate"), w()()(), _(101, "div", 36)(102, "div", 37), C(103, "img", 41), w(), _(104, "p", 39), I(105), R(106, "translate"), w(), _(107, "h3", 33)(108, "a"), C(109, "span", 34), I(110), R(111, "translate"), w()()(), _(112, "div", 36)(113, "div", 37), C(114, "img", 42), w(), _(115, "p", 39), I(116), R(117, "translate"), w(), _(118, "h3", 33)(119, "a"), C(120, "span", 34), I(121), R(122, "translate"), w()()(), _(123, "div", 36)(124, "div", 37), C(125, "img", 43), w(), _(126, "p", 39), I(127), R(128, "translate"), w(), _(129, "h3", 33)(130, "a"), C(131, "span", 34), I(132), R(133, "translate"), w()()(), _(134, "div", 36)(135, "div", 37), C(136, "img", 44), w(), _(137, "p", 39), I(138), R(139, "translate"), w(), _(140, "h3", 33)(141, "a"), C(142, "span", 34), I(143), R(144, "translate"), w()()(), _(145, "div", 36)(146, "div", 37), C(147, "img", 45), w(), _(148, "p", 39), I(149), R(150, "translate"), w(), _(151, "h3", 33)(152, "a"), C(153, "span", 34), I(154), R(155, "translate"), w()()(), _(156, "div", 36)(157, "div", 37), C(158, "img", 46), w(), _(159, "p", 39), I(160), R(161, "translate"), w(), _(162, "h3", 33)(163, "a"), C(164, "span", 34), I(165), R(166, "translate"), w()()(), _(167, "div", 36)(168, "div", 37), C(169, "img", 47), w(), _(170, "p", 39), I(171), R(172, "translate"), w(), _(173, "h3", 33)(174, "a"), C(175, "span", 34), I(176), R(177, "translate"), w()()()()()()(), _(178, "div", 48)(179, "button", 49), I(180), R(181, "translate"), Je(), _(182, "svg", 14), C(183, "path", 50), w()()()), 2 & e && (M(5), q(O(6, 30, "startingpage.title1medicom")), M(3), q(O(9, 32, "startingpage.descriptionmedicom")), M(10), q(O(19, 34, "startingpage.multiplatform")), M(3), q(O(22, 36, "startingpage.descriptionmultiplatform")), M(8), q(O(30, 38, "startingpage.security")), M(3), q(O(33, 40, "startingpage.descriptionsecurity")), M(8), q(O(41, 42, "startingpage.sql")), M(3), q(O(44, 44, "startingpage.descriptionsql")), M(4), q(O(48, 46, "lvs.titletechnologies")), M(24), q(O(72, 48, "lvs.screen")), M(5), fe(" ", O(77, 50, "medicom.censorship"), " "), M(7), q(O(84, 52, "medicom.titlelogin")), M(5), fe(" ", O(89, 54, "medicom.login"), " "), M(6), q(O(95, 56, "medicom.titleuserregister")), M(5), fe(" ", O(100, 58, "medicom.userregister"), " "), M(6), q(O(106, 60, "medicom.titlemenu")), M(5), fe(" ", O(111, 62, "medicom.menu"), " "), M(6), q(O(117, 64, "medicom.titlerecommendations")), M(5), fe(" ", O(122, 66, "medicom.recommendations"), " "), M(6), q(O(128, 68, "medicom.titlesearch")), M(5), fe(" ", O(133, 70, "medicom.search"), " "), M(6), q(O(139, 72, "medicom.titlesearchresult")), M(5), fe(" ", O(144, 74, "medicom.searchresult"), " "), M(6), q(O(150, 76, "medicom.titlemedicalcontrolrecord")), M(5), fe(" ", O(155, 78, "medicom.medicalcontrolrecord"), " "), M(6), q(O(161, 80, "medicom.titlesuccessful")), M(5), fe(" ", O(166, 82, "medicom.successful"), " "), M(6), q(O(172, 84, "medicom.titleerror")), M(5), fe(" ", O(177, 86, "medicom.error"), " "), M(4), fe(" ", O(181, 88, "notfound.back"), " ")) }, dependencies: [Hr, Xc] }), n })(); const pC = typeof window > "u" ? function (n) { return n() } : window.requestAnimationFrame; function gC(n, t, e) { const i = e || (o => Array.prototype.slice.call(o)); let s = !1, r = []; return function (...o) { r = i(o), s || (s = !0, pC.call(window, () => { s = !1, n.apply(t, r) })) } } const Bg = n => "start" === n ? "left" : "end" === n ? "right" : "center", Mt = (n, t, e) => "start" === n ? t : "end" === n ? e : (t + e) / 2; function Ei() { } const S6 = function () { let n = 0; return function () { return n++ } }(); function ye(n) { return null === n || typeof n > "u" } function Le(n) { if (Array.isArray && Array.isArray(n)) return !0; const t = Object.prototype.toString.call(n); return "[object" === t.slice(0, 7) && "Array]" === t.slice(-6) } function pe(n) { return null !== n && "[object Object]" === Object.prototype.toString.call(n) } const Ze = n => ("number" == typeof n || n instanceof Number) && isFinite(+n); function bn(n, t) { return Ze(n) ? n : t } function re(n, t) { return typeof n > "u" ? t : n } const mC = (n, t) => "string" == typeof n && n.endsWith("%") ? parseFloat(n) / 100 * t : +n; function Fe(n, t, e) { if (n && "function" == typeof n.call) return n.apply(e, t) } function xe(n, t, e, i) { let s, r, o; if (Le(n)) if (r = n.length, i) for (s = r - 1; s >= 0; s--)t.call(e, n[s], s); else for (s = 0; s < r; s++)t.call(e, n[s], s); else if (pe(n)) for (o = Object.keys(n), r = o.length, s = 0; s < r; s++)t.call(e, n[o[s]], o[s]) } function xu(n, t) { let e, i, s, r; if (!n || !t || n.length !== t.length) return !1; for (e = 0, i = n.length; e < i; ++e)if (s = n[e], r = t[e], s.datasetIndex !== r.datasetIndex || s.index !== r.index) return !1; return !0 } function Cu(n) { if (Le(n)) return n.map(Cu); if (pe(n)) { const t = Object.create(null), e = Object.keys(n), i = e.length; let s = 0; for (; s < i; ++s)t[e[s]] = Cu(n[e[s]]); return t } return n } function yC(n) { return -1 === ["__proto__", "prototype", "constructor"].indexOf(n) } function M6(n, t, e, i) { if (!yC(n)) return; const s = t[n], r = e[n]; pe(s) && pe(r) ? ba(s, r, i) : t[n] = Cu(r) } function ba(n, t, e) { const i = Le(t) ? t : [t], s = i.length; if (!pe(n)) return n; const r = (e = e || {}).merger || M6; for (let o = 0; o < s; ++o) { if (!pe(t = i[o])) continue; const a = Object.keys(t); for (let l = 0, c = a.length; l < c; ++l)r(a[l], n, t, e) } return n } function wa(n, t) { return ba(n, t, { merger: T6 }) } function T6(n, t, e) { if (!yC(n)) return; const i = t[n], s = e[n]; pe(i) && pe(s) ? wa(i, s) : Object.prototype.hasOwnProperty.call(t, n) || (t[n] = Cu(s)) } function vC(n, t) { const e = n.indexOf(".", t); return -1 === e ? n.length : e } function Ji(n, t) { if ("" === t) return n; let e = 0, i = vC(t, e); for (; n && i > e;)n = n[t.slice(e, i)], e = i + 1, i = vC(t, e); return n } function Vg(n) { return n.charAt(0).toUpperCase() + n.slice(1) } const wn = n => typeof n < "u", es = n => "function" == typeof n, _C = (n, t) => { if (n.size !== t.size) return !1; for (const e of n) if (!t.has(e)) return !1; return !0 }, He = Math.PI, Te = 2 * He, P6 = Te + He, Su = Number.POSITIVE_INFINITY, R6 = He / 180, Ge = He / 2, Da = He / 4, bC = 2 * He / 3, Dn = Math.log10, ii = Math.sign; function wC(n) { const t = Math.round(n); n = Ca(n, t, n / 1e3) ? t : n; const e = Math.pow(10, Math.floor(Dn(n))), i = n / e; return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * e } function xa(n) { return !isNaN(parseFloat(n)) && isFinite(n) } function Ca(n, t, e) { return Math.abs(n - t) < e } function DC(n, t, e) { let i, s, r; for (i = 0, s = n.length; i < s; i++)r = n[i][e], isNaN(r) || (t.min = Math.min(t.min, r), t.max = Math.max(t.max, r)) } function Vn(n) { return n * (He / 180) } function Hg(n) { return n * (180 / He) } function xC(n) { if (!Ze(n)) return; let t = 1, e = 0; for (; Math.round(n * t) / t !== n;)t *= 10, e++; return e } function CC(n, t) { const e = t.x - n.x, i = t.y - n.y, s = Math.sqrt(e * e + i * i); let r = Math.atan2(i, e); return r < -.5 * He && (r += Te), { angle: r, distance: s } } function $g(n, t) { return Math.sqrt(Math.pow(t.x - n.x, 2) + Math.pow(t.y - n.y, 2)) } function F6(n, t) { return (n - t + P6) % Te - He } function cn(n) { return (n % Te + Te) % Te } function Sa(n, t, e, i) { const s = cn(n), r = cn(t), o = cn(e), a = cn(r - s), l = cn(o - s), c = cn(s - r), u = cn(s - o); return s === r || s === o || i && r === o || a > l && c < u } function gt(n, t, e) { return Math.max(t, Math.min(e, n)) } function Mi(n, t, e, i = 1e-6) { return n >= Math.min(t, e) - i && n <= Math.max(t, e) + i } const Eu = n => 0 === n || 1 === n, SC = (n, t, e) => -Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * Te / e), EC = (n, t, e) => Math.pow(2, -10 * n) * Math.sin((n - t) * Te / e) + 1, Ea = { linear: n => n, easeInQuad: n => n * n, easeOutQuad: n => -n * (n - 2), easeInOutQuad: n => (n /= .5) < 1 ? .5 * n * n : -.5 * (--n * (n - 2) - 1), easeInCubic: n => n * n * n, easeOutCubic: n => (n -= 1) * n * n + 1, easeInOutCubic: n => (n /= .5) < 1 ? .5 * n * n * n : .5 * ((n -= 2) * n * n + 2), easeInQuart: n => n * n * n * n, easeOutQuart: n => -((n -= 1) * n * n * n - 1), easeInOutQuart: n => (n /= .5) < 1 ? .5 * n * n * n * n : -.5 * ((n -= 2) * n * n * n - 2), easeInQuint: n => n * n * n * n * n, easeOutQuint: n => (n -= 1) * n * n * n * n + 1, easeInOutQuint: n => (n /= .5) < 1 ? .5 * n * n * n * n * n : .5 * ((n -= 2) * n * n * n * n + 2), easeInSine: n => 1 - Math.cos(n * Ge), easeOutSine: n => Math.sin(n * Ge), easeInOutSine: n => -.5 * (Math.cos(He * n) - 1), easeInExpo: n => 0 === n ? 0 : Math.pow(2, 10 * (n - 1)), easeOutExpo: n => 1 === n ? 1 : 1 - Math.pow(2, -10 * n), easeInOutExpo: n => Eu(n) ? n : n < .5 ? .5 * Math.pow(2, 10 * (2 * n - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * n - 1))), easeInCirc: n => n >= 1 ? n : -(Math.sqrt(1 - n * n) - 1), easeOutCirc: n => Math.sqrt(1 - (n -= 1) * n), easeInOutCirc: n => (n /= .5) < 1 ? -.5 * (Math.sqrt(1 - n * n) - 1) : .5 * (Math.sqrt(1 - (n -= 2) * n) + 1), easeInElastic: n => Eu(n) ? n : SC(n, .075, .3), easeOutElastic: n => Eu(n) ? n : EC(n, .075, .3), easeInOutElastic: n => Eu(n) ? n : n < .5 ? .5 * SC(2 * n, .1125, .45) : .5 + .5 * EC(2 * n - 1, .1125, .45), easeInBack: n => n * n * (2.70158 * n - 1.70158), easeOutBack: n => (n -= 1) * n * (2.70158 * n + 1.70158) + 1, easeInOutBack(n) { let t = 1.70158; return (n /= .5) < 1 ? n * n * ((1 + (t *= 1.525)) * n - t) * .5 : .5 * ((n -= 2) * n * ((1 + (t *= 1.525)) * n + t) + 2) }, easeInBounce: n => 1 - Ea.easeOutBounce(1 - n), easeOutBounce: n => n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375, easeInOutBounce: n => n < .5 ? .5 * Ea.easeInBounce(2 * n) : .5 * Ea.easeOutBounce(2 * n - 1) + .5 }; function Ma(n) { return n + .5 | 0 } const ts = (n, t, e) => Math.max(Math.min(n, e), t); function Ta(n) { return ts(Ma(2.55 * n), 0, 255) } function ns(n) { return ts(Ma(255 * n), 0, 255) } function Ti(n) { return ts(Ma(n / 2.55) / 100, 0, 1) } function MC(n) { return ts(Ma(100 * n), 0, 100) } const xn = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, zg = [..."0123456789ABCDEF"], j6 = n => zg[15 & n], B6 = n => zg[(240 & n) >> 4] + zg[15 & n], Mu = n => (240 & n) >> 4 == (15 & n); const U6 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function TC(n, t, e) { const i = t * Math.min(e, 1 - e), s = (r, o = (r + n / 30) % 12) => e - i * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [s(0), s(8), s(4)] } function W6(n, t, e) { const i = (s, r = (s + n / 60) % 6) => e - e * t * Math.max(Math.min(r, 4 - r, 1), 0); return [i(5), i(3), i(1)] } function q6(n, t, e) { const i = TC(n, 1, .5); let s; for (t + e > 1 && (s = 1 / (t + e), t *= s, e *= s), s = 0; s < 3; s++)i[s] *= 1 - t - e, i[s] += t; return i } function Ug(n) { const e = n.r / 255, i = n.g / 255, s = n.b / 255, r = Math.max(e, i, s), o = Math.min(e, i, s), a = (r + o) / 2; let l, c, u; return r !== o && (u = r - o, c = a > .5 ? u / (2 - r - o) : u / (r + o), l = function G6(n, t, e, i, s) { return n === s ? (t - e) / i + (t < e ? 6 : 0) : t === s ? (e - n) / i + 2 : (n - t) / i + 4 }(e, i, s, u, r), l = 60 * l + .5), [0 | l, c || 0, a] } function Wg(n, t, e, i) { return (Array.isArray(t) ? n(t[0], t[1], t[2]) : n(t, e, i)).map(ns) } function qg(n, t, e) { return Wg(TC, n, t, e) } function AC(n) { return (n % 360 + 360) % 360 } const kC = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, IC = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; let Tu; const t7 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/, Gg = n => n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055, zr = n => n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4); function Au(n, t, e) { if (n) { let i = Ug(n); i[t] = Math.max(0, Math.min(i[t] + i[t] * e, 0 === t ? 360 : 1)), i = qg(i), n.r = i[0], n.g = i[1], n.b = i[2] } } function PC(n, t) { return n && Object.assign(t || {}, n) } function RC(n) { var t = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(n) ? n.length >= 3 && (t = { r: n[0], g: n[1], b: n[2], a: 255 }, n.length > 3 && (t.a = ns(n[3]))) : (t = PC(n, { r: 0, g: 0, b: 0, a: 1 })).a = ns(t.a), t } function r7(n) { return "r" === n.charAt(0) ? function n7(n) { const t = t7.exec(n); let i, s, r, e = 255; if (t) { if (t[7] !== i) { const o = +t[7]; e = t[8] ? Ta(o) : ts(255 * o, 0, 255) } return i = +t[1], s = +t[3], r = +t[5], i = 255 & (t[2] ? Ta(i) : ts(i, 0, 255)), s = 255 & (t[4] ? Ta(s) : ts(s, 0, 255)), r = 255 & (t[6] ? Ta(r) : ts(r, 0, 255)), { r: i, g: s, b: r, a: e } } }(n) : function Z6(n) { const t = U6.exec(n); let i, e = 255; if (!t) return; t[5] !== i && (e = t[6] ? Ta(+t[5]) : ns(+t[5])); const s = AC(+t[2]), r = +t[3] / 100, o = +t[4] / 100; return i = "hwb" === t[1] ? function K6(n, t, e) { return Wg(q6, n, t, e) }(s, r, o) : "hsv" === t[1] ? function Q6(n, t, e) { return Wg(W6, n, t, e) }(s, r, o) : qg(s, r, o), { r: i[0], g: i[1], b: i[2], a: e } }(n) } class ku { constructor(t) { if (t instanceof ku) return t; const e = typeof t; let i; "object" === e ? i = RC(t) : "string" === e && (i = function H6(n) { var e, t = n.length; return "#" === n[0] && (4 === t || 5 === t ? e = { r: 255 & 17 * xn[n[1]], g: 255 & 17 * xn[n[2]], b: 255 & 17 * xn[n[3]], a: 5 === t ? 17 * xn[n[4]] : 255 } : (7 === t || 9 === t) && (e = { r: xn[n[1]] << 4 | xn[n[2]], g: xn[n[3]] << 4 | xn[n[4]], b: xn[n[5]] << 4 | xn[n[6]], a: 9 === t ? xn[n[7]] << 4 | xn[n[8]] : 255 })), e }(t) || function e7(n) { Tu || (Tu = function J6() { const n = {}, t = Object.keys(IC), e = Object.keys(kC); let i, s, r, o, a; for (i = 0; i < t.length; i++) { for (o = a = t[i], s = 0; s < e.length; s++)r = e[s], a = a.replace(r, kC[r]); r = parseInt(IC[o], 16), n[a] = [r >> 16 & 255, r >> 8 & 255, 255 & r] } return n }(), Tu.transparent = [0, 0, 0, 0]); const t = Tu[n.toLowerCase()]; return t && { r: t[0], g: t[1], b: t[2], a: 4 === t.length ? t[3] : 255 } }(t) || r7(t)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var t = PC(this._rgb); return t && (t.a = Ti(t.a)), t } set rgb(t) { this._rgb = RC(t) } rgbString() { return this._valid ? function i7(n) { return n && (n.a < 255 ? `rgba(${n.r}, ${n.g}, ${n.b}, ${Ti(n.a)})` : `rgb(${n.r}, ${n.g}, ${n.b})`) }(this._rgb) : void 0 } hexString() { return this._valid ? function z6(n) { var t = (n => Mu(n.r) && Mu(n.g) && Mu(n.b) && Mu(n.a))(n) ? j6 : B6; return n ? "#" + t(n.r) + t(n.g) + t(n.b) + ((n, t) => n < 255 ? t(n) : "")(n.a, t) : void 0 }(this._rgb) : void 0 } hslString() { return this._valid ? function X6(n) { if (!n) return; const t = Ug(n), e = t[0], i = MC(t[1]), s = MC(t[2]); return n.a < 255 ? `hsla(${e}, ${i}%, ${s}%, ${Ti(n.a)})` : `hsl(${e}, ${i}%, ${s}%)` }(this._rgb) : void 0 } mix(t, e) { if (t) { const i = this.rgb, s = t.rgb; let r; const o = e === r ? .5 : e, a = 2 * o - 1, l = i.a - s.a, c = ((a * l == -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; r = 1 - c, i.r = 255 & c * i.r + r * s.r + .5, i.g = 255 & c * i.g + r * s.g + .5, i.b = 255 & c * i.b + r * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i } return this } interpolate(t, e) { return t && (this._rgb = function s7(n, t, e) { const i = zr(Ti(n.r)), s = zr(Ti(n.g)), r = zr(Ti(n.b)); return { r: ns(Gg(i + e * (zr(Ti(t.r)) - i))), g: ns(Gg(s + e * (zr(Ti(t.g)) - s))), b: ns(Gg(r + e * (zr(Ti(t.b)) - r))), a: n.a + e * (t.a - n.a) } }(this._rgb, t._rgb, e)), this } clone() { return new ku(this.rgb) } alpha(t) { return this._rgb.a = ns(t), this } clearer(t) { return this._rgb.a *= 1 - t, this } greyscale() { const t = this._rgb, e = Ma(.3 * t.r + .59 * t.g + .11 * t.b); return t.r = t.g = t.b = e, this } opaquer(t) { return this._rgb.a *= 1 + t, this } negate() { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this } lighten(t) { return Au(this._rgb, 2, t), this } darken(t) { return Au(this._rgb, 2, -t), this } saturate(t) { return Au(this._rgb, 1, t), this } desaturate(t) { return Au(this._rgb, 1, -t), this } rotate(t) { return function Y6(n, t) { var e = Ug(n); e[0] = AC(e[0] + t), e = qg(e), n.r = e[0], n.g = e[1], n.b = e[2] }(this._rgb, t), this } } function OC(n) { return new ku(n) } function LC(n) { if (n && "object" == typeof n) { const t = n.toString(); return "[object CanvasPattern]" === t || "[object CanvasGradient]" === t } return !1 } function FC(n) { return LC(n) ? n : OC(n) } function Kg(n) { return LC(n) ? n : OC(n).saturate(.5).darken(.1).hexString() } const Ns = Object.create(null), Qg = Object.create(null); function Aa(n, t) { if (!t) return n; const e = t.split("."); for (let i = 0, s = e.length; i < s; ++i) { const r = e[i]; n = n[r] || (n[r] = Object.create(null)) } return n } function Zg(n, t, e) { return "string" == typeof t ? ba(Aa(n, t), e) : ba(Aa(n, ""), t) } var ge = new class o7 { constructor(t) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = e => e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (e, i) => Kg(i.backgroundColor), this.hoverBorderColor = (e, i) => Kg(i.borderColor), this.hoverColor = (e, i) => Kg(i.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t) } set(t, e) { return Zg(this, t, e) } get(t) { return Aa(this, t) } describe(t, e) { return Zg(Qg, t, e) } override(t, e) { return Zg(Ns, t, e) } route(t, e, i, s) { const r = Aa(this, t), o = Aa(this, i), a = "_" + e; Object.defineProperties(r, { [a]: { value: r[e], writable: !0 }, [e]: { enumerable: !0, get() { const l = this[a], c = o[s]; return pe(l) ? Object.assign({}, c, l) : re(l, c) }, set(l) { this[a] = l } } }) } }({ _scriptable: n => !n.startsWith("on"), _indexable: n => "events" !== n, hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }); function Iu(n, t, e, i, s) { let r = t[s]; return r || (r = t[s] = n.measureText(s).width, e.push(s)), r > i && (i = r), i } function l7(n, t, e, i) { let s = (i = i || {}).data = i.data || {}, r = i.garbageCollect = i.garbageCollect || []; i.font !== t && (s = i.data = {}, r = i.garbageCollect = [], i.font = t), n.save(), n.font = t; let o = 0; const a = e.length; let l, c, u, d, h; for (l = 0; l < a; l++)if (d = e[l], null != d && !0 !== Le(d)) o = Iu(n, s, r, o, d); else if (Le(d)) for (c = 0, u = d.length; c < u; c++)h = d[c], null != h && !Le(h) && (o = Iu(n, s, r, o, h)); n.restore(); const f = r.length / 2; if (f > e.length) { for (l = 0; l < f; l++)delete s[r[l]]; r.splice(0, f) } return o } function js(n, t, e) { const i = n.currentDevicePixelRatio, s = 0 !== e ? Math.max(e / 2, .5) : 0; return Math.round((t - s) * i) / i + s } function NC(n, t) { (t = t || n.getContext("2d")).save(), t.resetTransform(), t.clearRect(0, 0, n.width, n.height), t.restore() } function Pu(n, t, e, i) { let s, r, o, a, l; const c = t.pointStyle, u = t.rotation, d = t.radius; let h = (u || 0) * R6; if (c && "object" == typeof c && (s = c.toString(), "[object HTMLImageElement]" === s || "[object HTMLCanvasElement]" === s)) return n.save(), n.translate(e, i), n.rotate(h), n.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height), void n.restore(); if (!(isNaN(d) || d <= 0)) { switch (n.beginPath(), c) { default: n.arc(e, i, d, 0, Te), n.closePath(); break; case "triangle": n.moveTo(e + Math.sin(h) * d, i - Math.cos(h) * d), h += bC, n.lineTo(e + Math.sin(h) * d, i - Math.cos(h) * d), h += bC, n.lineTo(e + Math.sin(h) * d, i - Math.cos(h) * d), n.closePath(); break; case "rectRounded": l = .516 * d, a = d - l, r = Math.cos(h + Da) * a, o = Math.sin(h + Da) * a, n.arc(e - r, i - o, l, h - He, h - Ge), n.arc(e + o, i - r, l, h - Ge, h), n.arc(e + r, i + o, l, h, h + Ge), n.arc(e - o, i + r, l, h + Ge, h + He), n.closePath(); break; case "rect": if (!u) { a = Math.SQRT1_2 * d, n.rect(e - a, i - a, 2 * a, 2 * a); break } h += Da; case "rectRot": r = Math.cos(h) * d, o = Math.sin(h) * d, n.moveTo(e - r, i - o), n.lineTo(e + o, i - r), n.lineTo(e + r, i + o), n.lineTo(e - o, i + r), n.closePath(); break; case "crossRot": h += Da; case "cross": r = Math.cos(h) * d, o = Math.sin(h) * d, n.moveTo(e - r, i - o), n.lineTo(e + r, i + o), n.moveTo(e + o, i - r), n.lineTo(e - o, i + r); break; case "star": r = Math.cos(h) * d, o = Math.sin(h) * d, n.moveTo(e - r, i - o), n.lineTo(e + r, i + o), n.moveTo(e + o, i - r), n.lineTo(e - o, i + r), h += Da, r = Math.cos(h) * d, o = Math.sin(h) * d, n.moveTo(e - r, i - o), n.lineTo(e + r, i + o), n.moveTo(e + o, i - r), n.lineTo(e - o, i + r); break; case "line": r = Math.cos(h) * d, o = Math.sin(h) * d, n.moveTo(e - r, i - o), n.lineTo(e + r, i + o); break; case "dash": n.moveTo(e, i), n.lineTo(e + Math.cos(h) * d, i + Math.sin(h) * d) }n.fill(), t.borderWidth > 0 && n.stroke() } } function ka(n, t, e) { return e = e || .5, !t || n && n.x > t.left - e && n.x < t.right + e && n.y > t.top - e && n.y < t.bottom + e } function Ru(n, t) { n.save(), n.beginPath(), n.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), n.clip() } function Ou(n) { n.restore() } function c7(n, t, e, i, s) { if (!t) return n.lineTo(e.x, e.y); if ("middle" === s) { const r = (t.x + e.x) / 2; n.lineTo(r, t.y), n.lineTo(r, e.y) } else "after" === s != !!i ? n.lineTo(t.x, e.y) : n.lineTo(e.x, t.y); n.lineTo(e.x, e.y) } function u7(n, t, e, i) { if (!t) return n.lineTo(e.x, e.y); n.bezierCurveTo(i ? t.cp1x : t.cp2x, i ? t.cp1y : t.cp2y, i ? e.cp2x : e.cp1x, i ? e.cp2y : e.cp1y, e.x, e.y) } function Bs(n, t, e, i, s, r = {}) { const o = Le(t) ? t : [t], a = r.strokeWidth > 0 && "" !== r.strokeColor; let l, c; for (n.save(), n.font = s.string, function d7(n, t) { t.translation && n.translate(t.translation[0], t.translation[1]), ye(t.rotation) || n.rotate(t.rotation), t.color && (n.fillStyle = t.color), t.textAlign && (n.textAlign = t.textAlign), t.textBaseline && (n.textBaseline = t.textBaseline) }(n, r), l = 0; l < o.length; ++l)c = o[l], a && (r.strokeColor && (n.strokeStyle = r.strokeColor), ye(r.strokeWidth) || (n.lineWidth = r.strokeWidth), n.strokeText(c, e, i, r.maxWidth)), n.fillText(c, e, i, r.maxWidth), h7(n, e, i, c, r), i += s.lineHeight; n.restore() } function h7(n, t, e, i, s) { if (s.strikethrough || s.underline) { const r = n.measureText(i), o = t - r.actualBoundingBoxLeft, a = t + r.actualBoundingBoxRight, l = e - r.actualBoundingBoxAscent, c = e + r.actualBoundingBoxDescent, u = s.strikethrough ? (l + c) / 2 : c; n.strokeStyle = n.fillStyle, n.beginPath(), n.lineWidth = s.decorationWidth || 2, n.moveTo(o, u), n.lineTo(a, u), n.stroke() } } function Ia(n, t) { const { x: e, y: i, w: s, h: r, radius: o } = t; n.arc(e + o.topLeft, i + o.topLeft, o.topLeft, -Ge, He, !0), n.lineTo(e, i + r - o.bottomLeft), n.arc(e + o.bottomLeft, i + r - o.bottomLeft, o.bottomLeft, He, Ge, !0), n.lineTo(e + s - o.bottomRight, i + r), n.arc(e + s - o.bottomRight, i + r - o.bottomRight, o.bottomRight, Ge, 0, !0), n.lineTo(e + s, i + o.topRight), n.arc(e + s - o.topRight, i + o.topRight, o.topRight, 0, -Ge, !0), n.lineTo(e + o.topLeft, i) } const f7 = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/), p7 = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/); function g7(n, t) { const e = ("" + n).match(f7); if (!e || "normal" === e[1]) return 1.2 * t; switch (n = +e[2], e[3]) { case "px": return n; case "%": n /= 100 }return t * n } const m7 = n => +n || 0; function Yg(n, t) { const e = {}, i = pe(t), s = i ? Object.keys(t) : t, r = pe(n) ? i ? o => re(n[o], n[t[o]]) : o => n[o] : () => n; for (const o of s) e[o] = m7(r(o)); return e } function jC(n) { return Yg(n, { top: "y", right: "x", bottom: "y", left: "x" }) } function Vs(n) { return Yg(n, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Tt(n) { const t = jC(n); return t.width = t.left + t.right, t.height = t.top + t.bottom, t } function dt(n, t) { let e = re((n = n || {}).size, (t = t || ge.font).size); "string" == typeof e && (e = parseInt(e, 10)); let i = re(n.style, t.style); i && !("" + i).match(p7) && (console.warn('Invalid font style specified: "' + i + '"'), i = ""); const s = { family: re(n.family, t.family), lineHeight: g7(re(n.lineHeight, t.lineHeight), e), size: e, style: i, weight: re(n.weight, t.weight), string: "" }; return s.string = function a7(n) { return !n || ye(n.size) || ye(n.family) ? null : (n.style ? n.style + " " : "") + (n.weight ? n.weight + " " : "") + n.size + "px " + n.family }(s), s } function Pa(n, t, e, i) { let r, o, a, s = !0; for (r = 0, o = n.length; r < o; ++r)if (a = n[r], void 0 !== a && (void 0 !== t && "function" == typeof a && (a = a(t), s = !1), void 0 !== e && Le(a) && (a = a[e % a.length], s = !1), void 0 !== a)) return i && !s && (i.cacheable = !1), a } function is(n, t) { return Object.assign(Object.create(n), t) } function Xg(n, t, e) { e = e || (o => n[o] < t); let r, i = n.length - 1, s = 0; for (; i - s > 1;)r = s + i >> 1, e(r) ? s = r : i = r; return { lo: s, hi: i } } const Ai = (n, t, e) => Xg(n, e, i => n[i][t] < e), v7 = (n, t, e) => Xg(n, e, i => n[i][t] >= e), BC = ["push", "pop", "shift", "splice", "unshift"]; function VC(n, t) { const e = n._chartjs; if (!e) return; const i = e.listeners, s = i.indexOf(t); -1 !== s && i.splice(s, 1), !(i.length > 0) && (BC.forEach(r => { delete n[r] }), delete n._chartjs) } function HC(n) { const t = new Set; let e, i; for (e = 0, i = n.length; e < i; ++e)t.add(n[e]); return t.size === i ? n : Array.from(t) } function Jg(n, t = [""], e = n, i, s = (() => n[0])) { wn(i) || (i = qC("_fallback", n)); const r = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: n, _rootScopes: e, _fallback: i, _getTarget: s, override: o => Jg([o, ...n], t, e, i) }; return new Proxy(r, { deleteProperty: (o, a) => (delete o[a], delete o._keys, delete n[0][a], !0), get: (o, a) => zC(o, a, () => function T7(n, t, e, i) { let s; for (const r of t) if (s = qC(w7(r, n), e), wn(s)) return em(n, s) ? tm(e, i, n, s) : s }(a, t, n, o)), getOwnPropertyDescriptor: (o, a) => Reflect.getOwnPropertyDescriptor(o._scopes[0], a), getPrototypeOf: () => Reflect.getPrototypeOf(n[0]), has: (o, a) => GC(o).includes(a), ownKeys: o => GC(o), set(o, a, l) { const c = o._storage || (o._storage = s()); return o[a] = c[a] = l, delete o._keys, !0 } }) } function Ur(n, t, e, i) { const s = { _cacheable: !1, _proxy: n, _context: t, _subProxy: e, _stack: new Set, _descriptors: $C(n, i), setContext: r => Ur(n, r, e, i), override: r => Ur(n.override(r), t, e, i) }; return new Proxy(s, { deleteProperty: (r, o) => (delete r[o], delete n[o], !0), get: (r, o, a) => zC(r, o, () => function D7(n, t, e) { const { _proxy: i, _context: s, _subProxy: r, _descriptors: o } = n; let a = i[t]; return es(a) && o.isScriptable(t) && (a = function x7(n, t, e, i) { const { _proxy: s, _context: r, _subProxy: o, _stack: a } = e; if (a.has(n)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + n); return a.add(n), t = t(r, o || i), a.delete(n), em(n, t) && (t = tm(s._scopes, s, n, t)), t }(t, a, n, e)), Le(a) && a.length && (a = function C7(n, t, e, i) { const { _proxy: s, _context: r, _subProxy: o, _descriptors: a } = e; if (wn(r.index) && i(n)) t = t[r.index % t.length]; else if (pe(t[0])) { const l = t, c = s._scopes.filter(u => u !== l); t = []; for (const u of l) { const d = tm(c, s, n, u); t.push(Ur(d, r, o && o[n], a)) } } return t }(t, a, n, o.isIndexable)), em(t, a) && (a = Ur(a, s, r && r[t], o)), a }(r, o, a)), getOwnPropertyDescriptor: (r, o) => r._descriptors.allKeys ? Reflect.has(n, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(n, o), getPrototypeOf: () => Reflect.getPrototypeOf(n), has: (r, o) => Reflect.has(n, o), ownKeys: () => Reflect.ownKeys(n), set: (r, o, a) => (n[o] = a, delete r[o], !0) }) } function $C(n, t = { scriptable: !0, indexable: !0 }) { const { _scriptable: e = t.scriptable, _indexable: i = t.indexable, _allKeys: s = t.allKeys } = n; return { allKeys: s, scriptable: e, indexable: i, isScriptable: es(e) ? e : () => e, isIndexable: es(i) ? i : () => i } } const w7 = (n, t) => n ? n + Vg(t) : t, em = (n, t) => pe(t) && "adapters" !== n && (null === Object.getPrototypeOf(t) || t.constructor === Object); function zC(n, t, e) { if (Object.prototype.hasOwnProperty.call(n, t)) return n[t]; const i = e(); return n[t] = i, i } function UC(n, t, e) { return es(n) ? n(t, e) : n } const S7 = (n, t) => !0 === n ? t : "string" == typeof n ? Ji(t, n) : void 0; function E7(n, t, e, i, s) { for (const r of t) { const o = S7(e, r); if (o) { n.add(o); const a = UC(o._fallback, e, s); if (wn(a) && a !== e && a !== i) return a } else if (!1 === o && wn(i) && e !== i) return null } return !1 } function tm(n, t, e, i) { const s = t._rootScopes, r = UC(t._fallback, e, i), o = [...n, ...s], a = new Set; a.add(i); let l = WC(a, o, e, r || e, i); return !(null === l || wn(r) && r !== e && (l = WC(a, o, r, l, i), null === l)) && Jg(Array.from(a), [""], s, r, () => function M7(n, t, e) { const i = n._getTarget(); t in i || (i[t] = {}); const s = i[t]; return Le(s) && pe(e) ? e : s }(t, e, i)) } function WC(n, t, e, i, s) { for (; e;)e = E7(n, t, e, i, s); return e } function qC(n, t) { for (const e of t) { if (!e) continue; const i = e[n]; if (wn(i)) return i } } function GC(n) { let t = n._keys; return t || (t = n._keys = function A7(n) { const t = new Set; for (const e of n) for (const i of Object.keys(e).filter(s => !s.startsWith("_"))) t.add(i); return Array.from(t) }(n._scopes)), t } function KC(n, t, e, i) { const { iScale: s } = n, { key: r = "r" } = this._parsing, o = new Array(i); let a, l, c, u; for (a = 0, l = i; a < l; ++a)c = a + e, u = t[c], o[a] = { r: s.parse(Ji(u, r), c) }; return o } const k7 = Number.EPSILON || 1e-14, Wr = (n, t) => t < n.length && !n[t].skip && n[t], QC = n => "x" === n ? "y" : "x"; function I7(n, t, e, i) { const s = n.skip ? t : n, r = t, o = e.skip ? t : e, a = $g(r, s), l = $g(o, r); let c = a / (a + l), u = l / (a + l); c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u; const d = i * c, h = i * u; return { previous: { x: r.x - d * (o.x - s.x), y: r.y - d * (o.y - s.y) }, next: { x: r.x + h * (o.x - s.x), y: r.y + h * (o.y - s.y) } } } function Lu(n, t, e) { return Math.max(Math.min(n, e), t) } function F7(n, t, e, i, s) { let r, o, a, l; if (t.spanGaps && (n = n.filter(c => !c.skip)), "monotone" === t.cubicInterpolationMode) !function O7(n, t = "x") { const e = QC(t), i = n.length, s = Array(i).fill(0), r = Array(i); let o, a, l, c = Wr(n, 0); for (o = 0; o < i; ++o)if (a = l, l = c, c = Wr(n, o + 1), l) { if (c) { const u = c[t] - l[t]; s[o] = 0 !== u ? (c[e] - l[e]) / u : 0 } r[o] = a ? c ? ii(s[o - 1]) !== ii(s[o]) ? 0 : (s[o - 1] + s[o]) / 2 : s[o - 1] : s[o] } (function P7(n, t, e) { const i = n.length; let s, r, o, a, l, c = Wr(n, 0); for (let u = 0; u < i - 1; ++u)if (l = c, c = Wr(n, u + 1), l && c) { if (Ca(t[u], 0, k7)) { e[u] = e[u + 1] = 0; continue } s = e[u] / t[u], r = e[u + 1] / t[u], a = Math.pow(s, 2) + Math.pow(r, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), e[u] = s * o * t[u], e[u + 1] = r * o * t[u]) } })(n, s, r), function R7(n, t, e = "x") { const i = QC(e), s = n.length; let r, o, a, l = Wr(n, 0); for (let c = 0; c < s; ++c) { if (o = a, a = l, l = Wr(n, c + 1), !a) continue; const u = a[e], d = a[i]; o && (r = (u - o[e]) / 3, a[`cp1${e}`] = u - r, a[`cp1${i}`] = d - r * t[c]), l && (r = (l[e] - u) / 3, a[`cp2${e}`] = u + r, a[`cp2${i}`] = d + r * t[c]) } }(n, r, t) }(n, s); else { let c = i ? n[n.length - 1] : n[0]; for (r = 0, o = n.length; r < o; ++r)a = n[r], l = I7(c, a, n[Math.min(r + 1, o - (i ? 0 : 1)) % o], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a } t.capBezierPoints && function L7(n, t) { let e, i, s, r, o, a = ka(n[0], t); for (e = 0, i = n.length; e < i; ++e)o = r, r = a, a = e < i - 1 && ka(n[e + 1], t), r && (s = n[e], o && (s.cp1x = Lu(s.cp1x, t.left, t.right), s.cp1y = Lu(s.cp1y, t.top, t.bottom)), a && (s.cp2x = Lu(s.cp2x, t.left, t.right), s.cp2y = Lu(s.cp2y, t.top, t.bottom))) }(n, e) } function ZC() { return typeof window < "u" && typeof document < "u" } function nm(n) { let t = n.parentNode; return t && "[object ShadowRoot]" === t.toString() && (t = t.host), t } function Fu(n, t, e) { let i; return "string" == typeof n ? (i = parseInt(n, 10), -1 !== n.indexOf("%") && (i = i / 100 * t.parentNode[e])) : i = n, i } const Nu = n => window.getComputedStyle(n, null), j7 = ["top", "right", "bottom", "left"]; function Hs(n, t, e) { const i = {}; e = e ? "-" + e : ""; for (let s = 0; s < 4; s++) { const r = j7[s]; i[r] = parseFloat(n[t + "-" + r + e]) || 0 } return i.width = i.left + i.right, i.height = i.top + i.bottom, i } function $s(n, t) { if ("native" in n) return n; const { canvas: e, currentDevicePixelRatio: i } = t, s = Nu(e), r = "border-box" === s.boxSizing, o = Hs(s, "padding"), a = Hs(s, "border", "width"), { x: l, y: c, box: u } = function V7(n, t) { const e = n.touches, i = e && e.length ? e[0] : n, { offsetX: s, offsetY: r } = i; let a, l, o = !1; if (((n, t, e) => (n > 0 || t > 0) && (!e || !e.shadowRoot))(s, r, n.target)) a = s, l = r; else { const c = t.getBoundingClientRect(); a = i.clientX - c.left, l = i.clientY - c.top, o = !0 } return { x: a, y: l, box: o } }(n, e), d = o.left + (u && a.left), h = o.top + (u && a.top); let { width: f, height: p } = t; return r && (f -= o.width + a.width, p -= o.height + a.height), { x: Math.round((l - d) / f * e.width / i), y: Math.round((c - h) / p * e.height / i) } } const im = n => Math.round(10 * n) / 10; function YC(n, t, e) { const i = t || 1, s = Math.floor(n.height * i), r = Math.floor(n.width * i); n.height = s / i, n.width = r / i; const o = n.canvas; return o.style && (e || !o.style.height && !o.style.width) && (o.style.height = `${n.height}px`, o.style.width = `${n.width}px`), (n.currentDevicePixelRatio !== i || o.height !== s || o.width !== r) && (n.currentDevicePixelRatio = i, o.height = s, o.width = r, n.ctx.setTransform(i, 0, 0, i, 0, 0), !0) } const z7 = function () { let n = !1; try { const t = { get passive() { return n = !0, !1 } }; window.addEventListener("test", null, t), window.removeEventListener("test", null, t) } catch { } return n }(); function XC(n, t) { const e = function N7(n, t) { return Nu(n).getPropertyValue(t) }(n, t), i = e && e.match(/^(\d+)(\.\d+)?px$/); return i ? +i[1] : void 0 } function zs(n, t, e, i) { return { x: n.x + e * (t.x - n.x), y: n.y + e * (t.y - n.y) } } function U7(n, t, e, i) { return { x: n.x + e * (t.x - n.x), y: "middle" === i ? e < .5 ? n.y : t.y : "after" === i ? e < 1 ? n.y : t.y : e > 0 ? t.y : n.y } } function W7(n, t, e, i) { const s = { x: n.cp2x, y: n.cp2y }, r = { x: t.cp1x, y: t.cp1y }, o = zs(n, s, e), a = zs(s, r, e), l = zs(r, t, e), c = zs(o, a, e), u = zs(a, l, e); return zs(c, u, e) } const JC = new Map; function Ra(n, t, e) { return function q7(n, t) { t = t || {}; const e = n + JSON.stringify(t); let i = JC.get(e); return i || (i = new Intl.NumberFormat(n, t), JC.set(e, i)), i }(t, e).format(n) } function qr(n, t, e) { return n ? function (n, t) { return { x: e => n + n + t - e, setWidth(e) { t = e }, textAlign: e => "center" === e ? e : "right" === e ? "left" : "right", xPlus: (e, i) => e - i, leftForLtr: (e, i) => e - i } }(t, e) : { x: n => n, setWidth(n) { }, textAlign: n => n, xPlus: (n, t) => n + t, leftForLtr: (n, t) => n } } function eS(n, t) { let e, i; ("ltr" === t || "rtl" === t) && (e = n.canvas.style, i = [e.getPropertyValue("direction"), e.getPropertyPriority("direction")], e.setProperty("direction", t, "important"), n.prevTextDirection = i) } function tS(n, t) { void 0 !== t && (delete n.prevTextDirection, n.canvas.style.setProperty("direction", t[0], t[1])) } function nS(n) { return "angle" === n ? { between: Sa, compare: F6, normalize: cn } : { between: Mi, compare: (t, e) => t - e, normalize: t => t } } function iS({ start: n, end: t, count: e, loop: i, style: s }) { return { start: n % e, end: t % e, loop: i && (t - n + 1) % e == 0, style: s } } function sS(n, t, e) { if (!e) return [n]; const { property: i, start: s, end: r } = e, o = t.length, { compare: a, between: l, normalize: c } = nS(i), { start: u, end: d, loop: h, style: f } = function Q7(n, t, e) { const { property: i, start: s, end: r } = e, { between: o, normalize: a } = nS(i), l = t.length; let h, f, { start: c, end: u, loop: d } = n; if (d) { for (c += l, u += l, h = 0, f = l; h < f && o(a(t[c % l][i]), s, r); ++h)c--, u--; c %= l, u %= l } return u < c && (u += l), { start: c, end: u, loop: d, style: n.style } }(n, t, e), p = []; let y, b, v, g = !1, m = null; for (let F = u, B = u; F <= d; ++F)b = t[F % o], !b.skip && (y = c(b[i]), y !== v && (g = l(y, s, r), null === m && (g || l(s, v, y) && 0 !== a(s, v)) && (m = 0 === a(y, s) ? F : B), null !== m && (!g || 0 === a(r, y) || l(r, v, y)) && (p.push(iS({ start: m, end: F, loop: h, count: o, style: f })), m = null), B = F, v = y)); return null !== m && p.push(iS({ start: m, end: d, loop: h, count: o, style: f })), p } function rS(n, t) { const e = [], i = n.segments; for (let s = 0; s < i.length; s++) { const r = sS(i[s], n.points, t); r.length && e.push(...r) } return e } function aS(n) { return { backgroundColor: n.backgroundColor, borderCapStyle: n.borderCapStyle, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderJoinStyle: n.borderJoinStyle, borderWidth: n.borderWidth, borderColor: n.borderColor } } function e9(n, t) { return t && JSON.stringify(n) !== JSON.stringify(t) } var ki = new class t9 { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s) { const o = e.duration; e.listeners[s].forEach(a => a({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(i - e.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = pC.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(t = Date.now()) { let e = 0; this._charts.forEach((i, s) => { if (!i.running || !i.items.length) return; const r = i.items; let l, o = r.length - 1, a = !1; for (; o >= 0; --o)l = r[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(t), a = !0) : (r[o] = r[r.length - 1], r.pop()); a && (s.draw(), this._notify(s, i, t, "progress")), r.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += r.length }), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t) { const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i) { this._getAnims(t).listeners[e].push(i) } add(t, e) { !e || !e.length || this._getAnims(t).items.push(...e) } has(t) { return this._getAnims(t).items.length > 0 } start(t) { const e = this._charts.get(t); !e || (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((i, s) => Math.max(i, s._duration), 0), this._refresh()) } running(t) { if (!this._running) return !1; const e = this._charts.get(t); return !(!e || !e.running || !e.items.length) } stop(t) { const e = this._charts.get(t); if (!e || !e.items.length) return; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t) { return this._charts.delete(t) } }; const lS = "transparent", n9 = { boolean: (n, t, e) => e > .5 ? t : n, color(n, t, e) { const i = FC(n || lS), s = i.valid && FC(t || lS); return s && s.valid ? s.mix(i, e).hexString() : t }, number: (n, t, e) => n + (t - n) * e }; class i9 { constructor(t, e, i, s) { const r = e[i]; s = Pa([t.to, s, r, t.from]); const o = Pa([t.from, r, s]); this._active = !0, this._fn = t.fn || n9[t.type || typeof o], this._easing = Ea[t.easing] || Ea.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0 } active() { return this._active } update(t, e, i) { if (this._active) { this._notify(!1); const s = this._target[this._prop], r = i - this._start, o = this._duration - r; this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += r, this._loop = !!t.loop, this._to = Pa([t.to, e, s, t.from]), this._from = Pa([t.from, s, e]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(t) { const e = t - this._start, i = this._duration, s = this._prop, r = this._from, o = this._loop, a = this._to; let l; if (this._active = r !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0); e < 0 ? this._target[s] = r : (l = e / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[s] = this._fn(r, a, l)) } wait() { const t = this._promises || (this._promises = []); return new Promise((e, i) => { t.push({ res: e, rej: i }) }) } _notify(t) { const e = t ? "res" : "rej", i = this._promises || []; for (let s = 0; s < i.length; s++)i[s][e]() } } ge.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }); const o9 = Object.keys(ge.animation); ge.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: n => "onProgress" !== n && "onComplete" !== n && "fn" !== n }), ge.set("animations", { colors: { type: "color", properties: ["color", "borderColor", "backgroundColor"] }, numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius", "tension"] } }), ge.describe("animations", { _fallback: "animation" }), ge.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: n => 0 | n } } } }); class cS { constructor(t, e) { this._chart = t, this._properties = new Map, this.configure(e) } configure(t) { if (!pe(t)) return; const e = this._properties; Object.getOwnPropertyNames(t).forEach(i => { const s = t[i]; if (!pe(s)) return; const r = {}; for (const o of o9) r[o] = s[o]; (Le(s.properties) && s.properties || [i]).forEach(o => { (o === i || !e.has(o)) && e.set(o, r) }) }) } _animateOptions(t, e) { const i = e.options, s = function l9(n, t) { if (!t) return; let e = n.options; if (e) return e.$shared && (n.options = e = Object.assign({}, e, { $shared: !1, $animations: {} })), e; n.options = t }(t, i); if (!s) return []; const r = this._createAnimations(s, i); return i.$shared && function a9(n, t) { const e = [], i = Object.keys(t); for (let s = 0; s < i.length; s++) { const r = n[i[s]]; r && r.active() && e.push(r.wait()) } return Promise.all(e) }(t.options.$animations, i).then(() => { t.options = i }, () => { }), r } _createAnimations(t, e) { const i = this._properties, s = [], r = t.$animations || (t.$animations = {}), o = Object.keys(e), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const c = o[l]; if ("$" === c.charAt(0)) continue; if ("options" === c) { s.push(...this._animateOptions(t, e)); continue } const u = e[c]; let d = r[c]; const h = i.get(c); if (d) { if (h && d.active()) { d.update(h, u, a); continue } d.cancel() } h && h.duration ? (r[c] = d = new i9(h, t, c, u), s.push(d)) : t[c] = u } return s } update(t, e) { if (0 === this._properties.size) return void Object.assign(t, e); const i = this._createAnimations(t, e); return i.length ? (ki.add(this._chart, i), !0) : void 0 } } function uS(n, t) { const e = n && n.options || {}, i = e.reverse, s = void 0 === e.min ? t : 0, r = void 0 === e.max ? t : 0; return { start: i ? r : s, end: i ? s : r } } function dS(n, t) { const e = [], i = n._getSortedDatasetMetas(t); let s, r; for (s = 0, r = i.length; s < r; ++s)e.push(i[s].index); return e } function hS(n, t, e, i = {}) { const s = n.keys, r = "single" === i.mode; let o, a, l, c; if (null !== t) { for (o = 0, a = s.length; o < a; ++o) { if (l = +s[o], l === e) { if (i.all) continue; break } c = n.values[l], Ze(c) && (r || 0 === t || ii(t) === ii(c)) && (t += c) } return t } } function fS(n, t) { const e = n && n.options.stacked; return e || void 0 === e && void 0 !== t.stack } function p9(n, t, e) { const i = n[t] || (n[t] = {}); return i[e] || (i[e] = {}) } function pS(n, t, e, i) { for (const s of t.getMatchingVisibleMetas(i).reverse()) { const r = n[s.index]; if (e && r > 0 || !e && r < 0) return s.index } return null } function gS(n, t) { const { chart: e, _cachedMeta: i } = n, s = e._stacks || (e._stacks = {}), { iScale: r, vScale: o, index: a } = i, l = r.axis, c = o.axis, u = function h9(n, t, e) { return `${n.id}.${t.id}.${e.stack || e.type}` }(r, o, i), d = t.length; let h; for (let f = 0; f < d; ++f) { const p = t[f], { [l]: g, [c]: m } = p; h = (p._stacks || (p._stacks = {}))[c] = p9(s, u, g), h[a] = m, h._top = pS(h, o, !0, i.type), h._bottom = pS(h, o, !1, i.type) } } function sm(n, t) { const e = n.scales; return Object.keys(e).filter(i => e[i].axis === t).shift() } function Oa(n, t) { const e = n.controller.index, i = n.vScale && n.vScale.axis; if (i) { t = t || n._parsed; for (const s of t) { const r = s._stacks; if (!r || void 0 === r[i] || void 0 === r[i][e]) return; delete r[i][e] } } } const rm = n => "reset" === n || "none" === n, mS = (n, t) => t ? n : Object.assign({}, n); let Ii = (() => { class n { constructor(e, i) { this.chart = e, this._ctx = e.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = fS(e.vScale, e), this.addElements() } updateIndex(e) { this.index !== e && Oa(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, i = this._cachedMeta, s = this.getDataset(), r = (h, f, p, g) => "x" === h ? f : "r" === h ? g : p, o = i.xAxisID = re(s.xAxisID, sm(e, "x")), a = i.yAxisID = re(s.yAxisID, sm(e, "y")), l = i.rAxisID = re(s.rAxisID, sm(e, "r")), c = i.indexAxis, u = i.iAxisID = r(c, o, a, l), d = i.vAxisID = r(c, a, o, l); i.xScale = this.getScaleForId(o), i.yScale = this.getScaleForId(a), i.rScale = this.getScaleForId(l), i.iScale = this.getScaleForId(u), i.vScale = this.getScaleForId(d) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const i = this._cachedMeta; return e === i.iScale ? i.vScale : i.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && VC(this._data, this), e._stacked && Oa(e) } _dataCheck() { const e = this.getDataset(), i = e.data || (e.data = []), s = this._data; if (pe(i)) this._data = function d9(n) { const t = Object.keys(n), e = new Array(t.length); let i, s, r; for (i = 0, s = t.length; i < s; ++i)r = t[i], e[i] = { x: r, y: n[r] }; return e }(i); else if (s !== i) { if (s) { VC(s, this); const r = this._cachedMeta; Oa(r), r._parsed = [] } i && Object.isExtensible(i) && function b7(n, t) { n._chartjs ? n._chartjs.listeners.push(t) : (Object.defineProperty(n, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [t] } }), BC.forEach(e => { const i = "_onData" + Vg(e), s = n[e]; Object.defineProperty(n, e, { configurable: !0, enumerable: !1, value(...r) { const o = s.apply(this, r); return n._chartjs.listeners.forEach(a => { "function" == typeof a[i] && a[i](...r) }), o } }) })) }(i, this), this._syncList = [], this._data = i } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const i = this._cachedMeta, s = this.getDataset(); let r = !1; this._dataCheck(); const o = i._stacked; i._stacked = fS(i.vScale, i), i.stack !== s.stack && (r = !0, Oa(i), i.stack = s.stack), this._resyncElements(e), (r || o !== i._stacked) && gS(this, i._parsed) } configure() { const e = this.chart.config, i = e.datasetScopeKeys(this._type), s = e.getOptionScopes(this.getDataset(), i, !0); this.options = e.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, i) { const { _cachedMeta: s, _data: r } = this, { iScale: o, _stacked: a } = s, l = o.axis; let d, h, f, c = 0 === e && i === r.length || s._sorted, u = e > 0 && s._parsed[e - 1]; if (!1 === this._parsing) s._parsed = r, s._sorted = !0, f = r; else { f = Le(r[e]) ? this.parseArrayData(s, r, e, i) : pe(r[e]) ? this.parseObjectData(s, r, e, i) : this.parsePrimitiveData(s, r, e, i); const p = () => null === h[l] || u && h[l] < u[l]; for (d = 0; d < i; ++d)s._parsed[d + e] = h = f[d], c && (p() && (c = !1), u = h); s._sorted = c } a && gS(this, f) } parsePrimitiveData(e, i, s, r) { const { iScale: o, vScale: a } = e, l = o.axis, c = a.axis, u = o.getLabels(), d = o === a, h = new Array(r); let f, p, g; for (f = 0, p = r; f < p; ++f)g = f + s, h[f] = { [l]: d || o.parse(u[g], g), [c]: a.parse(i[g], g) }; return h } parseArrayData(e, i, s, r) { const { xScale: o, yScale: a } = e, l = new Array(r); let c, u, d, h; for (c = 0, u = r; c < u; ++c)d = c + s, h = i[d], l[c] = { x: o.parse(h[0], d), y: a.parse(h[1], d) }; return l } parseObjectData(e, i, s, r) { const { xScale: o, yScale: a } = e, { xAxisKey: l = "x", yAxisKey: c = "y" } = this._parsing, u = new Array(r); let d, h, f, p; for (d = 0, h = r; d < h; ++d)f = d + s, p = i[f], u[d] = { x: o.parse(Ji(p, l), f), y: a.parse(Ji(p, c), f) }; return u } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, i, s) { const o = this._cachedMeta, a = i[e.axis]; return hS({ keys: dS(this.chart, !0), values: i._stacks[e.axis] }, a, o.index, { mode: s }) } updateRangeFromParsed(e, i, s, r) { const o = s[i.axis]; let a = null === o ? NaN : o; const l = r && s._stacks[i.axis]; r && l && (r.values = l, a = hS(r, o, this._cachedMeta.index)), e.min = Math.min(e.min, a), e.max = Math.max(e.max, a) } getMinMax(e, i) { const s = this._cachedMeta, r = s._parsed, o = s._sorted && e === s.iScale, a = r.length, l = this._getOtherScale(e), c = ((n, t, e) => n && !t.hidden && t._stacked && { keys: dS(this.chart, !0), values: null })(i, s), u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: d, max: h } = function f9(n) { const { min: t, max: e, minDefined: i, maxDefined: s } = n.getUserBounds(); return { min: i ? t : Number.NEGATIVE_INFINITY, max: s ? e : Number.POSITIVE_INFINITY } }(l); let f, p; function g() { p = r[f]; const m = p[l.axis]; return !Ze(p[e.axis]) || d > m || h < m } for (f = 0; f < a && (g() || (this.updateRangeFromParsed(u, e, p, c), !o)); ++f); if (o) for (f = a - 1; f >= 0; --f)if (!g()) { this.updateRangeFromParsed(u, e, p, c); break } return u } getAllParsedValues(e) { const i = this._cachedMeta._parsed, s = []; let r, o, a; for (r = 0, o = i.length; r < o; ++r)a = i[r][e.axis], Ze(a) && s.push(a); return s } getMaxOverflow() { return !1 } getLabelAndValue(e) { const i = this._cachedMeta, s = i.iScale, r = i.vScale, o = this.getParsed(e); return { label: s ? "" + s.getLabelForValue(o[s.axis]) : "", value: r ? "" + r.getLabelForValue(o[r.axis]) : "" } } _update(e) { const i = this._cachedMeta; this.update(e || "default"), i._clip = function u9(n) { let t, e, i, s; return pe(n) ? (t = n.top, e = n.right, i = n.bottom, s = n.left) : t = e = i = s = n, { top: t, right: e, bottom: i, left: s, disabled: !1 === n } }(re(this.options.clip, function c9(n, t, e) { if (!1 === e) return !1; const i = uS(n, e), s = uS(t, e); return { top: s.end, right: i.end, bottom: s.start, left: i.start } }(i.xScale, i.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, s = this._cachedMeta, r = s.data || [], o = this.chart.chartArea, a = [], l = this._drawStart || 0, c = this._drawCount || r.length - l, u = this.options.drawActiveElementsOnTop; let d; for (s.dataset && s.dataset.draw(e, o, l, c), d = l; d < l + c; ++d) { const h = r[d]; h.hidden || (h.active && u ? a.push(h) : h.draw(e, o)) } for (d = 0; d < a.length; ++d)a[d].draw(e, o) } getStyle(e, i) { const s = i ? "active" : "default"; return void 0 === e && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(e || 0, s) } getContext(e, i, s) { const r = this.getDataset(); let o; if (e >= 0 && e < this._cachedMeta.data.length) { const a = this._cachedMeta.data[e]; o = a.$context || (a.$context = function m9(n, t, e) { return is(n, { active: !1, dataIndex: t, parsed: void 0, raw: void 0, element: e, index: t, mode: "default", type: "data" }) }(this.getContext(), e, a)), o.parsed = this.getParsed(e), o.raw = r.data[e], o.index = o.dataIndex = e } else o = this.$context || (this.$context = function g9(n, t) { return is(n, { active: !1, dataset: void 0, datasetIndex: t, index: t, mode: "default", type: "dataset" }) }(this.chart.getContext(), this.index)), o.dataset = r, o.index = o.datasetIndex = this.index; return o.active = !!i, o.mode = s, o } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, i) { return this._resolveElementOptions(this.dataElementType.id, i, e) } _resolveElementOptions(e, i = "default", s) { const r = "active" === i, o = this._cachedDataOpts, a = e + "-" + i, l = o[a], c = this.enableOptionSharing && wn(s); if (l) return mS(l, c); const u = this.chart.config, d = u.datasetElementScopeKeys(this._type, e), h = r ? [`${e}Hover`, "hover", e, ""] : [e, ""], f = u.getOptionScopes(this.getDataset(), d), p = Object.keys(ge.elements[e]), m = u.resolveNamedOptions(f, p, () => this.getContext(s, r), h); return m.$shared && (m.$shared = c, o[a] = Object.freeze(mS(m, c))), m } _resolveAnimations(e, i, s) { const r = this.chart, o = this._cachedDataOpts, a = `animation-${i}`, l = o[a]; if (l) return l; let c; if (!1 !== r.options.animation) { const d = this.chart.config, h = d.datasetAnimationScopeKeys(this._type, i), f = d.getOptionScopes(this.getDataset(), h); c = d.createResolver(f, this.getContext(e, s, i)) } const u = new cS(r, c && c.animations); return c && c._cacheable && (o[a] = Object.freeze(u)), u } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, i) { return !i || rm(e) || this.chart._animationsDisabled } updateElement(e, i, s, r) { rm(r) ? Object.assign(e, s) : this._resolveAnimations(i, r).update(e, s) } updateSharedOptions(e, i, s) { e && !rm(i) && this._resolveAnimations(void 0, i).update(e, s) } _setStyle(e, i, s, r) { e.active = r; const o = this.getStyle(i, r); this._resolveAnimations(i, s, r).update(e, { options: !r && this.getSharedOptions(o) || o }) } removeHoverStyle(e, i, s) { this._setStyle(e, s, "active", !1) } setHoverStyle(e, i, s) { this._setStyle(e, s, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const i = this._data, s = this._cachedMeta.data; for (const [l, c, u] of this._syncList) this[l](c, u); this._syncList = []; const r = s.length, o = i.length, a = Math.min(o, r); a && this.parse(0, a), o > r ? this._insertElements(r, o - r, e) : o < r && this._removeElements(o, r - o) } _insertElements(e, i, s = !0) { const r = this._cachedMeta, o = r.data, a = e + i; let l; const c = u => { for (u.length += i, l = u.length - 1; l >= a; l--)u[l] = u[l - i] }; for (c(o), l = e; l < a; ++l)o[l] = new this.dataElementType; this._parsing && c(r._parsed), this.parse(e, i), s && this.updateElements(o, e, i, "reset") } updateElements(e, i, s, r) { } _removeElements(e, i) { const s = this._cachedMeta; if (this._parsing) { const r = s._parsed.splice(e, i); s._stacked && Oa(s, r) } s.data.splice(e, i) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [i, s, r] = e; this[i](s, r) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, i) { i && this._sync(["_removeElements", e, i]); const s = arguments.length - 2; s && this._sync(["_insertElements", e, s]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } return n.defaults = {}, n })(); function _9(n) { const t = n.iScale, e = function v9(n, t) { if (!n._cache.$bar) { const e = n.getMatchingVisibleMetas(t); let i = []; for (let s = 0, r = e.length; s < r; s++)i = i.concat(e[s].controller.getAllParsedValues(n)); n._cache.$bar = HC(i.sort((s, r) => s - r)) } return n._cache.$bar }(t, n.type); let s, r, o, a, i = t._length; const l = () => { 32767 === o || -32768 === o || (wn(a) && (i = Math.min(i, Math.abs(o - a) || i)), a = o) }; for (s = 0, r = e.length; s < r; ++s)o = t.getPixelForValue(e[s]), l(); for (a = void 0, s = 0, r = t.ticks.length; s < r; ++s)o = t.getPixelForTick(s), l(); return i } function yS(n, t, e, i) { return Le(n) ? function D9(n, t, e, i) { const s = e.parse(n[0], i), r = e.parse(n[1], i), o = Math.min(s, r), a = Math.max(s, r); let l = o, c = a; Math.abs(o) > Math.abs(a) && (l = a, c = o), t[e.axis] = c, t._custom = { barStart: l, barEnd: c, start: s, end: r, min: o, max: a } }(n, t, e, i) : t[e.axis] = e.parse(n, i), t } function vS(n, t, e, i) { const s = n.iScale, r = n.vScale, o = s.getLabels(), a = s === r, l = []; let c, u, d, h; for (c = e, u = e + i; c < u; ++c)h = t[c], d = {}, d[s.axis] = a || s.parse(o[c], c), l.push(yS(h, d, r, c)); return l } function om(n) { return n && void 0 !== n.barStart && void 0 !== n.barEnd } function S9(n, t, e, i) { let s = t.borderSkipped; const r = {}; if (!s) return void (n.borderSkipped = r); const { start: o, end: a, reverse: l, top: c, bottom: u } = function C9(n) { let t, e, i, s, r; return n.horizontal ? (t = n.base > n.x, e = "left", i = "right") : (t = n.base < n.y, e = "bottom", i = "top"), t ? (s = "end", r = "start") : (s = "start", r = "end"), { start: e, end: i, reverse: t, top: s, bottom: r } }(n); "middle" === s && e && (n.enableBorderRadius = !0, (e._top || 0) === i ? s = c : (e._bottom || 0) === i ? s = u : (r[_S(u, o, a, l)] = !0, s = c)), r[_S(s, o, a, l)] = !0, n.borderSkipped = r } function _S(n, t, e, i) { return i ? (n = function E9(n, t, e) { return n === t ? e : n === e ? t : n }(n, t, e), n = bS(n, e, t)) : n = bS(n, t, e), n } function bS(n, t, e) { return "start" === n ? t : "end" === n ? e : n } function M9(n, { inflateAmount: t }, e) { n.inflateAmount = "auto" === t ? 1 === e ? .33 : 0 : t } Ii.prototype.datasetElementType = null, Ii.prototype.dataElementType = null; let wS = (() => { class n extends Ii { parsePrimitiveData(e, i, s, r) { return vS(e, i, s, r) } parseArrayData(e, i, s, r) { return vS(e, i, s, r) } parseObjectData(e, i, s, r) { const { iScale: o, vScale: a } = e, { xAxisKey: l = "x", yAxisKey: c = "y" } = this._parsing, u = "x" === o.axis ? l : c, d = "x" === a.axis ? l : c, h = []; let f, p, g, m; for (f = s, p = s + r; f < p; ++f)m = i[f], g = {}, g[o.axis] = o.parse(Ji(m, u), f), h.push(yS(Ji(m, d), g, a, f)); return h } updateRangeFromParsed(e, i, s, r) { super.updateRangeFromParsed(e, i, s, r); const o = s._custom; o && i === this._cachedMeta.vScale && (e.min = Math.min(e.min, o.min), e.max = Math.max(e.max, o.max)) } getMaxOverflow() { return 0 } getLabelAndValue(e) { const i = this._cachedMeta, { iScale: s, vScale: r } = i, o = this.getParsed(e), a = o._custom, l = om(a) ? "[" + a.start + ", " + a.end + "]" : "" + r.getLabelForValue(o[r.axis]); return { label: "" + s.getLabelForValue(o[s.axis]), value: l } } initialize() { this.enableOptionSharing = !0, super.initialize(), this._cachedMeta.stack = this.getDataset().stack } update(e) { const i = this._cachedMeta; this.updateElements(i.data, 0, i.data.length, e) } updateElements(e, i, s, r) { const o = "reset" === r, { index: a, _cachedMeta: { vScale: l } } = this, c = l.getBasePixel(), u = l.isHorizontal(), d = this._getRuler(), h = this.resolveDataElementOptions(i, r), f = this.getSharedOptions(h), p = this.includeOptions(r, f); this.updateSharedOptions(f, r, h); for (let g = i; g < i + s; g++) { const m = this.getParsed(g), y = o || ye(m[l.axis]) ? { base: c, head: c } : this._calculateBarValuePixels(g), b = this._calculateBarIndexPixels(g, d), v = (m._stacks || {})[l.axis], D = { horizontal: u, base: y.base, enableBorderRadius: !v || om(m._custom) || a === v._top || a === v._bottom, x: u ? y.head : b.center, y: u ? b.center : y.head, height: u ? b.size : Math.abs(y.size), width: u ? Math.abs(y.size) : b.size }; p && (D.options = f || this.resolveDataElementOptions(g, e[g].active ? "active" : r)); const x = D.options || e[g].options; S9(D, x, v, a), M9(D, x, d.ratio), this.updateElement(e[g], g, D, r) } } _getStacks(e, i) { const r = this._cachedMeta.iScale, o = r.getMatchingVisibleMetas(this._type), a = r.options.stacked, l = o.length, c = []; let u, d; for (u = 0; u < l; ++u)if (d = o[u], d.controller.options.grouped) { if (typeof i < "u") { const h = d.controller.getParsed(i)[d.controller._cachedMeta.vScale.axis]; if (ye(h) || isNaN(h)) continue } if ((!1 === a || -1 === c.indexOf(d.stack) || void 0 === a && void 0 === d.stack) && c.push(d.stack), d.index === e) break } return c.length || c.push(void 0), c } _getStackCount(e) { return this._getStacks(void 0, e).length } _getStackIndex(e, i, s) { const r = this._getStacks(e, s), o = void 0 !== i ? r.indexOf(i) : -1; return -1 === o ? r.length - 1 : o } _getRuler() { const e = this.options, i = this._cachedMeta, s = i.iScale, r = []; let o, a; for (o = 0, a = i.data.length; o < a; ++o)r.push(s.getPixelForValue(this.getParsed(o)[s.axis], o)); const l = e.barThickness; return { min: l || _9(i), pixels: r, start: s._startPixel, end: s._endPixel, stackCount: this._getStackCount(), scale: s, grouped: e.grouped, ratio: l ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(e) { const { _cachedMeta: { vScale: i, _stacked: s }, options: { base: r, minBarLength: o } } = this, a = r || 0, l = this.getParsed(e), c = l._custom, u = om(c); let p, g, d = l[i.axis], h = 0, f = s ? this.applyStack(i, l, s) : d; f !== d && (h = f - d, f = d), u && (d = c.barStart, f = c.barEnd - c.barStart, 0 !== d && ii(d) !== ii(c.barEnd) && (h = 0), h += d); const m = ye(r) || u ? h : r; let y = i.getPixelForValue(m); if (p = this.chart.getDataVisibility(e) ? i.getPixelForValue(h + f) : y, g = p - y, Math.abs(g) < o) { g = function x9(n, t, e) { return 0 !== n ? ii(n) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1) }(g, i, a) * o, d === a && (y -= g / 2); const b = i.getPixelForDecimal(0), v = i.getPixelForDecimal(1), D = Math.min(b, v), x = Math.max(b, v); y = Math.max(Math.min(y, x), D), p = y + g } if (y === i.getPixelForValue(a)) { const b = ii(g) * i.getLineWidthForValue(a) / 2; y += b, g -= b } return { size: g, base: y, head: p, center: p + g / 2 } } _calculateBarIndexPixels(e, i) { const s = i.scale, r = this.options, o = r.skipNull, a = re(r.maxBarThickness, 1 / 0); let l, c; if (i.grouped) { const u = o ? this._getStackCount(e) : i.stackCount, d = "flex" === r.barThickness ? function w9(n, t, e, i) { const s = t.pixels, r = s[n]; let o = n > 0 ? s[n - 1] : null, a = n < s.length - 1 ? s[n + 1] : null; const l = e.categoryPercentage; null === o && (o = r - (null === a ? t.end - t.start : a - r)), null === a && (a = r + r - o); const c = r - (r - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / i, ratio: e.barPercentage, start: c } }(e, i, r, u) : function b9(n, t, e, i) { const s = e.barThickness; let r, o; return ye(s) ? (r = t.min * e.categoryPercentage, o = e.barPercentage) : (r = s * i, o = 1), { chunk: r / i, ratio: o, start: t.pixels[n] - r / 2 } }(e, i, r, u), h = this._getStackIndex(this.index, this._cachedMeta.stack, o ? e : void 0); l = d.start + d.chunk * h + d.chunk / 2, c = Math.min(a, d.chunk * d.ratio) } else l = s.getPixelForValue(this.getParsed(e)[s.axis], e), c = Math.min(a, i.min * i.ratio); return { base: l - c / 2, head: l + c / 2, center: l, size: c } } draw() { const e = this._cachedMeta, i = e.vScale, s = e.data, r = s.length; let o = 0; for (; o < r; ++o)null !== this.getParsed(o)[i.axis] && s[o].draw(this._ctx) } } return n.id = "bar", n.defaults = { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }, n.overrides = { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }, n })(), DS = (() => { class n extends Ii { initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(e, i, s, r) { const o = super.parsePrimitiveData(e, i, s, r); for (let a = 0; a < o.length; a++)o[a]._custom = this.resolveDataElementOptions(a + s).radius; return o } parseArrayData(e, i, s, r) { const o = super.parseArrayData(e, i, s, r); for (let a = 0; a < o.length; a++)o[a]._custom = re(i[s + a][2], this.resolveDataElementOptions(a + s).radius); return o } parseObjectData(e, i, s, r) { const o = super.parseObjectData(e, i, s, r); for (let a = 0; a < o.length; a++) { const l = i[s + a]; o[a]._custom = re(l && l.r && +l.r, this.resolveDataElementOptions(a + s).radius) } return o } getMaxOverflow() { const e = this._cachedMeta.data; let i = 0; for (let s = e.length - 1; s >= 0; --s)i = Math.max(i, e[s].size(this.resolveDataElementOptions(s)) / 2); return i > 0 && i } getLabelAndValue(e) { const i = this._cachedMeta, { xScale: s, yScale: r } = i, o = this.getParsed(e), a = s.getLabelForValue(o.x), l = r.getLabelForValue(o.y), c = o._custom; return { label: i.label, value: "(" + a + ", " + l + (c ? ", " + c : "") + ")" } } update(e) { const i = this._cachedMeta.data; this.updateElements(i, 0, i.length, e) } updateElements(e, i, s, r) { const o = "reset" === r, { iScale: a, vScale: l } = this._cachedMeta, c = this.resolveDataElementOptions(i, r), u = this.getSharedOptions(c), d = this.includeOptions(r, u), h = a.axis, f = l.axis; for (let p = i; p < i + s; p++) { const g = e[p], m = !o && this.getParsed(p), y = {}, b = y[h] = o ? a.getPixelForDecimal(.5) : a.getPixelForValue(m[h]), v = y[f] = o ? l.getBasePixel() : l.getPixelForValue(m[f]); y.skip = isNaN(b) || isNaN(v), d && (y.options = this.resolveDataElementOptions(p, g.active ? "active" : r), o && (y.options.radius = 0)), this.updateElement(g, p, y, r) } this.updateSharedOptions(u, r, c) } resolveDataElementOptions(e, i) { const s = this.getParsed(e); let r = super.resolveDataElementOptions(e, i); r.$shared && (r = Object.assign({}, r, { $shared: !1 })); const o = r.radius; return "active" !== i && (r.radius = 0), r.radius += re(s && s._custom, o), r } } return n.id = "bubble", n.defaults = { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }, n.overrides = { scales: { x: { type: "linear" }, y: { type: "linear" } }, plugins: { tooltip: { callbacks: { title: () => "" } } } }, n })(), am = (() => { class n extends Ii { constructor(e, i) { super(e, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(e, i) { const s = this.getDataset().data, r = this._cachedMeta; if (!1 === this._parsing) r._parsed = s; else { let a, l, o = c => +s[c]; if (pe(s[e])) { const { key: c = "value" } = this._parsing; o = u => +Ji(s[u], c) } for (a = e, l = e + i; a < l; ++a)r._parsed[a] = o(a) } } _getRotation() { return Vn(this.options.rotation - 90) } _getCircumference() { return Vn(this.options.circumference) } _getRotationExtents() { let e = Te, i = -Te; for (let s = 0; s < this.chart.data.datasets.length; ++s)if (this.chart.isDatasetVisible(s)) { const r = this.chart.getDatasetMeta(s).controller, o = r._getRotation(), a = r._getCircumference(); e = Math.min(e, o), i = Math.max(i, o + a) } return { rotation: e, circumference: i - e } } update(e) { const i = this.chart, { chartArea: s } = i, r = this._cachedMeta, o = r.data, a = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, l = Math.max((Math.min(s.width, s.height) - a) / 2, 0), c = Math.min(((n, t) => "string" == typeof n && n.endsWith("%") ? parseFloat(n) / 100 : n / t)(this.options.cutout, l), 1), u = this._getRingWeight(this.index), { circumference: d, rotation: h } = this._getRotationExtents(), { ratioX: f, ratioY: p, offsetX: g, offsetY: m } = function T9(n, t, e) { let i = 1, s = 1, r = 0, o = 0; if (t < Te) { const a = n, l = a + t, c = Math.cos(a), u = Math.sin(a), d = Math.cos(l), h = Math.sin(l), f = (v, D, x) => Sa(v, a, l, !0) ? 1 : Math.max(D, D * e, x, x * e), p = (v, D, x) => Sa(v, a, l, !0) ? -1 : Math.min(D, D * e, x, x * e), g = f(0, c, d), m = f(Ge, u, h), y = p(He, c, d), b = p(He + Ge, u, h); i = (g - y) / 2, s = (m - b) / 2, r = -(g + y) / 2, o = -(m + b) / 2 } return { ratioX: i, ratioY: s, offsetX: r, offsetY: o } }(h, d, c), v = Math.max(Math.min((s.width - a) / f, (s.height - a) / p) / 2, 0), D = mC(this.options.radius, v), S = (D - Math.max(D * c, 0)) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * D, this.offsetY = m * D, r.total = this.calculateTotal(), this.outerRadius = D - S * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - S * u, 0), this.updateElements(o, 0, o.length, e) } _circumference(e, i) { const s = this.options, r = this._cachedMeta, o = this._getCircumference(); return i && s.animation.animateRotate || !this.chart.getDataVisibility(e) || null === r._parsed[e] || r.data[e].hidden ? 0 : this.calculateCircumference(r._parsed[e] * o / Te) } updateElements(e, i, s, r) { const o = "reset" === r, a = this.chart, l = a.chartArea, d = (l.left + l.right) / 2, h = (l.top + l.bottom) / 2, f = o && a.options.animation.animateScale, p = f ? 0 : this.innerRadius, g = f ? 0 : this.outerRadius, m = this.resolveDataElementOptions(i, r), y = this.getSharedOptions(m), b = this.includeOptions(r, y); let D, v = this._getRotation(); for (D = 0; D < i; ++D)v += this._circumference(D, o); for (D = i; D < i + s; ++D) { const x = this._circumference(D, o), S = e[D], A = { x: d + this.offsetX, y: h + this.offsetY, startAngle: v, endAngle: v + x, circumference: x, outerRadius: g, innerRadius: p }; b && (A.options = y || this.resolveDataElementOptions(D, S.active ? "active" : r)), v += x, this.updateElement(S, D, A, r) } this.updateSharedOptions(y, r, m) } calculateTotal() { const e = this._cachedMeta, i = e.data; let r, s = 0; for (r = 0; r < i.length; r++) { const o = e._parsed[r]; null !== o && !isNaN(o) && this.chart.getDataVisibility(r) && !i[r].hidden && (s += Math.abs(o)) } return s } calculateCircumference(e) { const i = this._cachedMeta.total; return i > 0 && !isNaN(e) ? Te * (Math.abs(e) / i) : 0 } getLabelAndValue(e) { const s = this.chart, r = s.data.labels || [], o = Ra(this._cachedMeta._parsed[e], s.options.locale); return { label: r[e] || "", value: o } } getMaxBorderWidth(e) { let i = 0; const s = this.chart; let r, o, a, l, c; if (!e) for (r = 0, o = s.data.datasets.length; r < o; ++r)if (s.isDatasetVisible(r)) { a = s.getDatasetMeta(r), e = a.data, l = a.controller; break } if (!e) return 0; for (r = 0, o = e.length; r < o; ++r)c = l.resolveDataElementOptions(r), "inner" !== c.borderAlign && (i = Math.max(i, c.borderWidth || 0, c.hoverBorderWidth || 0)); return i } getMaxOffset(e) { let i = 0; for (let s = 0, r = e.length; s < r; ++s) { const o = this.resolveDataElementOptions(s); i = Math.max(i, o.offset || 0, o.hoverOffset || 0) } return i } _getRingWeightOffset(e) { let i = 0; for (let s = 0; s < e; ++s)this.chart.isDatasetVisible(s) && (i += this._getRingWeight(s)); return i } _getRingWeight(e) { return Math.max(re(this.chart.data.datasets[e].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } return n.id = "doughnut", n.defaults = { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }, n.descriptors = { _scriptable: t => "spacing" !== t, _indexable: t => "spacing" !== t }, n.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: i } } = t.legend.options; return e.labels.map((s, r) => { const a = t.getDatasetMeta(0).controller.getStyle(r); return { text: s, fillStyle: a.backgroundColor, strokeStyle: a.borderColor, lineWidth: a.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(r), index: r } }) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } }, tooltip: { callbacks: { title: () => "", label(t) { let e = t.label; const i = ": " + t.formattedValue; return Le(e) ? (e = e.slice(), e[0] += i) : e += i, e } } } } }, n })(), lm = (() => { class n extends Ii { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(e) { const i = this._cachedMeta, { dataset: s, data: r = [], _dataset: o } = i, a = this.chart._animationsDisabled; let { start: l, count: c } = function A9(n, t, e) { const i = t.length; let s = 0, r = i; if (n._sorted) { const { iScale: o, _parsed: a } = n, l = o.axis, { min: c, max: u, minDefined: d, maxDefined: h } = o.getUserBounds(); d && (s = gt(Math.min(Ai(a, o.axis, c).lo, e ? i : Ai(t, l, o.getPixelForValue(c)).lo), 0, i - 1)), r = h ? gt(Math.max(Ai(a, o.axis, u).hi + 1, e ? 0 : Ai(t, l, o.getPixelForValue(u)).hi + 1), s, i) - s : i - s } return { start: s, count: r } }(i, r, a); this._drawStart = l, this._drawCount = c, function k9(n) { const { xScale: t, yScale: e, _scaleRanges: i } = n, s = { xmin: t.min, xmax: t.max, ymin: e.min, ymax: e.max }; if (!i) return n._scaleRanges = s, !0; const r = i.xmin !== t.min || i.xmax !== t.max || i.ymin !== e.min || i.ymax !== e.max; return Object.assign(i, s), r }(i) && (l = 0, c = r.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = r; const u = this.resolveDatasetElementOptions(e); this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(s, void 0, { animated: !a, options: u }, e), this.updateElements(r, l, c, e) } updateElements(e, i, s, r) { const o = "reset" === r, { iScale: a, vScale: l, _stacked: c, _dataset: u } = this._cachedMeta, d = this.resolveDataElementOptions(i, r), h = this.getSharedOptions(d), f = this.includeOptions(r, h), p = a.axis, g = l.axis, { spanGaps: m, segment: y } = this.options, b = xa(m) ? m : Number.POSITIVE_INFINITY, v = this.chart._animationsDisabled || o || "none" === r; let D = i > 0 && this.getParsed(i - 1); for (let x = i; x < i + s; ++x) { const S = e[x], A = this.getParsed(x), F = v ? S : {}, B = ye(A[g]), te = F[p] = a.getPixelForValue(A[p], x), oe = F[g] = o || B ? l.getBasePixel() : l.getPixelForValue(c ? this.applyStack(l, A, c) : A[g], x); F.skip = isNaN(te) || isNaN(oe) || B, F.stop = x > 0 && Math.abs(A[p] - D[p]) > b, y && (F.parsed = A, F.raw = u.data[x]), f && (F.options = h || this.resolveDataElementOptions(x, S.active ? "active" : r)), v || this.updateElement(S, x, F, r), D = A } this.updateSharedOptions(h, r, d) } getMaxOverflow() { const e = this._cachedMeta, i = e.dataset, s = i.options && i.options.borderWidth || 0, r = e.data || []; if (!r.length) return s; const o = r[0].size(this.resolveDataElementOptions(0)), a = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1)); return Math.max(s, o, a) / 2 } draw() { const e = this._cachedMeta; e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw() } } return n.id = "line", n.defaults = { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }, n.overrides = { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }, n })(), xS = (() => { class n extends Ii { constructor(e, i) { super(e, i), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(e) { const s = this.chart, r = s.data.labels || [], o = Ra(this._cachedMeta._parsed[e].r, s.options.locale); return { label: r[e] || "", value: o } } parseObjectData(e, i, s, r) { return KC.bind(this)(e, i, s, r) } update(e) { const i = this._cachedMeta.data; this._updateRadius(), this.updateElements(i, 0, i.length, e) } getMinMax() { const i = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return this._cachedMeta.data.forEach((s, r) => { const o = this.getParsed(r).r; !isNaN(o) && this.chart.getDataVisibility(r) && (o < i.min && (i.min = o), o > i.max && (i.max = o)) }), i } _updateRadius() { const e = this.chart, i = e.chartArea, s = e.options, r = Math.min(i.right - i.left, i.bottom - i.top), o = Math.max(r / 2, 0), l = (o - Math.max(s.cutoutPercentage ? o / 100 * s.cutoutPercentage : 1, 0)) / e.getVisibleDatasetCount(); this.outerRadius = o - l * this.index, this.innerRadius = this.outerRadius - l } updateElements(e, i, s, r) { const o = "reset" === r, a = this.chart, c = a.options.animation, u = this._cachedMeta.rScale, d = u.xCenter, h = u.yCenter, f = u.getIndexAngle(0) - .5 * He; let g, p = f; const m = 360 / this.countVisibleElements(); for (g = 0; g < i; ++g)p += this._computeAngle(g, r, m); for (g = i; g < i + s; g++) { const y = e[g]; let b = p, v = p + this._computeAngle(g, r, m), D = a.getDataVisibility(g) ? u.getDistanceFromCenterForValue(this.getParsed(g).r) : 0; p = v, o && (c.animateScale && (D = 0), c.animateRotate && (b = v = f)); const x = { x: d, y: h, innerRadius: 0, outerRadius: D, startAngle: b, endAngle: v, options: this.resolveDataElementOptions(g, y.active ? "active" : r) }; this.updateElement(y, g, x, r) } } countVisibleElements() { let i = 0; return this._cachedMeta.data.forEach((s, r) => { !isNaN(this.getParsed(r).r) && this.chart.getDataVisibility(r) && i++ }), i } _computeAngle(e, i, s) { return this.chart.getDataVisibility(e) ? Vn(this.resolveDataElementOptions(e, i).angle || s) : 0 } } return n.id = "polarArea", n.defaults = { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }, n.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: i } } = t.legend.options; return e.labels.map((s, r) => { const a = t.getDatasetMeta(0).controller.getStyle(r); return { text: s, fillStyle: a.backgroundColor, strokeStyle: a.borderColor, lineWidth: a.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(r), index: r } }) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } }, tooltip: { callbacks: { title: () => "", label: t => t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }, n })(), CS = (() => { class n extends am { } return n.id = "pie", n.defaults = { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }, n })(), SS = (() => { class n extends Ii { getLabelAndValue(e) { const i = this._cachedMeta.vScale, s = this.getParsed(e); return { label: i.getLabels()[e], value: "" + i.getLabelForValue(s[i.axis]) } } parseObjectData(e, i, s, r) { return KC.bind(this)(e, i, s, r) } update(e) { const i = this._cachedMeta, s = i.dataset, r = i.data || [], o = i.iScale.getLabels(); if (s.points = r, "resize" !== e) { const a = this.resolveDatasetElementOptions(e); this.options.showLine || (a.borderWidth = 0), this.updateElement(s, void 0, { _loop: !0, _fullLoop: o.length === r.length, options: a }, e) } this.updateElements(r, 0, r.length, e) } updateElements(e, i, s, r) { const o = this._cachedMeta.rScale, a = "reset" === r; for (let l = i; l < i + s; l++) { const c = e[l], u = this.resolveDataElementOptions(l, c.active ? "active" : r), d = o.getPointPositionForValue(l, this.getParsed(l).r), h = a ? o.xCenter : d.x, f = a ? o.yCenter : d.y, p = { x: h, y: f, angle: d.angle, skip: isNaN(h) || isNaN(f), options: u }; this.updateElement(c, l, p, r) } } } return n.id = "radar", n.defaults = { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }, n.overrides = { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }, n })(), ES = (() => { class n extends lm { } return n.id = "scatter", n.defaults = { showLine: !1, fill: !1 }, n.overrides = { interaction: { mode: "point" }, plugins: { tooltip: { callbacks: { title: () => "", label: t => "(" + t.label + ", " + t.formattedValue + ")" } } }, scales: { x: { type: "linear" }, y: { type: "linear" } } }, n })(); function Us() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } var P9 = { _date: (() => { class n { constructor(e) { this.options = e || {} } formats() { return Us() } parse(e, i) { return Us() } format(e, i) { return Us() } add(e, i, s) { return Us() } diff(e, i, s) { return Us() } startOf(e, i, s) { return Us() } endOf(e, i) { return Us() } } return n.override = function (t) { Object.assign(n.prototype, t) }, n })() }; function R9(n, t, e, i) { const { controller: s, data: r, _sorted: o } = n, a = s._cachedMeta.iScale; if (a && t === a.axis && "r" !== t && o && r.length) { const l = a._reversePixels ? v7 : Ai; if (!i) return l(r, t, e); if (s._sharedOptions) { const c = r[0], u = "function" == typeof c.getRange && c.getRange(t); if (u) { const d = l(r, t, e - u), h = l(r, t, e + u); return { lo: d.lo, hi: h.hi } } } } return { lo: 0, hi: r.length - 1 } } function La(n, t, e, i, s) { const r = n.getSortedVisibleDatasetMetas(), o = e[t]; for (let a = 0, l = r.length; a < l; ++a) { const { index: c, data: u } = r[a], { lo: d, hi: h } = R9(r[a], t, o, s); for (let f = d; f <= h; ++f) { const p = u[f]; p.skip || i(p, c, f) } } } function cm(n, t, e, i, s) { const r = []; return !s && !n.isPointInArea(t) || La(n, e, t, function (a, l, c) { !s && !ka(a, n.chartArea, 0) || a.inRange(t.x, t.y, i) && r.push({ element: a, datasetIndex: l, index: c }) }, !0), r } function um(n, t, e, i, s, r) { return r || n.isPointInArea(t) ? "r" !== e || i ? function F9(n, t, e, i, s, r) { let o = []; const a = function O9(n) { const t = -1 !== n.indexOf("x"), e = -1 !== n.indexOf("y"); return function (i, s) { const r = t ? Math.abs(i.x - s.x) : 0, o = e ? Math.abs(i.y - s.y) : 0; return Math.sqrt(Math.pow(r, 2) + Math.pow(o, 2)) } }(e); let l = Number.POSITIVE_INFINITY; return La(n, e, t, function c(u, d, h) { const f = u.inRange(t.x, t.y, s); if (i && !f) return; const p = u.getCenterPoint(s); if (!r && !n.isPointInArea(p) && !f) return; const m = a(t, p); m < l ? (o = [{ element: u, datasetIndex: d, index: h }], l = m) : m === l && o.push({ element: u, datasetIndex: d, index: h }) }), o }(n, t, e, i, s, r) : function L9(n, t, e, i) { let s = []; return La(n, e, t, function r(o, a, l) { const { startAngle: c, endAngle: u } = o.getProps(["startAngle", "endAngle"], i), { angle: d } = CC(o, { x: t.x, y: t.y }); Sa(d, c, u) && s.push({ element: o, datasetIndex: a, index: l }) }), s }(n, t, e, s) : [] } function MS(n, t, e, i, s) { const r = [], o = "x" === e ? "inXRange" : "inYRange"; let a = !1; return La(n, e, t, (l, c, u) => { l[o](t[e], s) && (r.push({ element: l, datasetIndex: c, index: u }), a = a || l.inRange(t.x, t.y, s)) }), i && !a ? [] : r } var N9 = { evaluateInteractionItems: La, modes: { index(n, t, e, i) { const s = $s(t, n), r = e.axis || "x", o = e.includeInvisible || !1, a = e.intersect ? cm(n, s, r, i, o) : um(n, s, r, !1, i, o), l = []; return a.length ? (n.getSortedVisibleDatasetMetas().forEach(c => { const u = a[0].index, d = c.data[u]; d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: u }) }), l) : [] }, dataset(n, t, e, i) { const s = $s(t, n), r = e.axis || "xy", o = e.includeInvisible || !1; let a = e.intersect ? cm(n, s, r, i, o) : um(n, s, r, !1, i, o); if (a.length > 0) { const l = a[0].datasetIndex, c = n.getDatasetMeta(l).data; a = []; for (let u = 0; u < c.length; ++u)a.push({ element: c[u], datasetIndex: l, index: u }) } return a }, point: (n, t, e, i) => cm(n, $s(t, n), e.axis || "xy", i, e.includeInvisible || !1), nearest: (n, t, e, i) => um(n, $s(t, n), e.axis || "xy", e.intersect, i, e.includeInvisible || !1), x: (n, t, e, i) => MS(n, $s(t, n), "x", e.intersect, i), y: (n, t, e, i) => MS(n, $s(t, n), "y", e.intersect, i) } }; const TS = ["left", "top", "right", "bottom"]; function Fa(n, t) { return n.filter(e => e.pos === t) } function AS(n, t) { return n.filter(e => -1 === TS.indexOf(e.pos) && e.box.axis === t) } function Na(n, t) { return n.sort((e, i) => { const s = t ? i : e, r = t ? e : i; return s.weight === r.weight ? s.index - r.index : s.weight - r.weight }) } function kS(n, t, e, i) { return Math.max(n[e], t[e]) + Math.max(n[i], t[i]) } function IS(n, t) { n.top = Math.max(n.top, t.top), n.left = Math.max(n.left, t.left), n.bottom = Math.max(n.bottom, t.bottom), n.right = Math.max(n.right, t.right) } function $9(n, t, e, i) { const { pos: s, box: r } = e, o = n.maxPadding; if (!pe(s)) { e.size && (n[s] -= e.size); const d = i[e.stack] || { size: 0, count: 1 }; d.size = Math.max(d.size, e.horizontal ? r.height : r.width), e.size = d.size / d.count, n[s] += e.size } r.getPadding && IS(o, r.getPadding()); const a = Math.max(0, t.outerWidth - kS(o, n, "left", "right")), l = Math.max(0, t.outerHeight - kS(o, n, "top", "bottom")), c = a !== n.w, u = l !== n.h; return n.w = a, n.h = l, e.horizontal ? { same: c, other: u } : { same: u, other: c } } function U9(n, t) { const e = t.maxPadding; return function i(s) { const r = { left: 0, top: 0, right: 0, bottom: 0 }; return s.forEach(o => { r[o] = Math.max(t[o], e[o]) }), r }(n ? ["left", "right"] : ["top", "bottom"]) } function ja(n, t, e, i) { const s = []; let r, o, a, l, c, u; for (r = 0, o = n.length, c = 0; r < o; ++r) { a = n[r], l = a.box, l.update(a.width || t.w, a.height || t.h, U9(a.horizontal, t)); const { same: d, other: h } = $9(t, e, a, i); c |= d && s.length, u = u || h, l.fullSize || s.push(a) } return c && ja(s, t, e, i) || u } function ju(n, t, e, i, s) { n.top = e, n.left = t, n.right = t + i, n.bottom = e + s, n.width = i, n.height = s } function PS(n, t, e, i) { const s = e.padding; let { x: r, y: o } = t; for (const a of n) { const l = a.box, c = i[a.stack] || { count: 1, placed: 0, weight: 1 }, u = a.stackWeight / c.weight || 1; if (a.horizontal) { const d = t.w * u, h = c.size || l.height; wn(c.start) && (o = c.start), l.fullSize ? ju(l, s.left, o, e.outerWidth - s.right - s.left, h) : ju(l, t.left + c.placed, o, d, h), c.start = o, c.placed += d, o = l.bottom } else { const d = t.h * u, h = c.size || l.width; wn(c.start) && (r = c.start), l.fullSize ? ju(l, r, s.top, h, e.outerHeight - s.bottom - s.top) : ju(l, r, t.top + c.placed, h, d), c.start = r, c.placed += d, r = l.right } } t.x = r, t.y = o } ge.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }); var At = { addBox(n, t) { n.boxes || (n.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function () { return [{ z: 0, draw(e) { t.draw(e) } }] }, n.boxes.push(t) }, removeBox(n, t) { const e = n.boxes ? n.boxes.indexOf(t) : -1; -1 !== e && n.boxes.splice(e, 1) }, configure(n, t, e) { t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight }, update(n, t, e, i) { if (!n) return; const s = Tt(n.options.layout.padding), r = Math.max(t - s.width, 0), o = Math.max(e - s.height, 0), a = function H9(n) { const t = function j9(n) { const t = []; let e, i, s, r, o, a; for (e = 0, i = (n || []).length; e < i; ++e)s = n[e], ({ position: r, options: { stack: o, stackWeight: a = 1 } } = s), t.push({ index: e, box: s, pos: r, horizontal: s.isHorizontal(), weight: s.weight, stack: o && r + o, stackWeight: a }); return t }(n), e = Na(t.filter(c => c.box.fullSize), !0), i = Na(Fa(t, "left"), !0), s = Na(Fa(t, "right")), r = Na(Fa(t, "top"), !0), o = Na(Fa(t, "bottom")), a = AS(t, "x"), l = AS(t, "y"); return { fullSize: e, leftAndTop: i.concat(r), rightAndBottom: s.concat(l).concat(o).concat(a), chartArea: Fa(t, "chartArea"), vertical: i.concat(s).concat(l), horizontal: r.concat(o).concat(a) } }(n.boxes), l = a.vertical, c = a.horizontal; xe(n.boxes, g => { "function" == typeof g.beforeLayout && g.beforeLayout() }); const u = l.reduce((g, m) => m.box.options && !1 === m.box.options.display ? g : g + 1, 0) || 1, d = Object.freeze({ outerWidth: t, outerHeight: e, padding: s, availableWidth: r, availableHeight: o, vBoxMaxWidth: r / 2 / u, hBoxMaxHeight: o / 2 }), h = Object.assign({}, s); IS(h, Tt(i)); const f = Object.assign({ maxPadding: h, w: r, h: o, x: s.left, y: s.top }, s), p = function V9(n, t) { const e = function B9(n) { const t = {}; for (const e of n) { const { stack: i, pos: s, stackWeight: r } = e; if (!i || !TS.includes(s)) continue; const o = t[i] || (t[i] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += r } return t }(n), { vBoxMaxWidth: i, hBoxMaxHeight: s } = t; let r, o, a; for (r = 0, o = n.length; r < o; ++r) { a = n[r]; const { fullSize: l } = a.box, c = e[a.stack], u = c && a.stackWeight / c.weight; a.horizontal ? (a.width = u ? u * i : l && t.availableWidth, a.height = s) : (a.width = i, a.height = u ? u * s : l && t.availableHeight) } return e }(l.concat(c), d); ja(a.fullSize, f, d, p), ja(l, f, d, p), ja(c, f, d, p) && ja(l, f, d, p), function z9(n) { const t = n.maxPadding; function e(i) { const s = Math.max(t[i] - n[i], 0); return n[i] += s, s } n.y += e("top"), n.x += e("left"), e("right"), e("bottom") }(f), PS(a.leftAndTop, f, d, p), f.x += f.w, f.y += f.h, PS(a.rightAndBottom, f, d, p), n.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, xe(a.chartArea, g => { const m = g.box; Object.assign(m, n.chartArea), m.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class RS { acquireContext(t, e) { } releaseContext(t) { return !1 } addEventListener(t, e, i) { } removeEventListener(t, e, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(t, e, i, s) { return e = Math.max(0, e || t.width), i = i || t.height, { width: e, height: Math.max(0, s ? Math.floor(e / s) : i) } } isAttached(t) { return !0 } updateConfig(t) { } } class W9 extends RS { acquireContext(t) { return t && t.getContext && t.getContext("2d") || null } updateConfig(t) { t.options.animation = !1 } } const Bu = "$chartjs", q9 = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, OS = n => null === n || "" === n, LS = !!z7 && { passive: !0 }; function Q9(n, t, e) { n.canvas.removeEventListener(t, e, LS) } function Vu(n, t) { for (const e of n) if (e === t || e.contains(t)) return !0 } function Y9(n, t, e) { const i = n.canvas, s = new MutationObserver(r => { let o = !1; for (const a of r) o = o || Vu(a.addedNodes, i), o = o && !Vu(a.removedNodes, i); o && e() }); return s.observe(document, { childList: !0, subtree: !0 }), s } function X9(n, t, e) { const i = n.canvas, s = new MutationObserver(r => { let o = !1; for (const a of r) o = o || Vu(a.removedNodes, i), o = o && !Vu(a.addedNodes, i); o && e() }); return s.observe(document, { childList: !0, subtree: !0 }), s } const Ba = new Map; let FS = 0; function NS() { const n = window.devicePixelRatio; n !== FS && (FS = n, Ba.forEach((t, e) => { e.currentDevicePixelRatio !== n && t() })) } function tj(n, t, e) { const i = n.canvas, s = i && nm(i); if (!s) return; const r = gC((a, l) => { const c = s.clientWidth; e(a, l), c < s.clientWidth && e() }, window), o = new ResizeObserver(a => { const l = a[0], c = l.contentRect.width, u = l.contentRect.height; 0 === c && 0 === u || r(c, u) }); return o.observe(s), function J9(n, t) { Ba.size || window.addEventListener("resize", NS), Ba.set(n, t) }(n, r), o } function dm(n, t, e) { e && e.disconnect(), "resize" === t && function ej(n) { Ba.delete(n), Ba.size || window.removeEventListener("resize", NS) }(n) } function nj(n, t, e) { const i = n.canvas, s = gC(r => { null !== n.ctx && e(function Z9(n, t) { const e = q9[n.type] || n.type, { x: i, y: s } = $s(n, t); return { type: e, chart: t, native: n, x: void 0 !== i ? i : null, y: void 0 !== s ? s : null } }(r, n)) }, n, r => { const o = r[0]; return [o, o.offsetX, o.offsetY] }); return function K9(n, t, e) { n.addEventListener(t, e, LS) }(i, t, s), s } class ij extends RS { acquireContext(t, e) { const i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (function G9(n, t) { const e = n.style, i = n.getAttribute("height"), s = n.getAttribute("width"); if (n[Bu] = { initial: { height: i, width: s, style: { display: e.display, height: e.height, width: e.width } } }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", OS(s)) { const r = XC(n, "width"); void 0 !== r && (n.width = r) } if (OS(i)) if ("" === n.style.height) n.height = n.width / (t || 2); else { const r = XC(n, "height"); void 0 !== r && (n.height = r) } }(t, e), i) : null } releaseContext(t) { const e = t.canvas; if (!e[Bu]) return !1; const i = e[Bu].initial;["height", "width"].forEach(r => { const o = i[r]; ye(o) ? e.removeAttribute(r) : e.setAttribute(r, o) }); const s = i.style || {}; return Object.keys(s).forEach(r => { e.style[r] = s[r] }), e.width = e.width, delete e[Bu], !0 } addEventListener(t, e, i) { this.removeEventListener(t, e), (t.$proxies || (t.$proxies = {}))[e] = ({ attach: Y9, detach: X9, resize: tj }[e] || nj)(t, e, i) } removeEventListener(t, e) { const i = t.$proxies || (t.$proxies = {}), s = i[e]; s && (({ attach: dm, detach: dm, resize: dm }[e] || Q9)(t, e, s), i[e] = void 0) } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(t, e, i, s) { return function $7(n, t, e, i) { const s = Nu(n), r = Hs(s, "margin"), o = Fu(s.maxWidth, n, "clientWidth") || Su, a = Fu(s.maxHeight, n, "clientHeight") || Su, l = function H7(n, t, e) { let i, s; if (void 0 === t || void 0 === e) { const r = nm(n); if (r) { const o = r.getBoundingClientRect(), a = Nu(r), l = Hs(a, "border", "width"), c = Hs(a, "padding"); t = o.width - c.width - l.width, e = o.height - c.height - l.height, i = Fu(a.maxWidth, r, "clientWidth"), s = Fu(a.maxHeight, r, "clientHeight") } else t = n.clientWidth, e = n.clientHeight } return { width: t, height: e, maxWidth: i || Su, maxHeight: s || Su } }(n, t, e); let { width: c, height: u } = l; if ("content-box" === s.boxSizing) { const d = Hs(s, "border", "width"), h = Hs(s, "padding"); c -= h.width + d.width, u -= h.height + d.height } return c = Math.max(0, c - r.width), u = Math.max(0, i ? Math.floor(c / i) : u - r.height), c = im(Math.min(c, o, l.maxWidth)), u = im(Math.min(u, a, l.maxHeight)), c && !u && (u = im(c / 2)), { width: c, height: u } }(t, e, i, s) } isAttached(t) { const e = nm(t); return !(!e || !e.isConnected) } } class Hn { constructor() { this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0 } tooltipPosition(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } hasValue() { return xa(this.x) && xa(this.y) } getProps(t, e) { const i = this.$animations; if (!e || !i) return this; const s = {}; return t.forEach(r => { s[r] = i[r] && i[r].active() ? i[r]._to : this[r] }), s } } Hn.defaults = {}, Hn.defaultRoutes = void 0; const jS = { values: n => Le(n) ? n : "" + n, numeric(n, t, e) { if (0 === n) return "0"; const i = this.chart.options.locale; let s, r = n; if (e.length > 1) { const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value)); (c < 1e-4 || c > 1e15) && (s = "scientific"), r = function rj(n, t) { let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value; return Math.abs(e) >= 1 && n !== Math.floor(n) && (e = n - Math.floor(n)), e }(n, e) } const o = Dn(Math.abs(r)), a = Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: s, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), Ra(n, i, l) }, logarithmic(n, t, e) { if (0 === n) return "0"; const i = n / Math.pow(10, Math.floor(Dn(n))); return 1 === i || 2 === i || 5 === i ? jS.numeric.call(this, n, t, e) : "" } }; var Hu = { formatters: jS }; function $u(n, t, e, i, s) { const r = re(i, 0), o = Math.min(re(s, n.length), n.length); let l, c, u, a = 0; for (e = Math.ceil(e), s && (l = s - i, e = l / Math.floor(l / e)), u = r; u < 0;)a++, u = Math.round(r + a * e); for (c = Math.max(r, 0); c < o; c++)c === u && (t.push(n[c]), a++, u = Math.round(r + a * e)) } ge.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", grace: 0, grid: { display: !0, lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (n, t) => t.lineWidth, tickColor: (n, t) => t.color, offset: !1, borderDash: [], borderDashOffset: 0, borderWidth: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Hu.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), ge.route("scale.ticks", "color", "", "color"), ge.route("scale.grid", "color", "", "borderColor"), ge.route("scale.grid", "borderColor", "", "borderColor"), ge.route("scale.title", "color", "", "color"), ge.describe("scale", { _fallback: !1, _scriptable: n => !n.startsWith("before") && !n.startsWith("after") && "callback" !== n && "parser" !== n, _indexable: n => "borderDash" !== n && "tickBorderDash" !== n }), ge.describe("scales", { _fallback: "scale" }), ge.describe("scale.ticks", { _scriptable: n => "backdropPadding" !== n && "callback" !== n, _indexable: n => "backdropPadding" !== n }); const BS = (n, t, e) => "top" === t || "left" === t ? n[t] + e : n[t] - e; function VS(n, t) { const e = [], i = n.length / t, s = n.length; let r = 0; for (; r < s; r += i)e.push(n[Math.floor(r)]); return e } function fj(n, t, e) { const i = n.ticks.length, s = Math.min(t, i - 1), r = n._startPixel, o = n._endPixel, a = 1e-6; let c, l = n.getPixelForTick(s); if (!(e && (c = 1 === i ? Math.max(l - r, o - l) : 0 === t ? (n.getPixelForTick(1) - l) / 2 : (l - n.getPixelForTick(s - 1)) / 2, l += s < t ? c : -c, l < r - a || l > o + a))) return l } function Va(n) { return n.drawTicks ? n.tickLength : 0 } function HS(n, t) { if (!n.display) return 0; const e = dt(n.font, t), i = Tt(n.padding); return (Le(n.text) ? n.text.length : 1) * e.lineHeight + i.height } function yj(n, t, e) { let i = Bg(n); return (e && "right" !== t || !e && "right" === t) && (i = (n => "left" === n ? "right" : "right" === n ? "left" : n)(i)), i } class Ws extends Hn { constructor(t) { super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(t) { this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax) } parse(t, e) { return t } getUserBounds() { let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this; return t = bn(t, Number.POSITIVE_INFINITY), e = bn(e, Number.NEGATIVE_INFINITY), i = bn(i, Number.POSITIVE_INFINITY), s = bn(s, Number.NEGATIVE_INFINITY), { min: bn(t, i), max: bn(e, s), minDefined: Ze(t), maxDefined: Ze(e) } } getMinMax(t) { let o, { min: e, max: i, minDefined: s, maxDefined: r } = this.getUserBounds(); if (s && r) return { min: e, max: i }; const a = this.getMatchingVisibleMetas(); for (let l = 0, c = a.length; l < c; ++l)o = a[l].controller.getMinMax(this, t), s || (e = Math.min(e, o.min)), r || (i = Math.max(i, o.max)); return e = r && e > i ? i : e, i = s && e > i ? e : i, { min: bn(e, bn(i, e)), max: bn(i, bn(e, i)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { Fe(this.options.beforeUpdate, [this]) } update(t, e, i) { const { beginAtZero: s, grace: r, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function y7(n, t, e) { const { min: i, max: s } = n, r = mC(t, (s - i) / 2), o = (a, l) => e && 0 === a ? 0 : a + l; return { min: o(i, -Math.abs(r)), max: o(s, r) } }(this, r, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? VS(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = function oj(n, t) { const e = n.options.ticks, i = e.maxTicksLimit || function aj(n) { const t = n.options.offset, e = n._tickSize(); return Math.floor(Math.min(n._length / e + (t ? 0 : 1), n._maxLength / e)) }(n), s = e.major.enabled ? function cj(n) { const t = []; let e, i; for (e = 0, i = n.length; e < i; e++)n[e].major && t.push(e); return t }(t) : [], r = s.length, o = s[0], a = s[r - 1], l = []; if (r > i) return function uj(n, t, e, i) { let o, s = 0, r = e[0]; for (i = Math.ceil(i), o = 0; o < n.length; o++)o === r && (t.push(n[o]), s++, r = e[s * i]) }(t, l, s, r / i), l; const c = function lj(n, t, e) { const i = function dj(n) { const t = n.length; let e, i; if (t < 2) return !1; for (i = n[0], e = 1; e < t; ++e)if (n[e] - n[e - 1] !== i) return !1; return i }(n), s = t.length / e; if (!i) return Math.max(s, 1); const r = function O6(n) { const t = [], e = Math.sqrt(n); let i; for (i = 1; i < e; i++)n % i == 0 && (t.push(i), t.push(n / i)); return e === (0 | e) && t.push(e), t.sort((s, r) => s - r).pop(), t }(i); for (let o = 0, a = r.length - 1; o < a; o++) { const l = r[o]; if (l > s) return l } return Math.max(s, 1) }(s, t, i); if (r > 0) { let u, d; const h = r > 1 ? Math.round((a - o) / (r - 1)) : null; for ($u(t, l, c, ye(h) ? 0 : o - h, o), u = 0, d = r - 1; u < d; u++)$u(t, l, c, s[u], s[u + 1]); return $u(t, l, c, a, ye(h) ? t.length : a + h), l } return $u(t, l, c), l }(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e, i, t = this.options.reverse; this.isHorizontal() ? (e = this.left, i = this.right) : (e = this.top, i = this.bottom, t = !t), this._startPixel = e, this._endPixel = i, this._reversePixels = t, this._length = i - e, this._alignToPixels = this.options.alignToPixels } afterUpdate() { Fe(this.options.afterUpdate, [this]) } beforeSetDimensions() { Fe(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { Fe(this.options.afterSetDimensions, [this]) } _callHooks(t) { this.chart.notifyPlugins(t, this.getContext()), Fe(this.options[t], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { Fe(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(t) { const e = this.options.ticks; let i, s, r; for (i = 0, s = t.length; i < s; i++)r = t[i], r.label = Fe(e.callback, [r.value, i, t], this) } afterTickToLabelConversion() { Fe(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { Fe(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const t = this.options, e = t.ticks, i = this.ticks.length, s = e.minRotation || 0, r = e.maxRotation; let a, l, c, o = s; if (!this._isVisible() || !e.display || s >= r || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s); const u = this._getLabelSizes(), d = u.widest.width, h = u.highest.height, f = gt(this.chart.width - d, 0, this.maxWidth); a = t.offset ? this.maxWidth / i : f / (i - 1), d + 6 > a && (a = f / (i - (t.offset ? .5 : 1)), l = this.maxHeight - Va(t.grid) - e.padding - HS(t.title, this.chart.options.font), c = Math.sqrt(d * d + h * h), o = Hg(Math.min(Math.asin(gt((u.highest.height + 6) / a, -1, 1)), Math.asin(gt(l / c, -1, 1)) - Math.asin(gt(h / c, -1, 1)))), o = Math.max(s, Math.min(r, o))), this.labelRotation = o } afterCalculateLabelRotation() { Fe(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { Fe(this.options.beforeFit, [this]) } fit() { const t = { width: 0, height: 0 }, { chart: e, options: { ticks: i, title: s, grid: r } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = HS(s, e.options.font); if (a ? (t.width = this.maxWidth, t.height = Va(r) + l) : (t.height = this.maxHeight, t.width = Va(r) + l), i.display && this.ticks.length) { const { first: c, last: u, widest: d, highest: h } = this._getLabelSizes(), f = 2 * i.padding, p = Vn(this.labelRotation), g = Math.cos(p), m = Math.sin(p); a ? t.height = Math.min(this.maxHeight, t.height + (i.mirror ? 0 : m * d.width + g * h.height) + f) : t.width = Math.min(this.maxWidth, t.width + (i.mirror ? 0 : g * d.width + m * h.height) + f), this._calculatePadding(c, u, m, g) } } this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom) } _calculatePadding(t, e, i, s) { const { ticks: { align: r, padding: o }, position: a } = this.options, l = 0 !== this.labelRotation, c = "top" !== a && "x" === this.axis; if (this.isHorizontal()) { const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1); let h = 0, f = 0; l ? c ? (h = s * t.width, f = i * e.height) : (h = i * t.height, f = s * e.width) : "start" === r ? f = e.width : "end" === r ? h = t.width : "inner" !== r && (h = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((h - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((f - d + o) * this.width / (this.width - d), 0) } else { let u = e.height / 2, d = t.height / 2; "start" === r ? (u = 0, d = t.height) : "end" === r && (u = e.height, d = 0), this.paddingTop = u + o, this.paddingBottom = d + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { Fe(this.options.afterFit, [this]) } isHorizontal() { const { axis: t, position: e } = this.options; return "top" === e || "bottom" === e || "x" === t } isFullSize() { return this.options.fullSize } _convertTicksToLabels(t) { let e, i; for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)ye(t[e].label) && (t.splice(e, 1), i--, e--); this.afterTickToLabelConversion() } _getLabelSizes() { let t = this._labelSizes; if (!t) { const e = this.options.ticks.sampleSize; let i = this.ticks; e < i.length && (i = VS(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length) } return t } _computeLabelSizes(t, e) { const { ctx: i, _longestTextCache: s } = this, r = [], o = []; let c, u, d, h, f, p, g, m, y, b, v, a = 0, l = 0; for (c = 0; c < e; ++c) { if (h = t[c].label, f = this._resolveTickFontOptions(c), i.font = p = f.string, g = s[p] = s[p] || { data: {}, gc: [] }, m = f.lineHeight, y = b = 0, ye(h) || Le(h)) { if (Le(h)) for (u = 0, d = h.length; u < d; ++u)v = h[u], !ye(v) && !Le(v) && (y = Iu(i, g.data, g.gc, y, v), b += m) } else y = Iu(i, g.data, g.gc, y, h), b = m; r.push(y), o.push(b), a = Math.max(y, a), l = Math.max(b, l) } !function pj(n, t) { xe(n, e => { const i = e.gc, s = i.length / 2; let r; if (s > t) { for (r = 0; r < s; ++r)delete e.data[i[r]]; i.splice(0, s) } }) }(s, e); const D = r.indexOf(a), x = o.indexOf(l), S = A => ({ width: r[A] || 0, height: o[A] || 0 }); return { first: S(0), last: S(e - 1), widest: S(D), highest: S(x), widths: r, heights: o } } getLabelForValue(t) { return t } getPixelForValue(t, e) { return NaN } getValueForPixel(t) { } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getPixelForDecimal(t) { this._reversePixels && (t = 1 - t); const e = this._startPixel + t * this._length; return function N6(n) { return gt(n, -32768, 32767) }(this._alignToPixels ? js(this.chart, e, 0) : e) } getDecimalForPixel(t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: t, max: e } = this; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 } getContext(t) { const e = this.ticks || []; if (t >= 0 && t < e.length) { const i = e[t]; return i.$context || (i.$context = function mj(n, t, e) { return is(n, { tick: e, index: t, type: "tick" }) }(this.getContext(), t, i)) } return this.$context || (this.$context = function gj(n, t) { return is(n, { scale: t, type: "scale" }) }(this.chart.getContext(), this)) } _tickSize() { const t = this.options.ticks, e = Vn(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), r = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = r ? r.widest.width + o : 0, l = r ? r.highest.height + o : 0; return this.isHorizontal() ? l * i > a * s ? a / i : l / s : l * s < a * i ? l / i : a / s } _isVisible() { const t = this.options.display; return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(t) { const e = this.axis, i = this.chart, s = this.options, { grid: r, position: o } = s, a = r.offset, l = this.isHorizontal(), u = this.ticks.length + (a ? 1 : 0), d = Va(r), h = [], f = r.setContext(this.getContext()), p = f.drawBorder ? f.borderWidth : 0, g = p / 2, m = function (ee) { return js(i, ee, p) }; let y, b, v, D, x, S, A, F, B, te, oe, J; if ("top" === o) y = m(this.bottom), S = this.bottom - d, F = y - g, te = m(t.top) + g, J = t.bottom; else if ("bottom" === o) y = m(this.top), te = t.top, J = m(t.bottom) - g, S = y + g, F = this.top + d; else if ("left" === o) y = m(this.right), x = this.right - d, A = y - g, B = m(t.left) + g, oe = t.right; else if ("right" === o) y = m(this.left), B = t.left, oe = m(t.right) - g, x = y + g, A = this.left + d; else if ("x" === e) { if ("center" === o) y = m((t.top + t.bottom) / 2 + .5); else if (pe(o)) { const ee = Object.keys(o)[0]; y = m(this.chart.scales[ee].getPixelForValue(o[ee])) } te = t.top, J = t.bottom, S = y + g, F = S + d } else if ("y" === e) { if ("center" === o) y = m((t.left + t.right) / 2); else if (pe(o)) { const ee = Object.keys(o)[0]; y = m(this.chart.scales[ee].getPixelForValue(o[ee])) } x = y - g, A = x - d, B = t.left, oe = t.right } const ve = re(s.ticks.maxTicksLimit, u), Ke = Math.max(1, Math.ceil(u / ve)); for (b = 0; b < u; b += Ke) { const ee = r.setContext(this.getContext(b)), P = ee.lineWidth, H = ee.color, $ = r.borderDash || [], ce = ee.borderDashOffset, je = ee.tickWidth, Ht = ee.tickColor, st = ee.tickBorderDash || [], Kt = ee.tickBorderDashOffset; v = fj(this, b, a), void 0 !== v && (D = js(i, v, P), l ? x = A = B = oe = D : S = F = te = J = D, h.push({ tx1: x, ty1: S, tx2: A, ty2: F, x1: B, y1: te, x2: oe, y2: J, width: P, color: H, borderDash: $, borderDashOffset: ce, tickWidth: je, tickColor: Ht, tickBorderDash: st, tickBorderDashOffset: Kt })) } return this._ticksLength = u, this._borderValue = y, h } _computeLabelItems(t) { const e = this.axis, i = this.options, { position: s, ticks: r } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = r, h = Va(i.grid), f = h + u, p = d ? -u : f, g = -Vn(this.labelRotation), m = []; let y, b, v, D, x, S, A, F, B, te, oe, J, ve = "middle"; if ("top" === s) S = this.bottom - p, A = this._getXAxisLabelAlignment(); else if ("bottom" === s) S = this.top + p, A = this._getXAxisLabelAlignment(); else if ("left" === s) { const ee = this._getYAxisLabelAlignment(h); A = ee.textAlign, x = ee.x } else if ("right" === s) { const ee = this._getYAxisLabelAlignment(h); A = ee.textAlign, x = ee.x } else if ("x" === e) { if ("center" === s) S = (t.top + t.bottom) / 2 + f; else if (pe(s)) { const ee = Object.keys(s)[0]; S = this.chart.scales[ee].getPixelForValue(s[ee]) + f } A = this._getXAxisLabelAlignment() } else if ("y" === e) { if ("center" === s) x = (t.left + t.right) / 2 - f; else if (pe(s)) { const ee = Object.keys(s)[0]; x = this.chart.scales[ee].getPixelForValue(s[ee]) } A = this._getYAxisLabelAlignment(h).textAlign } "y" === e && ("start" === l ? ve = "top" : "end" === l && (ve = "bottom")); const Ke = this._getLabelSizes(); for (y = 0, b = a.length; y < b; ++y) { v = a[y], D = v.label; const ee = r.setContext(this.getContext(y)); F = this.getPixelForTick(y) + r.labelOffset, B = this._resolveTickFontOptions(y), te = B.lineHeight, oe = Le(D) ? D.length : 1; const P = oe / 2, H = ee.color, $ = ee.textStrokeColor, ce = ee.textStrokeWidth; let Ht, je = A; if (o ? (x = F, "inner" === A && (je = y === b - 1 ? this.options.reverse ? "left" : "right" : 0 === y ? this.options.reverse ? "right" : "left" : "center"), J = "top" === s ? "near" === c || 0 !== g ? -oe * te + te / 2 : "center" === c ? -Ke.highest.height / 2 - P * te + te : te / 2 - Ke.highest.height : "near" === c || 0 !== g ? te / 2 : "center" === c ? Ke.highest.height / 2 - P * te : Ke.highest.height - oe * te, d && (J *= -1)) : (S = F, J = (1 - oe) * te / 2), ee.showLabelBackdrop) { const st = Tt(ee.backdropPadding), Kt = Ke.heights[y], Ae = Ke.widths[y]; let Qr = S + J - st.top, Ka = x - st.left; switch (ve) { case "middle": Qr -= Kt / 2; break; case "bottom": Qr -= Kt }switch (A) { case "center": Ka -= Ae / 2; break; case "right": Ka -= Ae }Ht = { left: Ka, top: Qr, width: Ae + st.width, height: Kt + st.height, color: ee.backdropColor } } m.push({ rotation: g, label: D, font: B, color: H, strokeColor: $, strokeWidth: ce, textOffset: J, textAlign: je, textBaseline: ve, translation: [x, S], backdrop: Ht }) } return m } _getXAxisLabelAlignment() { const { position: t, ticks: e } = this.options; if (-Vn(this.labelRotation)) return "top" === t ? "left" : "right"; let s = "center"; return "start" === e.align ? s = "left" : "end" === e.align ? s = "right" : "inner" === e.align && (s = "inner"), s } _getYAxisLabelAlignment(t) { const { position: e, ticks: { crossAlign: i, mirror: s, padding: r } } = this.options, a = t + r, l = this._getLabelSizes().widest.width; let c, u; return "left" === e ? s ? (u = this.right + r, "near" === i ? c = "left" : "center" === i ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, "near" === i ? c = "right" : "center" === i ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : "right" === e ? s ? (u = this.left + r, "near" === i ? c = "right" : "center" === i ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, "near" === i ? c = "left" : "center" === i ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", { textAlign: c, x: u } } _computeLabelArea() { if (this.options.ticks.mirror) return; const t = this.chart, e = this.options.position; return "left" === e || "right" === e ? { top: 0, left: this.left, bottom: t.height, right: this.right } : "top" === e || "bottom" === e ? { top: this.top, left: 0, bottom: this.bottom, right: t.width } : void 0 } drawBackground() { const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: r, height: o } = this; e && (t.save(), t.fillStyle = e, t.fillRect(i, s, r, o), t.restore()) } getLineWidthForValue(t) { const e = this.options.grid; if (!this._isVisible() || !e.display) return 0; const s = this.ticks.findIndex(r => r.value === t); return s >= 0 ? e.setContext(this.getContext(s)).lineWidth : 0 } drawGrid(t) { const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)); let r, o; const a = (l, c, u) => { !u.width || !u.color || (i.save(), i.lineWidth = u.width, i.strokeStyle = u.color, i.setLineDash(u.borderDash || []), i.lineDashOffset = u.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore()) }; if (e.display) for (r = 0, o = s.length; r < o; ++r) { const l = s[r]; e.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), e.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: t, ctx: e, options: { grid: i } } = this, s = i.setContext(this.getContext()), r = i.drawBorder ? s.borderWidth : 0; if (!r) return; const o = i.setContext(this.getContext(0)).lineWidth, a = this._borderValue; let l, c, u, d; this.isHorizontal() ? (l = js(t, this.left, r) - r / 2, c = js(t, this.right, o) + o / 2, u = d = a) : (u = js(t, this.top, r) - r / 2, d = js(t, this.bottom, o) + o / 2, l = c = a), e.save(), e.lineWidth = s.borderWidth, e.strokeStyle = s.borderColor, e.beginPath(), e.moveTo(l, u), e.lineTo(c, d), e.stroke(), e.restore() } drawLabels(t) { if (!this.options.ticks.display) return; const i = this.ctx, s = this._computeLabelArea(); s && Ru(i, s); const r = this._labelItems || (this._labelItems = this._computeLabelItems(t)); let o, a; for (o = 0, a = r.length; o < a; ++o) { const l = r[o], c = l.font, u = l.label; l.backdrop && (i.fillStyle = l.backdrop.color, i.fillRect(l.backdrop.left, l.backdrop.top, l.backdrop.width, l.backdrop.height)), Bs(i, u, 0, l.textOffset, c, l) } s && Ou(i) } drawTitle() { const { ctx: t, options: { position: e, title: i, reverse: s } } = this; if (!i.display) return; const r = dt(i.font), o = Tt(i.padding), a = i.align; let l = r.lineHeight / 2; "bottom" === e || "center" === e || pe(e) ? (l += o.bottom, Le(i.text) && (l += r.lineHeight * (i.text.length - 1))) : l += o.top; const { titleX: c, titleY: u, maxWidth: d, rotation: h } = function vj(n, t, e, i) { const { top: s, left: r, bottom: o, right: a, chart: l } = n, { chartArea: c, scales: u } = l; let h, f, p, d = 0; const g = o - s, m = a - r; if (n.isHorizontal()) { if (f = Mt(i, r, a), pe(e)) { const y = Object.keys(e)[0]; p = u[y].getPixelForValue(e[y]) + g - t } else p = "center" === e ? (c.bottom + c.top) / 2 + g - t : BS(n, e, t); h = a - r } else { if (pe(e)) { const y = Object.keys(e)[0]; f = u[y].getPixelForValue(e[y]) - m + t } else f = "center" === e ? (c.left + c.right) / 2 - m + t : BS(n, e, t); p = Mt(i, o, s), d = "left" === e ? -Ge : Ge } return { titleX: f, titleY: p, maxWidth: h, rotation: d } }(this, l, e, a); Bs(t, i.text, 0, 0, r, { color: i.color, maxWidth: d, rotation: h, textAlign: yj(a, e, s), textBaseline: "middle", translation: [c, u] }) } draw(t) { !this._isVisible() || (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t)) } _layers() { const t = this.options, e = t.ticks && t.ticks.z || 0, i = re(t.grid && t.grid.z, -1); return this._isVisible() && this.draw === Ws.prototype.draw ? [{ z: i, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: i + 1, draw: () => { this.drawBorder() } }, { z: e, draw: s => { this.drawLabels(s) } }] : [{ z: e, draw: s => { this.draw(s) } }] } getMatchingVisibleMetas(t) { const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", s = []; let r, o; for (r = 0, o = e.length; r < o; ++r) { const a = e[r]; a[i] === this.id && (!t || a.type === t) && s.push(a) } return s } _resolveTickFontOptions(t) { return dt(this.options.ticks.setContext(this.getContext(t)).font) } _maxDigits() { const t = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / t } } class zu { constructor(t, e, i) { this.type = t, this.scope = e, this.override = i, this.items = Object.create(null) } isForType(t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } register(t) { const e = Object.getPrototypeOf(t); let i; (function wj(n) { return "id" in n && "defaults" in n })(e) && (i = this.register(e)); const s = this.items, r = t.id, o = this.scope + "." + r; if (!r) throw new Error("class does not have id: " + t); return r in s || (s[r] = t, function _j(n, t, e) { const i = ba(Object.create(null), [e ? ge.get(e) : {}, ge.get(t), n.defaults]); ge.set(t, i), n.defaultRoutes && function bj(n, t) { Object.keys(t).forEach(e => { const i = e.split("."), s = i.pop(), r = [n].concat(i).join("."), o = t[e].split("."), a = o.pop(), l = o.join("."); ge.route(r, s, l, a) }) }(t, n.defaultRoutes), n.descriptors && ge.describe(t, n.descriptors) }(t, o, i), this.override && ge.override(t.id, t.overrides)), o } get(t) { return this.items[t] } unregister(t) { const e = this.items, i = t.id, s = this.scope; i in e && delete e[i], s && i in ge[s] && (delete ge[s][i], this.override && delete Ns[i]) } } var Pi = new class Dj { constructor() { this.controllers = new zu(Ii, "datasets", !0), this.elements = new zu(Hn, "elements"), this.plugins = new zu(Object, "plugins"), this.scales = new zu(Ws, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...t) { this._each("register", t) } remove(...t) { this._each("unregister", t) } addControllers(...t) { this._each("register", t, this.controllers) } addElements(...t) { this._each("register", t, this.elements) } addPlugins(...t) { this._each("register", t, this.plugins) } addScales(...t) { this._each("register", t, this.scales) } getController(t) { return this._get(t, this.controllers, "controller") } getElement(t) { return this._get(t, this.elements, "element") } getPlugin(t) { return this._get(t, this.plugins, "plugin") } getScale(t) { return this._get(t, this.scales, "scale") } removeControllers(...t) { this._each("unregister", t, this.controllers) } removeElements(...t) { this._each("unregister", t, this.elements) } removePlugins(...t) { this._each("unregister", t, this.plugins) } removeScales(...t) { this._each("unregister", t, this.scales) } _each(t, e, i) { [...e].forEach(s => { const r = i || this._getRegistryForType(s); i || r.isForType(s) || r === this.plugins && s.id ? this._exec(t, r, s) : xe(s, o => { const a = i || this._getRegistryForType(o); this._exec(t, a, o) }) }) } _exec(t, e, i) { const s = Vg(t); Fe(i["before" + s], [], i), e[t](i), Fe(i["after" + s], [], i) } _getRegistryForType(t) { for (let e = 0; e < this._typedRegistries.length; e++) { const i = this._typedRegistries[e]; if (i.isForType(t)) return i } return this.plugins } _get(t, e, i) { const s = e.get(t); if (void 0 === s) throw new Error('"' + t + '" is not a registered ' + i + "."); return s } }; class xj { constructor() { this._init = [] } notify(t, e, i, s) { "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")); const r = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(r, t, e, i); return "afterDestroy" === e && (this._notify(r, t, "stop"), this._notify(this._init, t, "uninstall")), o } _notify(t, e, i, s) { s = s || {}; for (const r of t) { const o = r.plugin; if (!1 === Fe(o[i], [e, s, r.options], o) && s.cancelable) return !1 } return !0 } invalidate() { ye(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), e } _createDescriptors(t, e) { const i = t && t.config, s = re(i.options && i.options.plugins, {}), r = function Cj(n) { const t = [], e = Object.keys(Pi.plugins.items); for (let s = 0; s < e.length; s++)t.push(Pi.getPlugin(e[s])); const i = n.plugins || []; for (let s = 0; s < i.length; s++) { const r = i[s]; -1 === t.indexOf(r) && t.push(r) } return t }(i); return !1 !== s || e ? function Ej(n, t, e, i) { const s = [], r = n.getContext(); for (let o = 0; o < t.length; o++) { const a = t[o], c = Sj(e[a.id], i); null !== c && s.push({ plugin: a, options: Mj(n.config, a, c, r) }) } return s }(t, r, s, e) : [] } _notifyStateChanges(t) { const e = this._oldCache || [], i = this._cache, s = (r, o) => r.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start") } } function Sj(n, t) { return t || !1 !== n ? !0 === n ? {} : n : null } function Mj(n, t, e, i) { const s = n.pluginScopeKeys(t), r = n.getOptionScopes(e, s); return n.createResolver(r, i, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function hm(n, t) { return ((t.datasets || {})[n] || {}).indexAxis || t.indexAxis || (ge.datasets[n] || {}).indexAxis || "x" } function fm(n, t) { return "x" === n || "y" === n ? n : t.axis || function kj(n) { return "top" === n || "bottom" === n ? "x" : "left" === n || "right" === n ? "y" : void 0 }(t.position) || n.charAt(0).toLowerCase() } function $S(n) { const t = n.options || (n.options = {}); t.plugins = re(t.plugins, {}), t.scales = function Ij(n, t) { const e = Ns[n.type] || { scales: {} }, i = t.scales || {}, s = hm(n.type, t), r = Object.create(null), o = Object.create(null); return Object.keys(i).forEach(a => { const l = i[a]; if (!pe(l)) return console.error(`Invalid scale configuration for scale: ${a}`); if (l._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${a}`); const c = fm(a, l), u = function Aj(n, t) { return n === t ? "_index_" : "_value_" }(c, s), d = e.scales || {}; r[c] = r[c] || a, o[a] = wa(Object.create(null), [{ axis: c }, l, d[c], d[u]]) }), n.data.datasets.forEach(a => { const l = a.type || n.type, c = a.indexAxis || hm(l, t), d = (Ns[l] || {}).scales || {}; Object.keys(d).forEach(h => { const f = function Tj(n, t) { let e = n; return "_index_" === n ? e = t : "_value_" === n && (e = "x" === t ? "y" : "x"), e }(h, c), p = a[f + "AxisID"] || r[f] || f; o[p] = o[p] || Object.create(null), wa(o[p], [{ axis: f }, i[p], d[h]]) }) }), Object.keys(o).forEach(a => { const l = o[a]; wa(l, [ge.scales[l.type], ge.scale]) }), o }(n, t) } function zS(n) { return (n = n || {}).datasets = n.datasets || [], n.labels = n.labels || [], n } const US = new Map, WS = new Set; function Uu(n, t) { let e = US.get(n); return e || (e = t(), US.set(n, e), WS.add(e)), e } const Ha = (n, t, e) => { const i = Ji(t, e); void 0 !== i && n.add(i) }; class Rj { constructor(t) { this._config = function Pj(n) { return (n = n || {}).data = zS(n.data), $S(n), n }(t), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(t) { this._config.type = t } get data() { return this._config.data } set data(t) { this._config.data = zS(t) } get options() { return this._config.options } set options(t) { this._config.options = t } get plugins() { return this._config.plugins } update() { const t = this._config; this.clearCache(), $S(t) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(t) { return Uu(t, () => [[`datasets.${t}`, ""]]) } datasetAnimationScopeKeys(t, e) { return Uu(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]]) } datasetElementScopeKeys(t, e) { return Uu(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]]) } pluginScopeKeys(t) { const e = t.id; return Uu(`${this.type}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]]) } _cachedScopes(t, e) { const i = this._scopeCache; let s = i.get(t); return (!s || e) && (s = new Map, i.set(t, s)), s } getOptionScopes(t, e, i) { const { options: s, type: r } = this, o = this._cachedScopes(t, i), a = o.get(e); if (a) return a; const l = new Set; e.forEach(u => { t && (l.add(t), u.forEach(d => Ha(l, t, d))), u.forEach(d => Ha(l, s, d)), u.forEach(d => Ha(l, Ns[r] || {}, d)), u.forEach(d => Ha(l, ge, d)), u.forEach(d => Ha(l, Qg, d)) }); const c = Array.from(l); return 0 === c.length && c.push(Object.create(null)), WS.has(e) && o.set(e, c), c } chartOptionScopes() { const { options: t, type: e } = this; return [t, Ns[e] || {}, ge.datasets[e] || {}, { type: e }, ge, Qg] } resolveNamedOptions(t, e, i, s = [""]) { const r = { $shared: !0 }, { resolver: o, subPrefixes: a } = qS(this._resolverCache, t, s); let l = o; (function Lj(n, t) { const { isScriptable: e, isIndexable: i } = $C(n); for (const s of t) { const r = e(s), o = i(s), a = (o || r) && n[s]; if (r && (es(a) || Oj(a)) || o && Le(a)) return !0 } return !1 })(o, e) && (r.$shared = !1, l = Ur(o, i = es(i) ? i() : i, this.createResolver(t, i, a))); for (const c of e) r[c] = l[c]; return r } createResolver(t, e, i = [""], s) { const { resolver: r } = qS(this._resolverCache, t, i); return pe(e) ? Ur(r, e, void 0, s) : r } } function qS(n, t, e) { let i = n.get(t); i || (i = new Map, n.set(t, i)); const s = e.join(); let r = i.get(s); return r || (r = { resolver: Jg(t, e), subPrefixes: e.filter(a => !a.toLowerCase().includes("hover")) }, i.set(s, r)), r } const Oj = n => pe(n) && Object.getOwnPropertyNames(n).reduce((t, e) => t || es(n[e]), !1), Nj = ["top", "bottom", "left", "right", "chartArea"]; function GS(n, t) { return "top" === n || "bottom" === n || -1 === Nj.indexOf(n) && "x" === t } function KS(n, t) { return function (e, i) { return e[n] === i[n] ? e[t] - i[t] : e[n] - i[n] } } function QS(n) { const t = n.chart, e = t.options.animation; t.notifyPlugins("afterRender"), Fe(e && e.onComplete, [n], t) } function jj(n) { const t = n.chart, e = t.options.animation; Fe(e && e.onProgress, [n], t) } function ZS(n) { return ZC() && "string" == typeof n ? n = document.getElementById(n) : n && n.length && (n = n[0]), n && n.canvas && (n = n.canvas), n } const Wu = {}, YS = n => { const t = ZS(n); return Object.values(Wu).filter(e => e.canvas === t).pop() }; function Bj(n, t, e) { const i = Object.keys(n); for (const s of i) { const r = +s; if (r >= t) { const o = n[s]; delete n[s], (e > 0 || r > t) && (n[r + e] = o) } } } class $a { constructor(t, e) { const i = this.config = new Rj(e), s = ZS(t), r = YS(s); if (r) throw new Error("Canvas is already in use. Chart with ID '" + r.id + "' must be destroyed before the canvas can be reused."); const o = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || function sj(n) { return !ZC() || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas ? W9 : ij }(s)), this.platform.updateConfig(i); const a = this.platform.acquireContext(s, o.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width; this.id = S6(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new xj, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function x6(n, t) { let e; return function (...i) { return t ? (clearTimeout(e), e = setTimeout(n, t, i)) : n.apply(this, i), t } }(d => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Wu[this.id] = this, a && l ? (ki.listen(this, "complete", QS), ki.listen(this, "progress", jj), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item") } get aspectRatio() { const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: s, _aspectRatio: r } = this; return ye(t) ? e && r ? r : s ? i / s : null : t } get data() { return this.config.data } set data(t) { this.config.data = t } get options() { return this._options } set options(t) { this.config.options = t } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : YC(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return NC(this.canvas, this.ctx), this } stop() { return ki.stop(this), this } resize(t, e) { ki.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) } _resize(t, e) { const i = this.options, o = this.platform.getMaximumSize(this.canvas, t, e, i.maintainAspectRatio && this.aspectRatio), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, YC(this, a, !0) && (this.notifyPlugins("resize", { size: o }), Fe(i.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { xe(this.options.scales || {}, (i, s) => { i.id = s }) } buildOrUpdateScales() { const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((o, a) => (o[a] = !1, o), {}); let r = []; e && (r = r.concat(Object.keys(e).map(o => { const a = e[o], l = fm(o, a), c = "r" === l, u = "x" === l; return { options: a, dposition: c ? "chartArea" : u ? "bottom" : "left", dtype: c ? "radialLinear" : u ? "category" : "linear" } }))), xe(r, o => { const a = o.options, l = a.id, c = fm(l, a), u = re(a.type, o.dtype); (void 0 === a.position || GS(a.position, c) !== GS(o.dposition)) && (a.position = o.dposition), s[l] = !0; let d = null; l in i && i[l].type === u ? d = i[l] : (d = new (Pi.getScale(u))({ id: l, type: u, ctx: this.ctx, chart: this }), i[d.id] = d), d.init(a, t) }), xe(s, (o, a) => { o || delete i[a] }), xe(i, o => { At.configure(this, o, o.options), At.addBox(this, o) }) } _updateMetasets() { const t = this._metasets, e = this.data.datasets.length, i = t.length; if (t.sort((s, r) => s.index - r.index), i > e) { for (let s = e; s < i; ++s)this._destroyDatasetMeta(s); t.splice(e, i - e) } this._sortedMetasets = t.slice(0).sort(KS("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: t, data: { datasets: e } } = this; t.length > e.length && delete this._stacks, t.forEach((i, s) => { 0 === e.filter(r => r === i._dataset).length && this._destroyDatasetMeta(s) }) } buildOrUpdateControllers() { const t = [], e = this.data.datasets; let i, s; for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) { const r = e[i]; let o = this.getDatasetMeta(i); const a = r.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = r.indexAxis || hm(a, this.options), o.order = r.order || 0, o.index = i, o.label = "" + r.label, o.visible = this.isDatasetVisible(i), o.controller) o.controller.updateIndex(i), o.controller.linkScales(); else { const l = Pi.getController(a), { datasetElementType: c, dataElementType: u } = ge.datasets[a]; Object.assign(l.prototype, { dataElementType: Pi.getElement(u), datasetElementType: c && Pi.getElement(c) }), o.controller = new l(this, i), t.push(o.controller) } } return this._updateMetasets(), t } _resetElements() { xe(this.data.datasets, (t, e) => { this.getDatasetMeta(e).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(t) { const e = this.config; e.update(); const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 })) return; const r = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let c = 0, u = this.data.datasets.length; c < u; c++) { const { controller: d } = this.getDatasetMeta(c), h = !s && -1 === r.indexOf(d); d.buildOrUpdateElements(h), o = Math.max(+d.getMaxOverflow(), o) } o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || xe(r, c => { c.reset() }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(KS("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { xe(this.scales, t => { At.removeBox(this, t) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events); (!_C(e, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || []; for (const { method: i, start: s, count: r } of e) Bj(t, s, "_removeElements" === i ? -r : r) } _getUniformDataChanges() { const t = this._dataChanges; if (!t || !t.length) return; this._dataChanges = []; const e = this.data.datasets.length, i = r => new Set(t.filter(o => o[0] === r).map((o, a) => a + "," + o.splice(1).join(","))), s = i(0); for (let r = 1; r < e; r++)if (!_C(s, i(r))) return; return Array.from(s).map(r => r.split(",")).map(r => ({ method: r[1], start: +r[2], count: +r[3] })) } _updateLayout(t) { if (!1 === this.notifyPlugins("beforeLayout", { cancelable: !0 })) return; At.update(this, this.width, this.height, t); const e = this.chartArea, i = e.width <= 0 || e.height <= 0; this._layers = [], xe(this.boxes, s => { i && "chartArea" === s.position || (s.configure && s.configure(), this._layers.push(...s._layers())) }, this), this._layers.forEach((s, r) => { s._idx = r }), this.notifyPlugins("afterLayout") } _updateDatasets(t) { if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 })) { for (let e = 0, i = this.data.datasets.length; e < i; ++e)this.getDatasetMeta(e).controller.configure(); for (let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, es(t) ? t({ datasetIndex: e }) : t); this.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset(t, e) { const i = this.getDatasetMeta(t), s = { meta: i, index: t, mode: e, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s)) } render() { !1 !== this.notifyPlugins("beforeRender", { cancelable: !0 }) && (ki.has(this) ? this.attached && !ki.running(this) && ki.start(this) : (this.draw(), QS({ chart: this }))) } draw() { let t; if (this._resizeBeforeDraw) { const { width: i, height: s } = this._resizeBeforeDraw; this._resize(i, s), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || !1 === this.notifyPlugins("beforeDraw", { cancelable: !0 })) return; const e = this._layers; for (t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea); for (this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(t) { const e = this._sortedMetasets, i = []; let s, r; for (s = 0, r = e.length; s < r; ++s) { const o = e[s]; (!t || o.visible) && i.push(o) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (!1 === this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })) return; const t = this.getSortedVisibleDatasetMetas(); for (let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(t) { const e = this.ctx, i = t._clip, s = !i.disabled, r = this.chartArea, o = { meta: t, index: t.index, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (s && Ru(e, { left: !1 === i.left ? 0 : r.left - i.left, right: !1 === i.right ? this.width : r.right + i.right, top: !1 === i.top ? 0 : r.top - i.top, bottom: !1 === i.bottom ? this.height : r.bottom + i.bottom }), t.controller.draw(), s && Ou(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(t) { return ka(t, this.chartArea, this._minPadding) } getElementsAtEventForMode(t, e, i, s) { const r = N9.modes[e]; return "function" == typeof r ? r(this, t, i, s) : [] } getDatasetMeta(t) { const e = this.data.datasets[t], i = this._metasets; let s = i.filter(r => r && r._dataset === e).pop(); return s || (s = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, i.push(s)), s } getContext() { return this.$context || (this.$context = is(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(t) { const e = this.data.datasets[t]; if (!e) return !1; const i = this.getDatasetMeta(t); return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden } setDatasetVisibility(t, e) { this.getDatasetMeta(t).hidden = !e } toggleDataVisibility(t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility(t) { return !this._hiddenIndices[t] } _updateVisibility(t, e, i) { const s = i ? "show" : "hide", r = this.getDatasetMeta(t), o = r.controller._resolveAnimations(void 0, s); wn(e) ? (r.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(r, { visible: i }), this.update(a => a.datasetIndex === t ? s : void 0)) } hide(t, e) { this._updateVisibility(t, e, !1) } show(t, e) { this._updateVisibility(t, e, !0) } _destroyDatasetMeta(t) { const e = this._metasets[t]; e && e.controller && e.controller._destroy(), delete this._metasets[t] } _stop() { let t, e; for (this.stop(), ki.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: t, ctx: e } = this; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), NC(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete Wu[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...t) { return this.canvas.toDataURL(...t) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const t = this._listeners, e = this.platform, i = (r, o) => { e.addEventListener(this, r, o), t[r] = o }, s = (r, o, a) => { r.offsetX = o, r.offsetY = a, this._eventHandler(r) }; xe(this.options.events, r => i(r, s)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const t = this._responsiveListeners, e = this.platform, i = (l, c) => { e.addEventListener(this, l, c), t[l] = c }, s = (l, c) => { t[l] && (e.removeEventListener(this, l, c), delete t[l]) }, r = (l, c) => { this.canvas && this.resize(l, c) }; let o; const a = () => { s("attach", a), this.attached = !0, this.resize(), i("resize", r), i("detach", o) }; o = () => { this.attached = !1, s("resize", r), this._stop(), this._resize(0, 0), i("attach", a) }, e.isAttached(this.canvas) ? a() : o() } unbindEvents() { xe(this._listeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._listeners = {}, xe(this._responsiveListeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._responsiveListeners = void 0 } updateHoverStyle(t, e, i) { const s = i ? "set" : "remove"; let r, o, a, l; for ("dataset" === e && (r = this.getDatasetMeta(t[0].datasetIndex), r.controller["_" + s + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) { o = t[a]; const c = o && this.getDatasetMeta(o.datasetIndex).controller; c && c[s + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(t) { const e = this._active || [], i = t.map(({ datasetIndex: r, index: o }) => { const a = this.getDatasetMeta(r); if (!a) throw new Error("No dataset found at index " + r); return { datasetIndex: r, element: a.data[o], index: o } }); !xu(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e)) } notifyPlugins(t, e, i) { return this._plugins.notify(this, t, e, i) } _updateHoverStyles(t, e, i) { const s = this.options.hover, r = (l, c) => l.filter(u => !c.some(d => u.datasetIndex === d.datasetIndex && u.index === d.index)), o = r(e, t), a = i ? t : r(t, e); o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0) } _eventHandler(t, e) { const i = { event: t, replay: e, cancelable: !0, inChartArea: this.isPointInArea(t) }, s = o => (o.options.events || this.options.events).includes(t.native.type); if (!1 === this.notifyPlugins("beforeEvent", i, s)) return; const r = this._handleEvent(t, e, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (r || i.changed) && this.render(), this } _handleEvent(t, e, i) { const { _active: s = [], options: r } = this, a = this._getActiveElements(t, s, i, e), l = function I6(n) { return "mouseup" === n.type || "click" === n.type || "contextmenu" === n.type }(t), c = function Vj(n, t, e, i) { return e && "mouseout" !== n.type ? i ? t : n : null }(t, this._lastEvent, i, l); i && (this._lastEvent = null, Fe(r.onHover, [t, a, this], this), l && Fe(r.onClick, [t, a, this], this)); const u = !xu(a, s); return (u || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = c, u } _getActiveElements(t, e, i, s) { if ("mouseout" === t.type) return []; if (!i) return e; const r = this.options.hover; return this.getElementsAtEventForMode(t, r.mode, r, s) } } const XS = () => xe($a.instances, n => n._plugins.invalidate()), ss = !0; function JS(n, t, e) { const { startAngle: i, pixelMargin: s, x: r, y: o, outerRadius: a, innerRadius: l } = t; let c = s / a; n.beginPath(), n.arc(r, o, a, i - c, e + c), l > s ? (c = s / l, n.arc(r, o, l, e + c, i - c, !0)) : n.arc(r, o, s, e + Ge, i - Ge), n.closePath(), n.clip() } function Gr(n, t, e, i) { return { x: e + n * Math.cos(t), y: i + n * Math.sin(t) } } function pm(n, t, e, i, s) { const { x: r, y: o, startAngle: a, pixelMargin: l, innerRadius: c } = t, u = Math.max(t.outerRadius + i + e - l, 0), d = c > 0 ? c + i + e + l : 0; let h = 0; const f = s - a; if (i) { const $ = ((c > 0 ? c - i : 0) + (u > 0 ? u - i : 0)) / 2; h = (f - (0 !== $ ? f * $ / ($ + i) : f)) / 2 } const g = (f - Math.max(.001, f * u - e / He) / u) / 2, m = a + g + h, y = s - g - h, { outerStart: b, outerEnd: v, innerStart: D, innerEnd: x } = function $j(n, t, e, i) { const s = function Hj(n) { return Yg(n, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) }(n.options.borderRadius), r = (e - t) / 2, o = Math.min(r, i * t / 2), a = l => { const c = (e - Math.min(r, l)) * i / 2; return gt(l, 0, Math.min(r, c)) }; return { outerStart: a(s.outerStart), outerEnd: a(s.outerEnd), innerStart: gt(s.innerStart, 0, o), innerEnd: gt(s.innerEnd, 0, o) } }(t, d, u, y - m), S = u - b, A = u - v, F = m + b / S, B = y - v / A, te = d + D, oe = d + x, J = m + D / te, ve = y - x / oe; if (n.beginPath(), n.arc(r, o, u, F, B), v > 0) { const P = Gr(A, B, r, o); n.arc(P.x, P.y, v, B, y + Ge) } const Ke = Gr(oe, y, r, o); if (n.lineTo(Ke.x, Ke.y), x > 0) { const P = Gr(oe, ve, r, o); n.arc(P.x, P.y, x, y + Ge, ve + Math.PI) } if (n.arc(r, o, d, y - x / d, m + D / d, !0), D > 0) { const P = Gr(te, J, r, o); n.arc(P.x, P.y, D, J + Math.PI, m - Ge) } const ee = Gr(S, m, r, o); if (n.lineTo(ee.x, ee.y), b > 0) { const P = Gr(S, F, r, o); n.arc(P.x, P.y, b, m - Ge, F) } n.closePath() } Object.defineProperties($a, { defaults: { enumerable: ss, value: ge }, instances: { enumerable: ss, value: Wu }, overrides: { enumerable: ss, value: Ns }, registry: { enumerable: ss, value: Pi }, version: { enumerable: ss, value: "3.8.0" }, getChart: { enumerable: ss, value: YS }, register: { enumerable: ss, value: (...n) => { Pi.add(...n), XS() } }, unregister: { enumerable: ss, value: (...n) => { Pi.remove(...n), XS() } } }); class za extends Hn { constructor(t) { super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t) } inRange(t, e, i) { const s = this.getProps(["x", "y"], i), { angle: r, distance: o } = CC(s, { x: t, y: e }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: u, circumference: d } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), h = this.options.spacing / 2, p = re(d, l - a) >= Te || Sa(r, a, l), g = Mi(o, c + h, u + h); return p && g } getCenterPoint(t) { const { x: e, y: i, startAngle: s, endAngle: r, innerRadius: o, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t), { offset: l, spacing: c } = this.options, u = (s + r) / 2, d = (o + a + c + l) / 2; return { x: e + Math.cos(u) * d, y: i + Math.sin(u) * d } } tooltipPosition(t) { return this.getCenterPoint(t) } draw(t) { const { options: e, circumference: i } = this, s = (e.offset || 0) / 2, r = (e.spacing || 0) / 2; if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > Te ? Math.floor(i / Te) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return; t.save(); let o = 0; if (s) { o = s / 2; const l = (this.startAngle + this.endAngle) / 2; t.translate(Math.cos(l) * o, Math.sin(l) * o), this.circumference >= He && (o = s) } t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor; const a = function zj(n, t, e, i) { const { fullCircles: s, startAngle: r, circumference: o } = t; let a = t.endAngle; if (s) { pm(n, t, e, i, r + Te); for (let l = 0; l < s; ++l)n.fill(); isNaN(o) || (a = r + o % Te, o % Te == 0 && (a += Te)) } return pm(n, t, e, i, a), n.fill(), a }(t, this, o, r); (function Wj(n, t, e, i, s) { const { options: r } = t, { borderWidth: o, borderJoinStyle: a } = r, l = "inner" === r.borderAlign; !o || (l ? (n.lineWidth = 2 * o, n.lineJoin = a || "round") : (n.lineWidth = o, n.lineJoin = a || "bevel"), t.fullCircles && function Uj(n, t, e) { const { x: i, y: s, startAngle: r, pixelMargin: o, fullCircles: a } = t, l = Math.max(t.outerRadius - o, 0), c = t.innerRadius + o; let u; for (e && JS(n, t, r + Te), n.beginPath(), n.arc(i, s, c, r + Te, r, !0), u = 0; u < a; ++u)n.stroke(); for (n.beginPath(), n.arc(i, s, l, r, r + Te), u = 0; u < a; ++u)n.stroke() }(n, t, l), l && JS(n, t, s), pm(n, t, e, i, s), n.stroke()) })(t, this, o, r, a), t.restore() } } function e2(n, t, e = t) { n.lineCap = re(e.borderCapStyle, t.borderCapStyle), n.setLineDash(re(e.borderDash, t.borderDash)), n.lineDashOffset = re(e.borderDashOffset, t.borderDashOffset), n.lineJoin = re(e.borderJoinStyle, t.borderJoinStyle), n.lineWidth = re(e.borderWidth, t.borderWidth), n.strokeStyle = re(e.borderColor, t.borderColor) } function qj(n, t, e) { n.lineTo(e.x, e.y) } function t2(n, t, e = {}) { const i = n.length, { start: s = 0, end: r = i - 1 } = e, { start: o, end: a } = t, l = Math.max(s, o), c = Math.min(r, a); return { count: i, start: l, loop: t.loop, ilen: c < l && !(s < o && r < o || s > a && r > a) ? i + c - l : c - l } } function Kj(n, t, e, i) { const { points: s, options: r } = t, { count: o, start: a, loop: l, ilen: c } = t2(s, e, i), u = function Gj(n) { return n.stepped ? c7 : n.tension || "monotone" === n.cubicInterpolationMode ? u7 : qj }(r); let f, p, g, { move: d = !0, reverse: h } = i || {}; for (f = 0; f <= c; ++f)p = s[(a + (h ? c - f : f)) % o], !p.skip && (d ? (n.moveTo(p.x, p.y), d = !1) : u(n, g, p, h, r.stepped), g = p); return l && (p = s[(a + (h ? c : 0)) % o], u(n, g, p, h, r.stepped)), !!l } function Qj(n, t, e, i) { const s = t.points, { count: r, start: o, ilen: a } = t2(s, e, i), { move: l = !0, reverse: c } = i || {}; let h, f, p, g, m, y, u = 0, d = 0; const b = D => (o + (c ? a - D : D)) % r, v = () => { g !== m && (n.lineTo(u, m), n.lineTo(u, g), n.lineTo(u, y)) }; for (l && (f = s[b(0)], n.moveTo(f.x, f.y)), h = 0; h <= a; ++h) { if (f = s[b(h)], f.skip) continue; const D = f.x, x = f.y, S = 0 | D; S === p ? (x < g ? g = x : x > m && (m = x), u = (d * u + D) / ++d) : (v(), n.lineTo(D, x), p = S, d = 0, g = m = x), y = x } v() } function gm(n) { const t = n.options; return n._decimated || n._loop || t.tension || "monotone" === t.cubicInterpolationMode || t.stepped || t.borderDash && t.borderDash.length ? Kj : Qj } za.id = "arc", za.defaults = { borderAlign: "center", borderColor: "#fff", borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0 }, za.defaultRoutes = { backgroundColor: "backgroundColor" }; const Jj = "function" == typeof Path2D; let Ua = (() => { class n extends Hn { constructor(e) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e) } updateControlPoints(e, i) { const s = this.options; !s.tension && "monotone" !== s.cubicInterpolationMode || s.stepped || this._pointsUpdated || (F7(this._points, s, e, s.spanGaps ? this._loop : this._fullLoop, i), this._pointsUpdated = !0) } set points(e) { this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = function X7(n, t) { const e = n.points, i = n.options.spanGaps, s = e.length; if (!s) return []; const r = !!n._loop, { start: o, end: a } = function Z7(n, t, e, i) { let s = 0, r = t - 1; if (e && !i) for (; s < t && !n[s].skip;)s++; for (; s < t && n[s].skip;)s++; for (s %= t, e && (r += s); r > s && n[r % t].skip;)r--; return r %= t, { start: s, end: r } }(e, s, r, i); return function oS(n, t, e, i) { return i && i.setContext && e ? function J7(n, t, e, i) { const s = n._chart.getContext(), r = aS(n.options), { _datasetIndex: o, options: { spanGaps: a } } = n, l = e.length, c = []; let u = r, d = t[0].start, h = d; function f(p, g, m, y) { const b = a ? -1 : 1; if (p !== g) { for (p += l; e[p % l].skip;)p -= b; for (; e[g % l].skip;)g += b; p % l != g % l && (c.push({ start: p % l, end: g % l, loop: m, style: y }), u = y, d = g % l) } } for (const p of t) { d = a ? d : p.start; let m, g = e[d % l]; for (h = d + 1; h <= p.end; h++) { const y = e[h % l]; m = aS(i.setContext(is(s, { type: "segment", p0: g, p1: y, p0DataIndex: (h - 1) % l, p1DataIndex: h % l, datasetIndex: o }))), e9(m, u) && f(d, h - 1, p.loop, u), g = y, u = m } d < h - 1 && f(d, h - 1, p.loop, u) } return c }(n, t, e, i) : t }(n, !0 === i ? [{ start: o, end: a, loop: r }] : function Y7(n, t, e, i) { const s = n.length, r = []; let l, o = t, a = n[t]; for (l = t + 1; l <= e; ++l) { const c = n[l % s]; c.skip || c.stop ? a.skip || (r.push({ start: t % s, end: (l - 1) % s, loop: i = !1 }), t = o = c.stop ? l : null) : (o = l, a.skip && (t = l)), a = c } return null !== o && r.push({ start: t % s, end: o % s, loop: i }), r }(e, o, a < o ? a + s : a, !!n._fullLoop && 0 === o && a === s - 1), e, t) }(this, this.options.segment)) } first() { const e = this.segments; return e.length && this.points[e[0].start] } last() { const e = this.segments, s = e.length; return s && this.points[e[s - 1].end] } interpolate(e, i) { const s = this.options, r = e[i], o = this.points, a = rS(this, { property: i, start: r, end: r }); if (!a.length) return; const l = [], c = function Zj(n) { return n.stepped ? U7 : n.tension || "monotone" === n.cubicInterpolationMode ? W7 : zs }(s); let u, d; for (u = 0, d = a.length; u < d; ++u) { const { start: h, end: f } = a[u], p = o[h], g = o[f]; if (p === g) { l.push(p); continue } const y = c(p, g, Math.abs((r - p[i]) / (g[i] - p[i])), s.stepped); y[i] = e[i], l.push(y) } return 1 === l.length ? l[0] : l } pathSegment(e, i, s) { return gm(this)(e, this, i, s) } path(e, i, s) { const r = this.segments, o = gm(this); let a = this._loop; i = i || 0, s = s || this.points.length - i; for (const l of r) a &= o(e, this, l, { start: i, end: i + s - 1 }); return !!a } draw(e, i, s, r) { (this.points || []).length && (this.options || {}).borderWidth && (e.save(), function eB(n, t, e, i) { Jj && !t.options.segment ? function Yj(n, t, e, i) { let s = t._path; s || (s = t._path = new Path2D, t.path(s, e, i) && s.closePath()), e2(n, t.options), n.stroke(s) }(n, t, e, i) : function Xj(n, t, e, i) { const { segments: s, options: r } = t, o = gm(t); for (const a of s) e2(n, r, a.style), n.beginPath(), o(n, t, a, { start: e, end: e + i - 1 }) && n.closePath(), n.stroke() }(n, t, e, i) }(e, this, s, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } return n.id = "line", n.defaults = { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }, n.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }, n.descriptors = { _scriptable: !0, _indexable: t => "borderDash" !== t && "fill" !== t }, n })(); function n2(n, t, e, i) { const s = n.options, { [e]: r } = n.getProps([e], i); return Math.abs(t - r) < s.radius + s.hitRadius } let i2 = (() => { class n extends Hn { constructor(e) { super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e) } inRange(e, i, s) { const r = this.options, { x: o, y: a } = this.getProps(["x", "y"], s); return Math.pow(e - o, 2) + Math.pow(i - a, 2) < Math.pow(r.hitRadius + r.radius, 2) } inXRange(e, i) { return n2(this, e, "x", i) } inYRange(e, i) { return n2(this, e, "y", i) } getCenterPoint(e) { const { x: i, y: s } = this.getProps(["x", "y"], e); return { x: i, y: s } } size(e) { let i = (e = e || this.options || {}).radius || 0; return i = Math.max(i, i && e.hoverRadius || 0), 2 * (i + (i && e.borderWidth || 0)) } draw(e, i) { const s = this.options; this.skip || s.radius < .1 || !ka(this, i, this.size(s) / 2) || (e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.fillStyle = s.backgroundColor, Pu(e, s, this.x, this.y)) } getRange() { const e = this.options || {}; return e.radius + e.hitRadius } } return n.id = "point", n.defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }, n.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }, n })(); function s2(n, t) { const { x: e, y: i, base: s, width: r, height: o } = n.getProps(["x", "y", "base", "width", "height"], t); let a, l, c, u, d; return n.horizontal ? (d = o / 2, a = Math.min(e, s), l = Math.max(e, s), c = i - d, u = i + d) : (d = r / 2, a = e - d, l = e + d, c = Math.min(i, s), u = Math.max(i, s)), { left: a, top: c, right: l, bottom: u } } function rs(n, t, e, i) { return n ? 0 : gt(t, e, i) } function mm(n, t, e, i) { const s = null === t, r = null === e, a = n && !(s && r) && s2(n, i); return a && (s || Mi(t, a.left, a.right)) && (r || Mi(e, a.top, a.bottom)) } function rB(n, t) { n.rect(t.x, t.y, t.w, t.h) } function ym(n, t, e = {}) { const i = n.x !== e.x ? -t : 0, s = n.y !== e.y ? -t : 0; return { x: n.x + i, y: n.y + s, w: n.w + ((n.x + n.w !== e.x + e.w ? t : 0) - i), h: n.h + ((n.y + n.h !== e.y + e.h ? t : 0) - s), radius: n.radius } } class Wa extends Hn { constructor(t) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t) } draw(t) { const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: r, outer: o } = function iB(n) { const t = s2(n), e = t.right - t.left, i = t.bottom - t.top, s = function tB(n, t, e) { const s = n.borderSkipped, r = jC(n.options.borderWidth); return { t: rs(s.top, r.top, 0, e), r: rs(s.right, r.right, 0, t), b: rs(s.bottom, r.bottom, 0, e), l: rs(s.left, r.left, 0, t) } }(n, e / 2, i / 2), r = function nB(n, t, e) { const { enableBorderRadius: i } = n.getProps(["enableBorderRadius"]), s = n.options.borderRadius, r = Vs(s), o = Math.min(t, e), a = n.borderSkipped, l = i || pe(s); return { topLeft: rs(!l || a.top || a.left, r.topLeft, 0, o), topRight: rs(!l || a.top || a.right, r.topRight, 0, o), bottomLeft: rs(!l || a.bottom || a.left, r.bottomLeft, 0, o), bottomRight: rs(!l || a.bottom || a.right, r.bottomRight, 0, o) } }(n, e / 2, i / 2); return { outer: { x: t.left, y: t.top, w: e, h: i, radius: r }, inner: { x: t.left + s.l, y: t.top + s.t, w: e - s.l - s.r, h: i - s.t - s.b, radius: { topLeft: Math.max(0, r.topLeft - Math.max(s.t, s.l)), topRight: Math.max(0, r.topRight - Math.max(s.t, s.r)), bottomLeft: Math.max(0, r.bottomLeft - Math.max(s.b, s.l)), bottomRight: Math.max(0, r.bottomRight - Math.max(s.b, s.r)) } } } }(this), a = function sB(n) { return n.topLeft || n.topRight || n.bottomLeft || n.bottomRight }(o.radius) ? Ia : rB; t.save(), (o.w !== r.w || o.h !== r.h) && (t.beginPath(), a(t, ym(o, e, r)), t.clip(), a(t, ym(r, -e, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), a(t, ym(r, e)), t.fillStyle = s, t.fill(), t.restore() } inRange(t, e, i) { return mm(this, t, e, i) } inXRange(t, e) { return mm(this, t, null, e) } inYRange(t, e) { return mm(this, null, t, e) } getCenterPoint(t) { const { x: e, y: i, base: s, horizontal: r } = this.getProps(["x", "y", "base", "horizontal"], t); return { x: r ? (e + s) / 2 : e, y: r ? i : (i + s) / 2 } } getRange(t) { return "x" === t ? this.width / 2 : this.height / 2 } } function r2(n) { if (n._decimated) { const t = n._data; delete n._decimated, delete n._data, Object.defineProperty(n, "data", { value: t }) } } function o2(n) { n.data.datasets.forEach(t => { r2(t) }) } Wa.id = "bar", Wa.defaults = { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }, Wa.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; var a2 = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (n, t, e) => { if (!e.enabled) return void o2(n); const i = n.width; n.data.datasets.forEach((s, r) => { const { _data: o, indexAxis: a } = s, l = n.getDatasetMeta(r), c = o || s.data; if ("y" === Pa([a, n.options.indexAxis]) || !l.controller.supportsDecimation) return; const u = n.scales[l.xAxisID]; if ("linear" !== u.type && "time" !== u.type || n.options.parsing) return; let p, { start: d, count: h } = function cB(n, t) { const e = t.length; let s, i = 0; const { iScale: r } = n, { min: o, max: a, minDefined: l, maxDefined: c } = r.getUserBounds(); return l && (i = gt(Ai(t, r.axis, o).lo, 0, e - 1)), s = c ? gt(Ai(t, r.axis, a).hi + 1, i, e) - i : e - i, { start: i, count: s } }(l, c); if (h <= (e.threshold || 4 * i)) r2(s); else { switch (ye(o) && (s._data = c, delete s.data, Object.defineProperty(s, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (g) { this._data = g } })), e.algorithm) { case "lttb": p = function aB(n, t, e, i, s) { const r = s.samples || i; if (r >= e) return n.slice(t, t + e); const o = [], a = (e - 2) / (r - 2); let l = 0; const c = t + e - 1; let d, h, f, p, g, u = t; for (o[l++] = n[u], d = 0; d < r - 2; d++) { let b, m = 0, y = 0; const v = Math.floor((d + 1) * a) + 1 + t, D = Math.min(Math.floor((d + 2) * a) + 1, e) + t, x = D - v; for (b = v; b < D; b++)m += n[b].x, y += n[b].y; m /= x, y /= x; const S = Math.floor(d * a) + 1 + t, A = Math.min(Math.floor((d + 1) * a) + 1, e) + t, { x: F, y: B } = n[u]; for (f = p = -1, b = S; b < A; b++)p = .5 * Math.abs((F - m) * (n[b].y - B) - (F - n[b].x) * (y - B)), p > f && (f = p, h = n[b], g = b); o[l++] = h, u = g } return o[l++] = n[c], o }(c, d, h, i, e); break; case "min-max": p = function lB(n, t, e, i) { let o, a, l, c, u, d, h, f, p, g, s = 0, r = 0; const m = [], b = n[t].x, D = n[t + e - 1].x - b; for (o = t; o < t + e; ++o) { a = n[o], l = (a.x - b) / D * i, c = a.y; const x = 0 | l; if (x === u) c < p ? (p = c, d = o) : c > g && (g = c, h = o), s = (r * s + a.x) / ++r; else { const S = o - 1; if (!ye(d) && !ye(h)) { const A = Math.min(d, h), F = Math.max(d, h); A !== f && A !== S && m.push({ ...n[A], x: s }), F !== f && F !== S && m.push({ ...n[F], x: s }) } o > 0 && S !== f && m.push(n[S]), m.push(a), u = x, r = 0, p = g = c, d = h = f = o } } return m }(c, d, h, i); break; default: throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`) }s._decimated = p } }) }, destroy(n) { o2(n) } }; function vm(n, t, e, i) { if (i) return; let s = t[n], r = e[n]; return "angle" === n && (s = cn(s), r = cn(r)), { property: n, start: s, end: r } } function _m(n, t, e) { for (; t > n; t--) { const i = e[t]; if (!isNaN(i.x) && !isNaN(i.y)) break } return t } function l2(n, t, e, i) { return n && t ? i(n[e], t[e]) : n ? n[e] : t ? t[e] : 0 } function c2(n, t) { let e = [], i = !1; return Le(n) ? (i = !0, e = n) : e = function dB(n, t) { const { x: e = null, y: i = null } = n || {}, s = t.points, r = []; return t.segments.forEach(({ start: o, end: a }) => { a = _m(o, a, s); const l = s[o], c = s[a]; null !== i ? (r.push({ x: l.x, y: i }), r.push({ x: c.x, y: i })) : null !== e && (r.push({ x: e, y: l.y }), r.push({ x: e, y: c.y })) }), r }(n, t), e.length ? new Ua({ points: e, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null } function hB(n, t, e) { let s = n[t].fill; const r = [t]; let o; if (!e) return s; for (; !1 !== s && -1 === r.indexOf(s);) { if (!Ze(s)) return s; if (o = n[s], !o) return !1; if (o.visible) return s; r.push(s), s = o.fill } return !1 } function fB(n, t, e) { const i = function yB(n) { const t = n.options, e = t.fill; let i = re(e && e.target, e); return void 0 === i && (i = !!t.backgroundColor), !1 !== i && null !== i && (!0 === i ? "origin" : i) }(n); if (pe(i)) return !isNaN(i.value) && i; let s = parseFloat(i); return Ze(s) && Math.floor(s) === s ? function pB(n, t, e, i) { return ("-" === n || "+" === n) && (e = t + e), !(e === t || e < 0 || e >= i) && e }(i[0], t, s, e) : ["origin", "start", "end", "stack", "shape"].indexOf(i) >= 0 && i } function bB(n, t, e) { const i = []; for (let s = 0; s < e.length; s++) { const r = e[s], { first: o, last: a, point: l } = wB(r, t, "x"); if (!(!l || o && a)) if (o) i.unshift(l); else if (n.push(l), !a) break } n.push(...i) } function wB(n, t, e) { const i = n.interpolate(t, e); if (!i) return {}; const s = i[e], r = n.segments, o = n.points; let a = !1, l = !1; for (let c = 0; c < r.length; c++) { const u = r[c], d = o[u.start][e], h = o[u.end][e]; if (Mi(s, d, h)) { a = s === d, l = s === h; break } } return { first: a, last: l, point: i } } class u2 { constructor(t) { this.x = t.x, this.y = t.y, this.radius = t.radius } pathSegment(t, e, i) { const { x: s, y: r, radius: o } = this; return t.arc(s, r, o, (e = e || { start: 0, end: Te }).end, e.start, !0), !i.bounds } interpolate(t) { const { x: e, y: i, radius: s } = this, r = t.angle; return { x: e + Math.cos(r) * s, y: i + Math.sin(r) * s, angle: r } } } function bm(n, t, e) { const i = function DB(n) { const { chart: t, fill: e, line: i } = n; if (Ze(e)) return function xB(n, t) { const e = n.getDatasetMeta(t); return e && n.isDatasetVisible(t) ? e.dataset : null }(t, e); if ("stack" === e) return function vB(n) { const { scale: t, index: e, line: i } = n, s = [], r = i.segments, o = i.points, a = function _B(n, t) { const e = [], i = n.getMatchingVisibleMetas("line"); for (let s = 0; s < i.length; s++) { const r = i[s]; if (r.index === t) break; r.hidden || e.unshift(r.dataset) } return e }(t, e); a.push(c2({ x: null, y: t.bottom }, i)); for (let l = 0; l < r.length; l++) { const c = r[l]; for (let u = c.start; u <= c.end; u++)bB(s, o[u], a) } return new Ua({ points: s, options: {} }) }(n); if ("shape" === e) return !0; const s = function CB(n) { return (n.scale || {}).getPointPositionForValue ? function EB(n) { const { scale: t, fill: e } = n, i = t.options, s = t.getLabels().length, r = i.reverse ? t.max : t.min, o = function mB(n, t, e) { let i; return i = "start" === n ? e : "end" === n ? t.options.reverse ? t.min : t.max : pe(n) ? n.value : t.getBaseValue(), i }(e, t, r), a = []; if (i.grid.circular) { const l = t.getPointPositionForValue(0, r); return new u2({ x: l.x, y: l.y, radius: t.getDistanceFromCenterForValue(o) }) } for (let l = 0; l < s; ++l)a.push(t.getPointPositionForValue(l, o)); return a }(n) : function SB(n) { const { scale: t = {}, fill: e } = n, i = function gB(n, t) { let e = null; return "start" === n ? e = t.bottom : "end" === n ? e = t.top : pe(n) ? e = t.getPixelForValue(n.value) : t.getBasePixel && (e = t.getBasePixel()), e }(e, t); if (Ze(i)) { const s = t.isHorizontal(); return { x: s ? i : null, y: s ? null : i } } return null }(n) }(n); return s instanceof u2 ? s : c2(s, i) }(t), { line: s, scale: r, axis: o } = t, a = s.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: d = c } = l || {}; i && s.points.length && (Ru(n, e), function MB(n, t) { const { line: e, target: i, above: s, below: r, area: o, scale: a } = t, l = e._loop ? "angle" : t.axis; n.save(), "x" === l && r !== s && (d2(n, i, o.top), h2(n, { line: e, target: i, color: s, scale: a, property: l }), n.restore(), n.save(), d2(n, i, o.bottom)), h2(n, { line: e, target: i, color: r, scale: a, property: l }), n.restore() }(n, { line: s, target: i, above: u, below: d, area: e, scale: r, axis: o }), Ou(n)) } function d2(n, t, e) { const { segments: i, points: s } = t; let r = !0, o = !1; n.beginPath(); for (const a of i) { const { start: l, end: c } = a, u = s[l], d = s[_m(l, c, s)]; r ? (n.moveTo(u.x, u.y), r = !1) : (n.lineTo(u.x, e), n.lineTo(u.x, u.y)), o = !!t.pathSegment(n, a, { move: o }), o ? n.closePath() : n.lineTo(d.x, e) } n.lineTo(t.first().x, e), n.closePath(), n.clip() } function h2(n, t) { const { line: e, target: i, property: s, color: r, scale: o } = t, a = function uB(n, t, e) { const i = n.segments, s = n.points, r = t.points, o = []; for (const a of i) { let { start: l, end: c } = a; c = _m(l, c, s); const u = vm(e, s[l], s[c], a.loop); if (!t.segments) { o.push({ source: a, target: u, start: s[l], end: s[c] }); continue } const d = rS(t, u); for (const h of d) { const f = vm(e, r[h.start], r[h.end], h.loop), p = sS(a, s, f); for (const g of p) o.push({ source: g, target: h, start: { [e]: l2(u, f, "start", Math.max) }, end: { [e]: l2(u, f, "end", Math.min) } }) } } return o }(e, i, s); for (const { source: l, target: c, start: u, end: d } of a) { const { style: { backgroundColor: h = r } = {} } = l, f = !0 !== i; n.save(), n.fillStyle = h, TB(n, o, f && vm(s, u, d)), n.beginPath(); const p = !!e.pathSegment(n, l); let g; if (f) { p ? n.closePath() : f2(n, i, d, s); const m = !!i.pathSegment(n, c, { move: p, reverse: !0 }); g = p && m, g || f2(n, i, u, s) } n.closePath(), n.fill(g ? "evenodd" : "nonzero"), n.restore() } } function TB(n, t, e) { const { top: i, bottom: s } = t.chart.chartArea, { property: r, start: o, end: a } = e || {}; "x" === r && (n.beginPath(), n.rect(o, i, a - o, s - i), n.clip()) } function f2(n, t, e, i) { const s = t.interpolate(e, i); s && n.lineTo(s.x, s.y) } var p2 = { id: "filler", afterDatasetsUpdate(n, t, e) { const i = (n.data.datasets || []).length, s = []; let r, o, a, l; for (o = 0; o < i; ++o)r = n.getDatasetMeta(o), a = r.dataset, l = null, a && a.options && a instanceof Ua && (l = { visible: n.isDatasetVisible(o), index: o, fill: fB(a, o, i), chart: n, axis: r.controller.options.indexAxis, scale: r.vScale, line: a }), r.$filler = l, s.push(l); for (o = 0; o < i; ++o)l = s[o], l && !1 !== l.fill && (l.fill = hB(s, o, e.propagate)) }, beforeDraw(n, t, e) { const i = "beforeDraw" === e.drawTime, s = n.getSortedVisibleDatasetMetas(), r = n.chartArea; for (let o = s.length - 1; o >= 0; --o) { const a = s[o].$filler; !a || (a.line.updateControlPoints(r, a.axis), i && bm(n.ctx, a, r)) } }, beforeDatasetsDraw(n, t, e) { if ("beforeDatasetsDraw" !== e.drawTime) return; const i = n.getSortedVisibleDatasetMetas(); for (let s = i.length - 1; s >= 0; --s) { const r = i[s].$filler; r && bm(n.ctx, r, n.chartArea) } }, beforeDatasetDraw(n, t, e) { const i = t.meta.$filler; !i || !1 === i.fill || "beforeDatasetDraw" !== e.drawTime || bm(n.ctx, i, n.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const g2 = (n, t) => { let { boxHeight: e = t, boxWidth: i = t } = n; return n.usePointStyle && (e = Math.min(e, t), i = Math.min(i, t)), { boxWidth: i, boxHeight: e, itemHeight: Math.max(t, e) } }; class m2 extends Hn { constructor(t) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e, i) { this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const t = this.options.labels || {}; let e = Fe(t.generateLabels, [this.chart], this) || []; t.filter && (e = e.filter(i => t.filter(i, this.chart.data))), t.sort && (e = e.sort((i, s) => t.sort(i, s, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e } fit() { const { options: t, ctx: e } = this; if (!t.display) return void (this.width = this.height = 0); const i = t.labels, s = dt(i.font), r = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = g2(i, r); let c, u; e.font = s.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(o, r, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(o, r, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(u, t.maxHeight || this.maxHeight) } _fitRows(t, e, i, s) { const { ctx: r, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], u = s + a; let d = t; r.textAlign = "left", r.textBaseline = "middle"; let h = -1, f = -u; return this.legendItems.forEach((p, g) => { const m = i + e / 2 + r.measureText(p.text).width; (0 === g || c[c.length - 1] + m + 2 * a > o) && (d += u, c[c.length - (g > 0 ? 0 : 1)] = 0, f += u, h++), l[g] = { left: 0, top: f, row: h, width: m, height: s }, c[c.length - 1] += m + a }), d } _fitCols(t, e, i, s) { const { ctx: r, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = o - t; let d = a, h = 0, f = 0, p = 0, g = 0; return this.legendItems.forEach((m, y) => { const b = i + e / 2 + r.measureText(m.text).width; y > 0 && f + s + 2 * a > u && (d += h + a, c.push({ width: h, height: f }), p += h + a, g++, h = f = 0), l[y] = { left: p, top: f, col: g, width: b, height: s }, h = Math.max(h, b), f += s + a }), d += h, c.push({ width: h, height: f }), d } adjustHitBoxes() { if (!this.options.display) return; const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: r } } = this, o = qr(r, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = Mt(i, this.left + s, this.right - this.lineWidths[a]); for (const c of e) a !== c.row && (a = c.row, l = Mt(i, this.left + s, this.right - this.lineWidths[a])), c.top += this.top + t + s, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + s } else { let a = 0, l = Mt(i, this.top + t + s, this.bottom - this.columnSizes[a].height); for (const c of e) c.col !== a && (a = c.col, l = Mt(i, this.top + t + s, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + s, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + s } } isHorizontal() { return "top" === this.options.position || "bottom" === this.options.position } draw() { if (this.options.display) { const t = this.ctx; Ru(t, this), this._draw(), Ou(t) } } _draw() { const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: r, labels: o } = t, a = ge.color, l = qr(t.rtl, this.left, this.width), c = dt(o.font), { color: u, padding: d } = o, h = c.size, f = h / 2; let p; this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = .5, s.font = c.string; const { boxWidth: g, boxHeight: m, itemHeight: y } = g2(o, h), D = this.isHorizontal(), x = this._computeTitleHeight(); p = D ? { x: Mt(r, this.left + d, this.right - i[0]), y: this.top + d + x, line: 0 } : { x: this.left + d, y: Mt(r, this.top + x + d, this.bottom - e[0].height), line: 0 }, eS(this.ctx, t.textDirection); const S = y + d; this.legendItems.forEach((A, F) => { s.strokeStyle = A.fontColor || u, s.fillStyle = A.fontColor || u; const B = s.measureText(A.text).width, te = l.textAlign(A.textAlign || (A.textAlign = o.textAlign)), oe = g + f + B; let J = p.x, ve = p.y; l.setWidth(this.width), D ? F > 0 && J + oe + d > this.right && (ve = p.y += S, p.line++, J = p.x = Mt(r, this.left + d, this.right - i[p.line])) : F > 0 && ve + S > this.bottom && (J = p.x = J + e[p.line].width + d, p.line++, ve = p.y = Mt(r, this.top + x + d, this.bottom - e[p.line].height)), function (A, F, B) { if (isNaN(g) || g <= 0 || isNaN(m) || m < 0) return; s.save(); const te = re(B.lineWidth, 1); if (s.fillStyle = re(B.fillStyle, a), s.lineCap = re(B.lineCap, "butt"), s.lineDashOffset = re(B.lineDashOffset, 0), s.lineJoin = re(B.lineJoin, "miter"), s.lineWidth = te, s.strokeStyle = re(B.strokeStyle, a), s.setLineDash(re(B.lineDash, [])), o.usePointStyle) { const oe = { radius: g * Math.SQRT2 / 2, pointStyle: B.pointStyle, rotation: B.rotation, borderWidth: te }, J = l.xPlus(A, g / 2); Pu(s, oe, J, F + f) } else { const oe = F + Math.max((h - m) / 2, 0), J = l.leftForLtr(A, g), ve = Vs(B.borderRadius); s.beginPath(), Object.values(ve).some(Ke => 0 !== Ke) ? Ia(s, { x: J, y: oe, w: g, h: m, radius: ve }) : s.rect(J, oe, g, m), s.fill(), 0 !== te && s.stroke() } s.restore() }(l.x(J), ve, A), J = ((n, t, e, i) => n === (i ? "left" : "right") ? e : "center" === n ? (t + e) / 2 : t)(te, J + g + f, D ? J + oe : this.right, t.rtl), function (A, F, B) { Bs(s, B.text, A, F + y / 2, c, { strikethrough: B.hidden, textAlign: l.textAlign(B.textAlign) }) }(l.x(J), ve, A), D ? p.x += oe + d : p.y += S }), tS(this.ctx, t.textDirection) } drawTitle() { const t = this.options, e = t.title, i = dt(e.font), s = Tt(e.padding); if (!e.display) return; const r = qr(t.rtl, this.left, this.width), o = this.ctx, a = e.position, c = s.top + i.size / 2; let u, d = this.left, h = this.width; if (this.isHorizontal()) h = Math.max(...this.lineWidths), u = this.top + c, d = Mt(t.align, d, this.right - h); else { const p = this.columnSizes.reduce((g, m) => Math.max(g, m.height), 0); u = c + Mt(t.align, this.top, this.bottom - p - t.labels.padding - this._computeTitleHeight()) } const f = Mt(a, d, d + h); o.textAlign = r.textAlign(Bg(a)), o.textBaseline = "middle", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Bs(o, e.text, f, u, i) } _computeTitleHeight() { const t = this.options.title, e = dt(t.font), i = Tt(t.padding); return t.display ? e.lineHeight + i.height : 0 } _getLegendItemAt(t, e) { let i, s, r; if (Mi(t, this.left, this.right) && Mi(e, this.top, this.bottom)) for (r = this.legendHitBoxes, i = 0; i < r.length; ++i)if (s = r[i], Mi(t, s.left, s.left + s.width) && Mi(e, s.top, s.top + s.height)) return this.legendItems[i]; return null } handleEvent(t) { const e = this.options; if (!function kB(n, t) { return !(("mousemove" !== n && "mouseout" !== n || !t.onHover && !t.onLeave) && (!t.onClick || "click" !== n && "mouseup" !== n)) }(t.type, e)) return; const i = this._getLegendItemAt(t.x, t.y); if ("mousemove" === t.type || "mouseout" === t.type) { const s = this._hoveredItem, r = ((n, t) => null !== n && null !== t && n.datasetIndex === t.datasetIndex && n.index === t.index)(s, i); s && !r && Fe(e.onLeave, [t, s, this], this), this._hoveredItem = i, i && !r && Fe(e.onHover, [t, i, this], this) } else i && Fe(e.onClick, [t, i, this], this) } } var y2 = { id: "legend", _element: m2, start(n, t, e) { const i = n.legend = new m2({ ctx: n.ctx, options: e, chart: n }); At.configure(n, i, e), At.addBox(n, i) }, stop(n) { At.removeBox(n, n.legend), delete n.legend }, beforeUpdate(n, t, e) { const i = n.legend; At.configure(n, i, e), i.options = e }, afterUpdate(n) { const t = n.legend; t.buildLabels(), t.adjustHitBoxes() }, afterEvent(n, t) { t.replay || n.legend.handleEvent(t.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(n, t, e) { const i = t.datasetIndex, s = e.chart; s.isDatasetVisible(i) ? (s.hide(i), t.hidden = !0) : (s.show(i), t.hidden = !1) }, onHover: null, onLeave: null, labels: { color: n => n.chart.options.color, boxWidth: 40, padding: 10, generateLabels(n) { const t = n.data.datasets, { labels: { usePointStyle: e, pointStyle: i, textAlign: s, color: r } } = n.legend.options; return n._getSortedDatasetMetas().map(o => { const a = o.controller.getStyle(e ? 0 : void 0), l = Tt(a.borderWidth); return { text: t[o.index].label, fillStyle: a.backgroundColor, fontColor: r, hidden: !o.visible, lineCap: a.borderCapStyle, lineDash: a.borderDash, lineDashOffset: a.borderDashOffset, lineJoin: a.borderJoinStyle, lineWidth: (l.width + l.height) / 4, strokeStyle: a.borderColor, pointStyle: i || a.pointStyle, rotation: a.rotation, textAlign: s || a.textAlign, borderRadius: 0, datasetIndex: o.index } }, this) } }, title: { color: n => n.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: n => !n.startsWith("on"), labels: { _scriptable: n => !["generateLabels", "filter", "sort"].includes(n) } } }; class wm extends Hn { constructor(t) { super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e) { const i = this.options; if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0); this.width = this.right = t, this.height = this.bottom = e; const s = Le(i.text) ? i.text.length : 1; this._padding = Tt(i.padding); const r = s * dt(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = r : this.width = r } isHorizontal() { const t = this.options.position; return "top" === t || "bottom" === t } _drawArgs(t) { const { top: e, left: i, bottom: s, right: r, options: o } = this, a = o.align; let c, u, d, l = 0; return this.isHorizontal() ? (u = Mt(a, i, r), d = e + t, c = r - i) : ("left" === o.position ? (u = i + t, d = Mt(a, s, e), l = -.5 * He) : (u = r - t, d = Mt(a, e, s), l = .5 * He), c = s - e), { titleX: u, titleY: d, maxWidth: c, rotation: l } } draw() { const t = this.ctx, e = this.options; if (!e.display) return; const i = dt(e.font), r = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(r); Bs(t, e.text, 0, 0, i, { color: e.color, maxWidth: l, rotation: c, textAlign: Bg(e.align), textBaseline: "middle", translation: [o, a] }) } } var v2 = { id: "title", _element: wm, start(n, t, e) { !function IB(n, t) { const e = new wm({ ctx: n.ctx, options: t, chart: n }); At.configure(n, e, t), At.addBox(n, e), n.titleBlock = e }(n, e) }, stop(n) { At.removeBox(n, n.titleBlock), delete n.titleBlock }, beforeUpdate(n, t, e) { const i = n.titleBlock; At.configure(n, i, e), i.options = e }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const qa = { average(n) { if (!n.length) return !1; let t, e, i = 0, s = 0, r = 0; for (t = 0, e = n.length; t < e; ++t) { const o = n[t].element; if (o && o.hasValue()) { const a = o.tooltipPosition(); i += a.x, s += a.y, ++r } } return { x: i / r, y: s / r } }, nearest(n, t) { if (!n.length) return !1; let r, o, a, e = t.x, i = t.y, s = Number.POSITIVE_INFINITY; for (r = 0, o = n.length; r < o; ++r) { const l = n[r].element; if (l && l.hasValue()) { const u = $g(t, l.getCenterPoint()); u < s && (s = u, a = l) } } if (a) { const l = a.tooltipPosition(); e = l.x, i = l.y } return { x: e, y: i } } }; function si(n, t) { return t && (Le(t) ? Array.prototype.push.apply(n, t) : n.push(t)), n } function Ri(n) { return ("string" == typeof n || n instanceof String) && n.indexOf("\n") > -1 ? n.split("\n") : n } function RB(n, t) { const { element: e, datasetIndex: i, index: s } = t, r = n.getDatasetMeta(i).controller, { label: o, value: a } = r.getLabelAndValue(s); return { chart: n, label: o, parsed: r.getParsed(s), raw: n.data.datasets[i].data[s], formattedValue: a, dataset: r.getDataset(), dataIndex: s, datasetIndex: i, element: e } } function _2(n, t) { const e = n.chart.ctx, { body: i, footer: s, title: r } = n, { boxWidth: o, boxHeight: a } = t, l = dt(t.bodyFont), c = dt(t.titleFont), u = dt(t.footerFont), d = r.length, h = s.length, f = i.length, p = Tt(t.padding); let g = p.height, m = 0, y = i.reduce((D, x) => D + x.before.length + x.lines.length + x.after.length, 0); y += n.beforeBody.length + n.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), y && (g += f * (t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight) + (y - f) * l.lineHeight + (y - 1) * t.bodySpacing), h && (g += t.footerMarginTop + h * u.lineHeight + (h - 1) * t.footerSpacing); let b = 0; const v = function (D) { m = Math.max(m, e.measureText(D).width + b) }; return e.save(), e.font = c.string, xe(n.title, v), e.font = l.string, xe(n.beforeBody.concat(n.afterBody), v), b = t.displayColors ? o + 2 + t.boxPadding : 0, xe(i, D => { xe(D.before, v), xe(D.lines, v), xe(D.after, v) }), b = 0, e.font = u.string, xe(n.footer, v), e.restore(), m += p.width, { width: m, height: g } } function FB(n, t, e, i) { const { x: s, width: r } = e, { width: o, chartArea: { left: a, right: l } } = n; let c = "center"; return "center" === i ? c = s <= (a + l) / 2 ? "left" : "right" : s <= r / 2 ? c = "left" : s >= o - r / 2 && (c = "right"), function LB(n, t, e, i) { const { x: s, width: r } = i, o = e.caretSize + e.caretPadding; if ("left" === n && s + r + o > t.width || "right" === n && s - r - o < 0) return !0 }(c, n, t, e) && (c = "center"), c } function b2(n, t, e) { const i = e.yAlign || t.yAlign || function OB(n, t) { const { y: e, height: i } = t; return e < i / 2 ? "top" : e > n.height - i / 2 ? "bottom" : "center" }(n, e); return { xAlign: e.xAlign || t.xAlign || FB(n, t, e, i), yAlign: i } } function w2(n, t, e, i) { const { caretSize: s, caretPadding: r, cornerRadius: o } = n, { xAlign: a, yAlign: l } = e, c = s + r, { topLeft: u, topRight: d, bottomLeft: h, bottomRight: f } = Vs(o); let p = function NB(n, t) { let { x: e, width: i } = n; return "right" === t ? e -= i : "center" === t && (e -= i / 2), e }(t, a); const g = function jB(n, t, e) { let { y: i, height: s } = n; return "top" === t ? i += e : i -= "bottom" === t ? s + e : s / 2, i }(t, l, c); return "center" === l ? "left" === a ? p += c : "right" === a && (p -= c) : "left" === a ? p -= Math.max(u, h) + s : "right" === a && (p += Math.max(d, f) + s), { x: gt(p, 0, i.width - t.width), y: gt(g, 0, i.height - t.height) } } function Gu(n, t, e) { const i = Tt(e.padding); return "center" === t ? n.x + n.width / 2 : "right" === t ? n.x + n.width - i.right : n.x + i.left } function D2(n) { return si([], Ri(n)) } function x2(n, t) { const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks; return e ? n.override(e) : n } let C2 = (() => { class n extends Hn { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart || e._chart, this._chart = this.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const i = this.chart, s = this.options.setContext(this.getContext()), r = s.enabled && i.options.animation && s.animations, o = new cS(this.chart, r); return r._cacheable && (this._cachedAnimations = Object.freeze(o)), o } getContext() { return this.$context || (this.$context = function BB(n, t, e) { return is(n, { tooltip: t, tooltipItems: e, type: "tooltip" }) }(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, i) { const { callbacks: s } = i, r = s.beforeTitle.apply(this, [e]), o = s.title.apply(this, [e]), a = s.afterTitle.apply(this, [e]); let l = []; return l = si(l, Ri(r)), l = si(l, Ri(o)), l = si(l, Ri(a)), l } getBeforeBody(e, i) { return D2(i.callbacks.beforeBody.apply(this, [e])) } getBody(e, i) { const { callbacks: s } = i, r = []; return xe(e, o => { const a = { before: [], lines: [], after: [] }, l = x2(s, o); si(a.before, Ri(l.beforeLabel.call(this, o))), si(a.lines, l.label.call(this, o)), si(a.after, Ri(l.afterLabel.call(this, o))), r.push(a) }), r } getAfterBody(e, i) { return D2(i.callbacks.afterBody.apply(this, [e])) } getFooter(e, i) { const { callbacks: s } = i, r = s.beforeFooter.apply(this, [e]), o = s.footer.apply(this, [e]), a = s.afterFooter.apply(this, [e]); let l = []; return l = si(l, Ri(r)), l = si(l, Ri(o)), l = si(l, Ri(a)), l } _createItems(e) { const i = this._active, s = this.chart.data, r = [], o = [], a = []; let c, u, l = []; for (c = 0, u = i.length; c < u; ++c)l.push(RB(this.chart, i[c])); return e.filter && (l = l.filter((d, h, f) => e.filter(d, h, f, s))), e.itemSort && (l = l.sort((d, h) => e.itemSort(d, h, s))), xe(l, d => { const h = x2(e.callbacks, d); r.push(h.labelColor.call(this, d)), o.push(h.labelPointStyle.call(this, d)), a.push(h.labelTextColor.call(this, d)) }), this.labelColors = r, this.labelPointStyles = o, this.labelTextColors = a, this.dataPoints = l, l } update(e, i) { const s = this.options.setContext(this.getContext()), r = this._active; let o, a = []; if (r.length) { const l = qa[s.position].call(this, r, this._eventPosition); a = this._createItems(s), this.title = this.getTitle(a, s), this.beforeBody = this.getBeforeBody(a, s), this.body = this.getBody(a, s), this.afterBody = this.getAfterBody(a, s), this.footer = this.getFooter(a, s); const c = this._size = _2(this, s), u = Object.assign({}, l, c), d = b2(this.chart, s, u), h = w2(s, u, d, this.chart); this.xAlign = d.xAlign, this.yAlign = d.yAlign, o = { opacity: 1, x: h.x, y: h.y, width: c.width, height: c.height, caretX: l.x, caretY: l.y } } else 0 !== this.opacity && (o = { opacity: 0 }); this._tooltipItems = a, this.$context = void 0, o && this._resolveAnimations().update(this, o), e && s.external && s.external.call(this, { chart: this.chart, tooltip: this, replay: i }) } drawCaret(e, i, s, r) { const o = this.getCaretPosition(e, s, r); i.lineTo(o.x1, o.y1), i.lineTo(o.x2, o.y2), i.lineTo(o.x3, o.y3) } getCaretPosition(e, i, s) { const { xAlign: r, yAlign: o } = this, { caretSize: a, cornerRadius: l } = s, { topLeft: c, topRight: u, bottomLeft: d, bottomRight: h } = Vs(l), { x: f, y: p } = e, { width: g, height: m } = i; let y, b, v, D, x, S; return "center" === o ? (x = p + m / 2, "left" === r ? (y = f, b = y - a, D = x + a, S = x - a) : (y = f + g, b = y + a, D = x - a, S = x + a), v = y) : (b = "left" === r ? f + Math.max(c, d) + a : "right" === r ? f + g - Math.max(u, h) - a : this.caretX, "top" === o ? (D = p, x = D - a, y = b - a, v = b + a) : (D = p + m, x = D + a, y = b + a, v = b - a), S = D), { x1: y, x2: b, x3: v, y1: D, y2: x, y3: S } } drawTitle(e, i, s) { const r = this.title, o = r.length; let a, l, c; if (o) { const u = qr(s.rtl, this.x, this.width); for (e.x = Gu(this, s.titleAlign, s), i.textAlign = u.textAlign(s.titleAlign), i.textBaseline = "middle", a = dt(s.titleFont), l = s.titleSpacing, i.fillStyle = s.titleColor, i.font = a.string, c = 0; c < o; ++c)i.fillText(r[c], u.x(e.x), e.y + a.lineHeight / 2), e.y += a.lineHeight + l, c + 1 === o && (e.y += s.titleMarginBottom - l) } } _drawColorBox(e, i, s, r, o) { const a = this.labelColors[s], l = this.labelPointStyles[s], { boxHeight: c, boxWidth: u, boxPadding: d } = o, h = dt(o.bodyFont), f = Gu(this, "left", o), p = r.x(f), m = i.y + (c < h.lineHeight ? (h.lineHeight - c) / 2 : 0); if (o.usePointStyle) { const y = { radius: Math.min(u, c) / 2, pointStyle: l.pointStyle, rotation: l.rotation, borderWidth: 1 }, b = r.leftForLtr(p, u) + u / 2, v = m + c / 2; e.strokeStyle = o.multiKeyBackground, e.fillStyle = o.multiKeyBackground, Pu(e, y, b, v), e.strokeStyle = a.borderColor, e.fillStyle = a.backgroundColor, Pu(e, y, b, v) } else { e.lineWidth = a.borderWidth || 1, e.strokeStyle = a.borderColor, e.setLineDash(a.borderDash || []), e.lineDashOffset = a.borderDashOffset || 0; const y = r.leftForLtr(p, u - d), b = r.leftForLtr(r.xPlus(p, 1), u - d - 2), v = Vs(a.borderRadius); Object.values(v).some(D => 0 !== D) ? (e.beginPath(), e.fillStyle = o.multiKeyBackground, Ia(e, { x: y, y: m, w: u, h: c, radius: v }), e.fill(), e.stroke(), e.fillStyle = a.backgroundColor, e.beginPath(), Ia(e, { x: b, y: m + 1, w: u - 2, h: c - 2, radius: v }), e.fill()) : (e.fillStyle = o.multiKeyBackground, e.fillRect(y, m, u, c), e.strokeRect(y, m, u, c), e.fillStyle = a.backgroundColor, e.fillRect(b, m + 1, u - 2, c - 2)) } e.fillStyle = this.labelTextColors[s] } drawBody(e, i, s) { const { body: r } = this, { bodySpacing: o, bodyAlign: a, displayColors: l, boxHeight: c, boxWidth: u, boxPadding: d } = s, h = dt(s.bodyFont); let f = h.lineHeight, p = 0; const g = qr(s.rtl, this.x, this.width), m = function (B) { i.fillText(B, g.x(e.x + p), e.y + f / 2), e.y += f + o }, y = g.textAlign(a); let b, v, D, x, S, A, F; for (i.textAlign = a, i.textBaseline = "middle", i.font = h.string, e.x = Gu(this, y, s), i.fillStyle = s.bodyColor, xe(this.beforeBody, m), p = l && "right" !== y ? "center" === a ? u / 2 + d : u + 2 + d : 0, x = 0, A = r.length; x < A; ++x) { for (b = r[x], v = this.labelTextColors[x], i.fillStyle = v, xe(b.before, m), D = b.lines, l && D.length && (this._drawColorBox(i, e, x, g, s), f = Math.max(h.lineHeight, c)), S = 0, F = D.length; S < F; ++S)m(D[S]), f = h.lineHeight; xe(b.after, m) } p = 0, f = h.lineHeight, xe(this.afterBody, m), e.y -= o } drawFooter(e, i, s) { const r = this.footer, o = r.length; let a, l; if (o) { const c = qr(s.rtl, this.x, this.width); for (e.x = Gu(this, s.footerAlign, s), e.y += s.footerMarginTop, i.textAlign = c.textAlign(s.footerAlign), i.textBaseline = "middle", a = dt(s.footerFont), i.fillStyle = s.footerColor, i.font = a.string, l = 0; l < o; ++l)i.fillText(r[l], c.x(e.x), e.y + a.lineHeight / 2), e.y += a.lineHeight + s.footerSpacing } } drawBackground(e, i, s, r) { const { xAlign: o, yAlign: a } = this, { x: l, y: c } = e, { width: u, height: d } = s, { topLeft: h, topRight: f, bottomLeft: p, bottomRight: g } = Vs(r.cornerRadius); i.fillStyle = r.backgroundColor, i.strokeStyle = r.borderColor, i.lineWidth = r.borderWidth, i.beginPath(), i.moveTo(l + h, c), "top" === a && this.drawCaret(e, i, s, r), i.lineTo(l + u - f, c), i.quadraticCurveTo(l + u, c, l + u, c + f), "center" === a && "right" === o && this.drawCaret(e, i, s, r), i.lineTo(l + u, c + d - g), i.quadraticCurveTo(l + u, c + d, l + u - g, c + d), "bottom" === a && this.drawCaret(e, i, s, r), i.lineTo(l + p, c + d), i.quadraticCurveTo(l, c + d, l, c + d - p), "center" === a && "left" === o && this.drawCaret(e, i, s, r), i.lineTo(l, c + h), i.quadraticCurveTo(l, c, l + h, c), i.closePath(), i.fill(), r.borderWidth > 0 && i.stroke() } _updateAnimationTarget(e) { const i = this.chart, s = this.$animations, r = s && s.x, o = s && s.y; if (r || o) { const a = qa[e.position].call(this, this._active, this._eventPosition); if (!a) return; const l = this._size = _2(this, e), c = Object.assign({}, a, this._size), u = b2(i, e, c), d = w2(e, c, u, i); (r._to !== d.x || o._to !== d.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = l.width, this.height = l.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, d)) } } _willRender() { return !!this.opacity } draw(e) { const i = this.options.setContext(this.getContext()); let s = this.opacity; if (!s) return; this._updateAnimationTarget(i); const r = { width: this.width, height: this.height }, o = { x: this.x, y: this.y }; s = Math.abs(s) < .001 ? 0 : s; const a = Tt(i.padding); i.enabled && (this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length) && (e.save(), e.globalAlpha = s, this.drawBackground(o, e, r, i), eS(e, i.textDirection), o.y += a.top, this.drawTitle(o, e, i), this.drawBody(o, e, i), this.drawFooter(o, e, i), tS(e, i.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, i) { const s = this._active, r = e.map(({ datasetIndex: l, index: c }) => { const u = this.chart.getDatasetMeta(l); if (!u) throw new Error("Cannot find a dataset at index " + l); return { datasetIndex: l, element: u.data[c], index: c } }), o = !xu(s, r), a = this._positionChanged(r, i); (o || a) && (this._active = r, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, i, s = !0) { if (i && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const r = this.options, o = this._active || [], a = this._getActiveElements(e, o, i, s), l = this._positionChanged(a, e), c = i || !xu(a, o) || l; return c && (this._active = a, (r.enabled || r.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, i))), c } _getActiveElements(e, i, s, r) { const o = this.options; if ("mouseout" === e.type) return []; if (!r) return i; const a = this.chart.getElementsAtEventForMode(e, o.mode, o, s); return o.reverse && a.reverse(), a } _positionChanged(e, i) { const { caretX: s, caretY: r, options: o } = this, a = qa[o.position].call(this, e, i); return !1 !== a && (s !== a.x || r !== a.y) } } return n.positioners = qa, n })(); var S2 = { id: "tooltip", _element: C2, positioners: qa, afterInit(n, t, e) { e && (n.tooltip = new C2({ chart: n, options: e })) }, beforeUpdate(n, t, e) { n.tooltip && n.tooltip.initialize(e) }, reset(n, t, e) { n.tooltip && n.tooltip.initialize(e) }, afterDraw(n) { const t = n.tooltip; if (t && t._willRender()) { const e = { tooltip: t }; if (!1 === n.notifyPlugins("beforeTooltipDraw", e)) return; t.draw(n.ctx), n.notifyPlugins("afterTooltipDraw", e) } }, afterEvent(n, t) { n.tooltip && n.tooltip.handleEvent(t.event, t.replay, t.inChartArea) && (t.changed = !0) }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (n, t) => t.bodyFont.size, boxWidth: (n, t) => t.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: { beforeTitle: Ei, title(n) { if (n.length > 0) { const t = n[0], e = t.chart.data.labels, i = e ? e.length : 0; if (this && this.options && "dataset" === this.options.mode) return t.dataset.label || ""; if (t.label) return t.label; if (i > 0 && t.dataIndex < i) return e[t.dataIndex] } return "" }, afterTitle: Ei, beforeBody: Ei, beforeLabel: Ei, label(n) { if (this && this.options && "dataset" === this.options.mode) return n.label + ": " + n.formattedValue || n.formattedValue; let t = n.dataset.label || ""; t && (t += ": "); const e = n.formattedValue; return ye(e) || (t += e), t }, labelColor(n) { const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex); return { borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(n) { const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex); return { pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: Ei, afterBody: Ei, beforeFooter: Ei, footer: Ei, afterFooter: Ei } }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: n => "filter" !== n && "itemSort" !== n && "external" !== n, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }; class Ga extends Ws { constructor(t) { super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(t) { const e = this._addedLabels; if (e.length) { const i = this.getLabels(); for (const { index: s, label: r } of e) i[s] === r && i.splice(s, 1); this._addedLabels = [] } super.init(t) } parse(t, e) { if (ye(t)) return null; const i = this.getLabels(); return ((n, t) => null === n ? null : gt(Math.round(n), 0, t))(e = isFinite(e) && i[e] === t ? e : function $B(n, t, e, i) { const s = n.indexOf(t); return -1 === s ? ((n, t, e, i) => ("string" == typeof t ? (e = n.push(t) - 1, i.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e))(n, t, e, i) : s !== n.lastIndexOf(t) ? e : s }(i, t, re(e, t), this._addedLabels), i.length - 1) } determineDataLimits() { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let { min: i, max: s } = this.getMinMax(!0); "ticks" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s } buildTicks() { const t = this.min, e = this.max, i = this.options.offset, s = []; let r = this.getLabels(); r = 0 === t && e === r.length - 1 ? r : r.slice(t, e + 1), this._valueRange = Math.max(r.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let o = t; o <= e; o++)s.push({ value: o }); return s } getLabelForValue(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(t) { return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getValueForPixel(t) { return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } getBasePixel() { return this.bottom } } function E2(n, t, { horizontal: e, minRotation: i }) { const s = Vn(i), r = (e ? Math.sin(s) : Math.cos(s)) || .001; return Math.min(t / r, .75 * t * ("" + n).length) } Ga.id = "category", Ga.defaults = { ticks: { callback: Ga.prototype.getLabelForValue } }; class Ku extends Ws { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(t, e) { return ye(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions() { const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds(); let { min: s, max: r } = this; const o = l => s = e ? s : l, a = l => r = i ? r : l; if (t) { const l = ii(s), c = ii(r); l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0) } if (s === r) { let l = 1; (r >= Number.MAX_SAFE_INTEGER || s <= Number.MIN_SAFE_INTEGER) && (l = Math.abs(.05 * r)), a(r + l), t || o(s - l) } this.min = s, this.max = r } getTickLimit() { const t = this.options.ticks; let s, { maxTicksLimit: e, stepSize: i } = t; return i ? (s = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), e = e || 11), e && (s = Math.min(e, s)), s } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const t = this.options, e = t.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const o = function UB(n, t) { const e = [], { bounds: s, step: r, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: h } = n, f = r || 1, p = u - 1, { min: g, max: m } = t, y = !ye(o), b = !ye(a), v = !ye(c), D = (m - g) / (d + 1); let S, A, F, B, x = wC((m - g) / p / f) * f; if (x < 1e-14 && !y && !b) return [{ value: g }, { value: m }]; B = Math.ceil(m / x) - Math.floor(g / x), B > p && (x = wC(B * x / p / f) * f), ye(l) || (S = Math.pow(10, l), x = Math.ceil(x * S) / S), "ticks" === s ? (A = Math.floor(g / x) * x, F = Math.ceil(m / x) * x) : (A = g, F = m), y && b && r && function L6(n, t) { const e = Math.round(n); return e - t <= n && e + t >= n }((a - o) / r, x / 1e3) ? (B = Math.round(Math.min((a - o) / x, u)), x = (a - o) / B, A = o, F = a) : v ? (A = y ? o : A, F = b ? a : F, B = c - 1, x = (F - A) / B) : (B = (F - A) / x, B = Ca(B, Math.round(B), x / 1e3) ? Math.round(B) : Math.ceil(B)); const te = Math.max(xC(x), xC(A)); S = Math.pow(10, ye(l) ? te : l), A = Math.round(A * S) / S, F = Math.round(F * S) / S; let oe = 0; for (y && (h && A !== o ? (e.push({ value: o }), A < o && oe++, Ca(Math.round((A + oe * x) * S) / S, o, E2(o, D, n)) && oe++) : A < o && oe++); oe < B; ++oe)e.push({ value: Math.round((A + oe * x) * S) / S }); return b && h && F !== a ? e.length && Ca(e[e.length - 1].value, a, E2(a, D, n)) ? e[e.length - 1].value = a : e.push({ value: a }) : (!b || F === a) && e.push({ value: F }), e }({ maxTicks: i, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: !1 !== e.includeBounds }, this._range || this); return "ticks" === t.bounds && DC(o, this, "value"), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const t = this.ticks; let e = this.min, i = this.max; if (super.configure(), this.options.offset && t.length) { const s = (i - e) / Math.max(t.length - 1, 1) / 2; e -= s, i += s } this._startValue = e, this._endValue = i, this._valueRange = i - e } getLabelForValue(t) { return Ra(t, this.chart.options.locale, this.options.ticks.format) } } class Qu extends Ku { determineDataLimits() { const { min: t, max: e } = this.getMinMax(!0); this.min = Ze(t) ? t : 0, this.max = Ze(e) ? e : 1, this.handleTickRangeOptions() } computeTickLimit() { const t = this.isHorizontal(), e = t ? this.width : this.height, i = Vn(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, r = this._resolveTickFontOptions(0); return Math.ceil(e / Math.min(40, r.lineHeight / s)) } getPixelForValue(t) { return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel(t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } } function M2(n) { return n / Math.pow(10, Math.floor(Dn(n))) == 1 } Qu.id = "linear", Qu.defaults = { ticks: { callback: Hu.formatters.numeric } }; class Zu extends Ws { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(t, e) { const i = Ku.prototype.parse.apply(this, [t, e]); if (0 !== i) return Ze(i) && i > 0 ? i : null; this._zero = !0 } determineDataLimits() { const { min: t, max: e } = this.getMinMax(!0); this.min = Ze(t) ? Math.max(0, t) : null, this.max = Ze(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let i = this.min, s = this.max; const r = l => i = t ? i : l, o = l => s = e ? s : l, a = (l, c) => Math.pow(10, Math.floor(Dn(l)) + c); i === s && (i <= 0 ? (r(1), o(10)) : (r(a(i, -1)), o(a(s, 1)))), i <= 0 && r(a(s, -1)), s <= 0 && o(a(i, 1)), this._zero && this.min !== this._suggestedMin && i === a(this.min, 0) && r(a(i, -1)), this.min = i, this.max = s } buildTicks() { const t = this.options, i = function WB(n, t) { const e = Math.floor(Dn(t.max)), i = Math.ceil(t.max / Math.pow(10, e)), s = []; let r = bn(n.min, Math.pow(10, Math.floor(Dn(t.min)))), o = Math.floor(Dn(r)), a = Math.floor(r / Math.pow(10, o)), l = o < 0 ? Math.pow(10, Math.abs(o)) : 1; do { s.push({ value: r, major: M2(r) }), ++a, 10 === a && (a = 1, ++o, l = o >= 0 ? 1 : l), r = Math.round(a * Math.pow(10, o) * l) / l } while (o < e || o === e && a < i); const c = bn(n.max, r); return s.push({ value: c, major: M2(r) }), s }({ min: this._userMin, max: this._userMax }, this); return "ticks" === t.bounds && DC(i, this, "value"), t.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } getLabelForValue(t) { return void 0 === t ? "0" : Ra(t, this.chart.options.locale, this.options.ticks.format) } configure() { const t = this.min; super.configure(), this._startValue = Dn(t), this._valueRange = Dn(this.max) - Dn(t) } getPixelForValue(t) { return (void 0 === t || 0 === t) && (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Dn(t) - this._startValue) / this._valueRange) } getValueForPixel(t) { const e = this.getDecimalForPixel(t); return Math.pow(10, this._startValue + e * this._valueRange) } } function Dm(n) { const t = n.ticks; if (t.display && n.display) { const e = Tt(t.backdropPadding); return re(t.font && t.font.size, ge.font.size) + e.height } return 0 } function qB(n, t, e) { return e = Le(e) ? e : [e], { w: l7(n, t.string, e), h: e.length * t.lineHeight } } function T2(n, t, e, i, s) { return n === i || n === s ? { start: t - e / 2, end: t + e / 2 } : n < i || n > s ? { start: t - e, end: t } : { start: t, end: t + e } } function KB(n, t, e, i, s) { const r = Math.abs(Math.sin(e)), o = Math.abs(Math.cos(e)); let a = 0, l = 0; i.start < t.l ? (a = (t.l - i.start) / r, n.l = Math.min(n.l, t.l - a)) : i.end > t.r && (a = (i.end - t.r) / r, n.r = Math.max(n.r, t.r + a)), s.start < t.t ? (l = (t.t - s.start) / o, n.t = Math.min(n.t, t.t - l)) : s.end > t.b && (l = (s.end - t.b) / o, n.b = Math.max(n.b, t.b + l)) } function ZB(n) { return 0 === n || 180 === n ? "center" : n < 180 ? "left" : "right" } function YB(n, t, e) { return "right" === e ? n -= t : "center" === e && (n -= t / 2), n } function XB(n, t, e) { return 90 === e || 270 === e ? n -= t / 2 : (e > 270 || e < 90) && (n -= t), n } function A2(n, t, e, i) { const { ctx: s } = n; if (e) s.arc(n.xCenter, n.yCenter, t, 0, Te); else { let r = n.getPointPosition(0, t); s.moveTo(r.x, r.y); for (let o = 1; o < i; o++)r = n.getPointPosition(o, t), s.lineTo(r.x, r.y) } } Zu.id = "logarithmic", Zu.defaults = { ticks: { callback: Hu.formatters.logarithmic, major: { enabled: !0 } } }; class Kr extends Ku { constructor(t) { super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const t = this._padding = Tt(Dm(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height; this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2) } determineDataLimits() { const { min: t, max: e } = this.getMinMax(!1); this.min = Ze(t) && !isNaN(t) ? t : 0, this.max = Ze(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Dm(this.options)) } generateTickLabels(t) { Ku.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, i) => { const s = Fe(this.options.pointLabels.callback, [e, i], this); return s || 0 === s ? s : "" }).filter((e, i) => this.chart.getDataVisibility(i)) } fit() { const t = this.options; t.display && t.pointLabels.display ? function GB(n) { const t = { l: n.left + n._padding.left, r: n.right - n._padding.right, t: n.top + n._padding.top, b: n.bottom - n._padding.bottom }, e = Object.assign({}, t), i = [], s = [], r = n._pointLabels.length, o = n.options.pointLabels, a = o.centerPointLabels ? He / r : 0; for (let l = 0; l < r; l++) { const c = o.setContext(n.getPointLabelContext(l)); s[l] = c.padding; const u = n.getPointPosition(l, n.drawingArea + s[l], a), d = dt(c.font), h = qB(n.ctx, d, n._pointLabels[l]); i[l] = h; const f = cn(n.getIndexAngle(l) + a), p = Math.round(Hg(f)); KB(e, t, f, T2(p, u.x, h.w, 0, 180), T2(p, u.y, h.h, 90, 270)) } n.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), n._pointLabelItems = function QB(n, t, e) { const i = [], s = n._pointLabels.length, r = n.options, o = Dm(r) / 2, a = n.drawingArea, l = r.pointLabels.centerPointLabels ? He / s : 0; for (let c = 0; c < s; c++) { const u = n.getPointPosition(c, a + o + e[c], l), d = Math.round(Hg(cn(u.angle + Ge))), h = t[c], f = XB(u.y, h.h, d), p = ZB(d), g = YB(u.x, h.w, p); i.push({ x: u.x, y: f, textAlign: p, left: g, top: f, right: g + h.w, bottom: f + h.h }) } return i }(n, i, s) }(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(t, e, i, s) { this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s)) } getIndexAngle(t) { return cn(t * (Te / (this._pointLabels.length || 1)) + Vn(this.options.startAngle || 0)) } getDistanceFromCenterForValue(t) { if (ye(t)) return NaN; const e = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * e : (t - this.min) * e } getValueForDistanceFromCenter(t) { if (ye(t)) return NaN; const e = t / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - e : this.min + e } getPointLabelContext(t) { const e = this._pointLabels || []; if (t >= 0 && t < e.length) { const i = e[t]; return function tV(n, t, e) { return is(n, { label: e, index: t, type: "pointLabel" }) }(this.getContext(), t, i) } } getPointPosition(t, e, i = 0) { const s = this.getIndexAngle(t) - Ge + i; return { x: Math.cos(s) * e + this.xCenter, y: Math.sin(s) * e + this.yCenter, angle: s } } getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } getBasePosition(t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition(t) { const { left: e, top: i, right: s, bottom: r } = this._pointLabelItems[t]; return { left: e, top: i, right: s, bottom: r } } drawBackground() { const { backgroundColor: t, grid: { circular: e } } = this.options; if (t) { const i = this.ctx; i.save(), i.beginPath(), A2(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore() } } drawGrid() { const t = this.ctx, e = this.options, { angleLines: i, grid: s } = e, r = this._pointLabels.length; let o, a, l; if (e.pointLabels.display && function JB(n, t) { const { ctx: e, options: { pointLabels: i } } = n; for (let s = t - 1; s >= 0; s--) { const r = i.setContext(n.getPointLabelContext(s)), o = dt(r.font), { x: a, y: l, textAlign: c, left: u, top: d, right: h, bottom: f } = n._pointLabelItems[s], { backdropColor: p } = r; if (!ye(p)) { const g = Vs(r.borderRadius), m = Tt(r.backdropPadding); e.fillStyle = p; const y = u - m.left, b = d - m.top, v = h - u + m.width, D = f - d + m.height; Object.values(g).some(x => 0 !== x) ? (e.beginPath(), Ia(e, { x: y, y: b, w: v, h: D, radius: g }), e.fill()) : e.fillRect(y, b, v, D) } Bs(e, n._pointLabels[s], a, l + o.lineHeight / 2, o, { color: r.color, textAlign: c, textBaseline: "middle" }) } }(this, r), s.display && this.ticks.forEach((c, u) => { 0 !== u && (a = this.getDistanceFromCenterForValue(c.value), function eV(n, t, e, i) { const s = n.ctx, r = t.circular, { color: o, lineWidth: a } = t; !r && !i || !o || !a || e < 0 || (s.save(), s.strokeStyle = o, s.lineWidth = a, s.setLineDash(t.borderDash), s.lineDashOffset = t.borderDashOffset, s.beginPath(), A2(n, e, r, i), s.closePath(), s.stroke(), s.restore()) }(this, s.setContext(this.getContext(u - 1)), a, r)) }), i.display) { for (t.save(), o = r - 1; o >= 0; o--) { const c = i.setContext(this.getPointLabelContext(o)), { color: u, lineWidth: d } = c; !d || !u || (t.lineWidth = d, t.strokeStyle = u, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(o, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke()) } t.restore() } } drawBorder() { } drawLabels() { const t = this.ctx, e = this.options, i = e.ticks; if (!i.display) return; const s = this.getIndexAngle(0); let r, o; t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((a, l) => { if (0 === l && !e.reverse) return; const c = i.setContext(this.getContext(l)), u = dt(c.font); if (r = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) { t.font = u.string, o = t.measureText(a.label).width, t.fillStyle = c.backdropColor; const d = Tt(c.backdropPadding); t.fillRect(-o / 2 - d.left, -r - u.size / 2 - d.top, o + d.width, u.size + d.height) } Bs(t, a.label, 0, -r, u, { color: c.color }) }), t.restore() } drawTitle() { } } Kr.id = "radialLinear", Kr.defaults = { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Hu.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: n => n, padding: 5, centerPointLabels: !1 } }, Kr.defaultRoutes = { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }, Kr.descriptors = { angleLines: { _fallback: "grid" } }; const Yu = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Gt = Object.keys(Yu); function nV(n, t) { return n - t } function k2(n, t) { if (ye(t)) return null; const e = n._adapter, { parser: i, round: s, isoWeekday: r } = n._parseOpts; let o = t; return "function" == typeof i && (o = i(o)), Ze(o) || (o = "string" == typeof i ? e.parse(o, i) : e.parse(o)), null === o ? null : (s && (o = "week" !== s || !xa(r) && !0 !== r ? e.startOf(o, s) : e.startOf(o, "isoWeek", r)), +o) } function I2(n, t, e, i) { const s = Gt.length; for (let r = Gt.indexOf(n); r < s - 1; ++r) { const o = Yu[Gt[r]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((e - t) / (a * o.size)) <= i) return Gt[r] } return Gt[s - 1] } function P2(n, t, e) { if (e) { if (e.length) { const { lo: i, hi: s } = Xg(e, t); n[e[i] >= t ? e[i] : e[s]] = !0 } } else n[t] = !0 } function R2(n, t, e) { const i = [], s = {}, r = t.length; let o, a; for (o = 0; o < r; ++o)a = t[o], s[a] = o, i.push({ value: a, major: !1 }); return 0 !== r && e ? function rV(n, t, e, i) { const s = n._adapter, r = +s.startOf(t[0].value, i), o = t[t.length - 1].value; let a, l; for (a = r; a <= o; a = +s.add(a, 1, i))l = e[a], l >= 0 && (t[l].major = !0); return t }(n, i, s, e) : i } let Xu = (() => { class n extends Ws { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, i) { const s = e.time || (e.time = {}), r = this._adapter = new P9._date(e.adapters.date); wa(s.displayFormats, r.formats()), this._parseOpts = { parser: s.parser, round: s.round, isoWeekday: s.isoWeekday }, super.init(e), this._normalized = i.normalized } parse(e, i) { return void 0 === e ? null : k2(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, i = this._adapter, s = e.time.unit || "day"; let { min: r, max: o, minDefined: a, maxDefined: l } = this.getUserBounds(); function c(u) { !a && !isNaN(u.min) && (r = Math.min(r, u.min)), !l && !isNaN(u.max) && (o = Math.max(o, u.max)) } (!a || !l) && (c(this._getLabelBounds()), ("ticks" !== e.bounds || "labels" !== e.ticks.source) && c(this.getMinMax(!1))), r = Ze(r) && !isNaN(r) ? r : +i.startOf(Date.now(), s), o = Ze(o) && !isNaN(o) ? o : +i.endOf(Date.now(), s) + 1, this.min = Math.min(r, o - 1), this.max = Math.max(r + 1, o) } _getLabelBounds() { const e = this.getLabelTimestamps(); let i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY; return e.length && (i = e[0], s = e[e.length - 1]), { min: i, max: s } } buildTicks() { const e = this.options, i = e.time, s = e.ticks, r = "labels" === s.source ? this.getLabelTimestamps() : this._generate(); "ticks" === e.bounds && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]); const o = this.min, l = function _7(n, t, e) { let i = 0, s = n.length; for (; i < s && n[i] < t;)i++; for (; s > i && n[s - 1] > e;)s--; return i > 0 || s < n.length ? n.slice(i, s) : n }(r, o, this.max); return this._unit = i.unit || (s.autoSkip ? I2(i.minUnit, this.min, this.max, this._getLabelCapacity(o)) : function iV(n, t, e, i, s) { for (let r = Gt.length - 1; r >= Gt.indexOf(e); r--) { const o = Gt[r]; if (Yu[o].common && n._adapter.diff(s, i, o) >= t - 1) return o } return Gt[e ? Gt.indexOf(e) : 0] }(this, l.length, i.minUnit, this.min, this.max)), this._majorUnit = s.major.enabled && "year" !== this._unit ? function sV(n) { for (let t = Gt.indexOf(n) + 1, e = Gt.length; t < e; ++t)if (Yu[Gt[t]].common) return Gt[t] }(this._unit) : void 0, this.initOffsets(r), e.reverse && l.reverse(), R2(this, l, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e) { let r, o, i = 0, s = 0; this.options.offset && e.length && (r = this.getDecimalForValue(e[0]), i = 1 === e.length ? 1 - r : (this.getDecimalForValue(e[1]) - r) / 2, o = this.getDecimalForValue(e[e.length - 1]), s = 1 === e.length ? o : (o - this.getDecimalForValue(e[e.length - 2])) / 2); const a = e.length < 3 ? .5 : .25; i = gt(i, 0, a), s = gt(s, 0, a), this._offsets = { start: i, end: s, factor: 1 / (i + 1 + s) } } _generate() { const e = this._adapter, i = this.min, s = this.max, r = this.options, o = r.time, a = o.unit || I2(o.minUnit, i, s, this._getLabelCapacity(i)), l = re(o.stepSize, 1), c = "week" === a && o.isoWeekday, u = xa(c) || !0 === c, d = {}; let f, p, h = i; if (u && (h = +e.startOf(h, "isoWeek", c)), h = +e.startOf(h, u ? "day" : a), e.diff(s, i, a) > 1e5 * l) throw new Error(i + " and " + s + " are too far apart with stepSize of " + l + " " + a); const g = "data" === r.ticks.source && this.getDataTimestamps(); for (f = h, p = 0; f < s; f = +e.add(f, l, a), p++)P2(d, f, g); return (f === s || "ticks" === r.bounds || 1 === p) && P2(d, f, g), Object.keys(d).sort((m, y) => m - y).map(m => +m) } getLabelForValue(e) { const s = this.options.time; return this._adapter.format(e, s.tooltipFormat ? s.tooltipFormat : s.displayFormats.datetime) } _tickFormatFunction(e, i, s, r) { const o = this.options, a = o.time.displayFormats, l = this._unit, c = this._majorUnit, d = c && a[c], h = s[i], p = this._adapter.format(e, r || (c && d && h && h.major ? d : l && a[l])), g = o.ticks.callback; return g ? Fe(g, [p, i, s], this) : p } generateTickLabels(e) { let i, s, r; for (i = 0, s = e.length; i < s; ++i)r = e[i], r.label = this._tickFormatFunction(r.value, i, e) } getDecimalForValue(e) { return null === e ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const i = this._offsets, s = this.getDecimalForValue(e); return this.getPixelForDecimal((i.start + s) * i.factor) } getValueForPixel(e) { const i = this._offsets, s = this.getDecimalForPixel(e) / i.factor - i.end; return this.min + s * (this.max - this.min) } _getLabelSize(e) { const i = this.options.ticks, s = this.ctx.measureText(e).width, r = Vn(this.isHorizontal() ? i.maxRotation : i.minRotation), o = Math.cos(r), a = Math.sin(r), l = this._resolveTickFontOptions(0).size; return { w: s * o + l * a, h: s * a + l * o } } _getLabelCapacity(e) { const i = this.options.time, s = i.displayFormats, r = s[i.unit] || s.millisecond, o = this._tickFormatFunction(e, 0, R2(this, [e], this._majorUnit), r), a = this._getLabelSize(o), l = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1; return l > 0 ? l : 1 } getDataTimestamps() { let i, s, e = this._cache.data || []; if (e.length) return e; const r = this.getMatchingVisibleMetas(); if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this); for (i = 0, s = r.length; i < s; ++i)e = e.concat(r[i].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let i, s; if (e.length) return e; const r = this.getLabels(); for (i = 0, s = r.length; i < s; ++i)e.push(k2(this, r[i])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return HC(e.sort(nV)) } } return n.id = "time", n.defaults = { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", major: { enabled: !1 } } }, n })(); function Ju(n, t, e) { let r, o, a, l, i = 0, s = n.length - 1; e ? (t >= n[i].pos && t <= n[s].pos && ({ lo: i, hi: s } = Ai(n, "pos", t)), ({ pos: r, time: a } = n[i]), ({ pos: o, time: l } = n[s])) : (t >= n[i].time && t <= n[s].time && ({ lo: i, hi: s } = Ai(n, "time", t)), ({ time: r, pos: a } = n[i]), ({ time: o, pos: l } = n[s])); const c = o - r; return c ? a + (l - a) * (t - r) / c : a } class ed extends Xu { constructor(t) { super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t); this._minPos = Ju(e, this.min), this._tableRange = Ju(e, this.max) - this._minPos, super.initOffsets(t) } buildLookupTable(t) { const { min: e, max: i } = this, s = [], r = []; let o, a, l, c, u; for (o = 0, a = t.length; o < a; ++o)c = t[o], c >= e && c <= i && s.push(c); if (s.length < 2) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; for (o = 0, a = s.length; o < a; ++o)u = s[o + 1], l = s[o - 1], c = s[o], Math.round((u + l) / 2) !== c && r.push({ time: c, pos: o / (a - 1) }); return r } _getTimestampsForTable() { let t = this._cache.all || []; if (t.length) return t; const e = this.getDataTimestamps(), i = this.getLabelTimestamps(); return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t } getDecimalForValue(t) { return (Ju(this._table, t) - this._minPos) / this._tableRange } getValueForPixel(t) { const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end; return Ju(this._table, i * this._tableRange + this._minPos, !0) } } function aV(n, t) { if (1 & n) { const e = Ds(); _(0, "div", 137)(1, "div", 138)(2, "a", 139), Pe("click", function () { return xt(e), Ct(lt().translateLanguage("es")) }), C(3, "img", 140), _(4, "span", 141), I(5), R(6, "translate"), w()(), _(7, "a", 142), Pe("click", function () { return xt(e), Ct(lt().translateLanguage("en")) }), C(8, "img", 143), _(9, "span", 141), I(10), R(11, "translate"), w()(), _(12, "a", 142), Pe("click", function () { return xt(e), Ct(lt().translateLanguage("ru")) }), C(13, "img", 144), _(14, "span", 141), I(15), R(16, "translate"), w()()()() } 2 & n && (M(5), fe(" ", O(6, 3, "startingpage.spanish"), " "), M(5), fe(" ", O(11, 5, "startingpage.english"), " "), M(5), fe(" ", O(16, 7, "startingpage.russian"), " ")) } function lV(n, t) { if (1 & n) { const e = Ds(); _(0, "div", 145)(1, "a", 146), Pe("click", function () { xt(e); const s = lt(), r = gi(43); return Ct(s.scroll(r)) }), I(2), R(3, "translate"), w(), _(4, "a", 146), Pe("click", function () { xt(e); const s = lt(), r = gi(72); return Ct(s.scroll(r)) }), I(5), R(6, "translate"), w(), _(7, "a", 146), Pe("click", function () { xt(e); const s = lt(), r = gi(187); return Ct(s.scroll(r)) }), I(8), R(9, "translate"), w(), _(10, "a", 146), Pe("click", function () { xt(e); const s = lt(), r = gi(197); return Ct(s.scroll(r)) }), I(11), R(12, "translate"), w(), _(13, "a", 147), I(14, "404"), w()() } 2 & n && (M(2), q(O(3, 4, "startingpage.navbar2")), M(3), q(O(6, 6, "startingpage.navbar6")), M(3), q(O(9, 8, "startingpage.navbar3")), M(3), q(O(12, 10, "startingpage.navbar4"))) } function cV(n, t) { if (1 & n && (_(0, "div", 149), C(1, "img", 150), w()), 2 & n) { const e = lt().$implicit; M(1), De("src", "../assets/resources/public/" + e, hr) } } function uV(n, t) { 1 & n && jt(0, cV, 2, 1, "ng-template", 148) } ed.id = "timeseries", ed.defaults = Xu.defaults; const dV = [{ path: "", redirectTo: "/", pathMatch: "full" }, { path: "", component: (() => { class n { constructor(e) { this.translate = e, this.barChartOptions = { responsive: !0 }, this.chart = null, this.selectLang = "", this.TransLang = [], this.dark = !1, this.showDropdownLanguages = !1, this.showNavbarMovile = !1, this.imgUrls = ["algoritmos.jpg", "programacion-estructurada.jpg", "angular.jpg", "python.jpg", "c-plus-plus.jpg", "redes.jpg", "diploma-oop.jpg", "fundamentos-javascript.jpg", "java-basico.jpg", "sql-mysql.jpg", "marca-personal.jpg", "terminal.jpg", "programacion-basica.jpg"], this.imgAltUrls = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14"], this.customOptions = { autoWidth: !0, loop: !0, mouseDrag: !0, touchDrag: !0, pullDrag: !0, dots: !0, navSpeed: 700, center: !0, autoplay: !0, autoplayTimeout: 5e3, navText: ["\u25c0\ufe0f", "\u25b6\ufe0f"], responsive: { 0: { items: 1 } }, nav: !0 }, e.setDefaultLang("es"), e.addLangs(["en", "es", "ru"]) } showLenguages() { this.showDropdownLanguages = !this.showDropdownLanguages } shownOptionsNavbar() { this.showNavbarMovile = !this.showNavbarMovile } setTransLanguage() { this.translate.use(this.selectLang) } getTransLanguage() { this.TransLang = [...this.translate.getLangs()] } toogleNightmode() { this.dark = !this.dark, localStorage.setItem("dark", JSON.stringify(this.dark)) } ngOnInit() { this.getTransLanguage(), $a.register(za, Ua, Wa, i2, wS, DS, am, lm, CS, xS, SS, ES, Ga, Qu, Zu, Kr, Xu, ed, a2, p2, y2, v2, S2), new $a("myChart", { type: "radar", data: { labels: ["C++", "C#", "JavaScript", "Python", "SQL", "TypeScript"], datasets: [{ label: "Back End", data: [8, 6, 7, 8, 8, 7], fill: !0, backgroundColor: "rgba(255, 99, 132, 0.2)", borderColor: "rgb(255, 99, 132)", pointBackgroundColor: "rgb(255, 99, 132)", pointBorderColor: "#fff", pointHoverBackgroundColor: "#fff", pointHoverBorderColor: "rgb(255, 99, 132)" }] }, options: { scales: { r: { angleLines: { display: !1 }, suggestedMin: 0, suggestedMax: 10 } } } }), new $a("myCharts", { type: "radar", data: { labels: ["Angular", "Bootstrap", "CSS", "HTML", "Tailwind"], datasets: [{ label: "Front End", data: [8, 6, 6, 8, 7], fill: !0, backgroundColor: "rgba(54, 162, 235, 0.2)", borderColor: "rgb(54, 162, 235)", pointBackgroundColor: "rgb(54, 162, 235)", pointBorderColor: "#fff", pointHoverBackgroundColor: "#fff", pointHoverBorderColor: "rgb(54, 162, 235)" }] }, options: { scales: { r: { angleLines: { display: !1 }, suggestedMin: 0, suggestedMax: 10 } } } }) } translateLanguage(e) { this.translate.use(e) } scroll(e) { e.scrollIntoView({ behavior: "smooth" }), this.showNavbarMovile = !1 } } return n.\u0275fac = function (e) { return new (e || n)(L(ra)) }, n.\u0275cmp = Un({ type: n, selectors: [["app-home"]], decls: 270, vars: 94, consts: [[1, "min-h-full"], [1, "sticky", "top-0", "z-50", "bg-gray-800"], [1, "max-w-7xl", "mx-auto", "px-4", "sm:px-6", "lg:px-8"], [1, "flex", "items-center", "justify-between", "h-16"], [1, "flex", "items-center"], [1, "flex-shrink-0"], ["src", "../assets/resources/public/JD.svg", "alt", "JD logo", 1, "fill-gray-400", "h-8", "w-8"], [1, "hidden", "md:block"], [1, "ml-10", "flex", "items-baseline", "space-x-4"], [1, "text-gray-300", "hover:bg-gray-700", "hover:text-white", "px-3", "py-2", "rounded-md", "text-sm", "font-medium", 3, "click"], ["routerLink", "/404", 1, "text-gray-300", "hover:bg-gray-700", "hover:text-white", "px-3", "py-2", "rounded-md", "text-sm", "font-medium"], [1, "ml-4", "flex", "items-center", "md:ml-6"], ["type", "button", 1, "bg-gray-800", "p-1", "rounded-full", "text-gray-400", "hover:text-white", "focus:outline-none", "focus:ring-2", "focus:ring-offset-2", "focus:ring-offset-gray-800", "focus:ring-white", 3, "click"], [1, "sr-only"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "2", 1, "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"], [1, "relative", "inline-block", "text-left", 3, "click"], ["class", "origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none", "role", "menu", "aria-orientation", "vertical", "aria-labelledby", "menu-button", "tabindex", "-1", 4, "ngIf"], [1, "-mr-2", "flex", "md:hidden"], ["type", "button", "aria-controls", "mobile-menu", "aria-expanded", "false", 1, "bg-gray-800", "inline-flex", "items-center", "justify-center", "p-2", "rounded-md", "text-gray-400", "hover:text-white", "hover:bg-gray-700", "focus:outline-none", "focus:ring-2", "focus:ring-offset-2", "focus:ring-offset-gray-800", "focus:ring-white", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke-width", "2", "stroke", "currentColor", "aria-hidden", "true", 1, "block", "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M4 6h16M4 12h16M4 18h16"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke-width", "2", "stroke", "currentColor", "aria-hidden", "true", 1, "hidden", "h-6", "w-6"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M6 18L18 6M6 6l12 12"], ["id", "mobile-menu", 1, "md:hidden"], ["class", "px-2 pt-2 pb-3 space-y-1 sm:px-3", 4, "ngIf"], [1, "bg-white", "dark:bg-gray-900"], [1, "grid", "max-w-screen-xl", "px-4", "pt-20", "pb-8", "mx-auto", "lg:gap-8", "xl:gap-0", "lg:py-16", "lg:grid-cols-12", "lg:pt-28"], ["aboutMe", ""], [1, "text-justify", "mr-auto", "place-self-center", "lg:col-span-7"], [1, "max-w-2xl", "mb-4", "text-4xl", "font-extrabold", "leading-none", "tracking-tight", "md:text-5xl", "xl:text-6xl", "dark:text-white"], [1, "max-w-2xl", "mb-6", "font-light", "text-gray-500", "lg:mb-8", "md:text-lg", "lg:text-xl", "dark:text-gray-400"], [1, "font-bold"], [1, "space-y-4", "sm:flex", "sm:space-y-0", "sm:space-x-4"], ["href", "https://github.com/quijadajose", 1, "inline-flex", "items-center", "justify-center", "w-full", "px-5", "py-3", "text-sm", "font-medium", "text-center", "text-gray-900", "border", "border-gray-200", "rounded-lg", "sm:w-auto", "hover:bg-gray-100", "focus:ring-4", "focus:ring-gray-100", "dark:text-white", "dark:border-gray-700", "dark:hover:bg-gray-700", "dark:focus:ring-gray-800"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 496 512", 1, "w-4", "h-4", "mr-2", "text-gray-500", "dark:text-gray-400"], ["d", "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"], ["href", "https://t.me/UNDESC0N0CID0", 1, "inline-flex", "items-center", "justify-center", "w-full", "px-5", "py-3", "text-sm", "font-medium", "text-center", "text-gray-900", "border", "border-gray-200", "rounded-lg", "sm:w-auto", "hover:bg-gray-100", "focus:ring-4", "focus:ring-gray-100", "dark:text-white", "dark:border-gray-700", "dark:hover:bg-gray-700", "dark:focus:ring-gray-800"], ["xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "fill", "currentColor", "viewBox", "0 0 16 16", 1, "bi", "bi-telegram"], ["d", "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.287 5.906c-.778.324-2.334.994-4.666 2.01-.378.15-.577.298-.595.442-.03.243.275.339.69.47l.175.055c.408.133.958.288 1.243.294.26.006.549-.1.868-.32 2.179-1.471 3.304-2.214 3.374-2.23.05-.012.12-.026.166.016.047.041.042.12.037.141-.03.129-1.227 1.241-1.846 1.817-.193.18-.33.307-.358.336a8.154 8.154 0 0 1-.188.186c-.38.366-.664.64.015 1.088.327.216.589.393.85.571.284.194.568.387.936.629.093.06.183.125.27.187.331.236.63.448.997.414.214-.02.435-.22.547-.82.265-1.417.786-4.486.906-5.751a1.426 1.426 0 0 0-.013-.315.337.337 0 0 0-.114-.217.526.526 0 0 0-.31-.093c-.3.005-.763.166-2.984 1.09z"], [1, "hidden", "lg:mt-0", "lg:col-span-5", "lg:flex"], ["loading", "lazy", "src", "../assets/resources/public/Sofware developer.svg", "alt", ""], ["skills", ""], [1, "py-12", "bg-white"], [1, "lg:text-center"], [1, "mt-2", "text-3xl", "leading-8", "font-extrabold", "tracking-tight", "text-gray-900", "sm:text-4xl"], [1, "mt-4", "max-w-2xl", "text-xl", "text-gray-500", "lg:mx-auto"], [1, "w-full", "border-b", "border-gray-400", "flex", "p-5", "last:border-b-0", "items-center"], [1, "flex", "flex-wrap", "justify-center"], ["href", "https://angular.io", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/angular.svg", "alt", "angular", "width", "40", "height", "40"], ["href", "https://www.gnu.org/software/bash/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/bash.svg", "alt", "bash", "width", "40", "height", "40"], ["href", "https://getbootstrap.com", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/bootstrap.svg", "alt", "bootstrap", "width", "40", "height", "40"], ["href", "https://www.w3schools.com/cpp/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/cplusplus.svg", "alt", "cplusplus", "width", "40", "height", "40"], ["href", "https://www.w3schools.com/cs/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/csharp.svg", "alt", "csharp", "width", "40", "height", "40"], ["href", "https://www.w3schools.com/css/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/css3.svg", "alt", "css3", "width", "40", "height", "40"], ["href", "https://dotnet.microsoft.com/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/dot-net.svg", "alt", "dotnet", "width", "40", "height", "40"], ["href", "https://expressjs.com", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/express.svg", "alt", "express", "width", "40", "height", "40"], ["href", "https://git-scm.com/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/git.svg", "alt", "git", "width", "40", "height", "40"], ["href", "https://www.w3.org/html/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/html5.svg", "alt", "html5", "width", "40", "height", "40"], ["href", "https://www.adobe.com/in/products/illustrator.html", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/illustrator.svg", "alt", "illustrator", "width", "40", "height", "40"], ["href", "https://www.java.com", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/Java.svg", "alt", "java", "width", "40", "height", "40"], ["href", "https://developer.mozilla.org/en-US/docs/Web/JavaScript", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/javascript.svg", "alt", "javascript", "width", "40", "height", "40"], ["href", "https://www.linux.org/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/linux.svg", "alt", "linux", "width", "40", "height", "40"], ["href", "https://mariadb.org/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/mariadb.svg", "alt", "mariadb", "width", "40", "height", "40"], ["href", "https://www.mysql.com/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/mysql.svg", "alt", "mysql", "width", "40", "height", "40"], ["href", "https://nodejs.org", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/nodejs.svg", "alt", "nodejs", "width", "40", "height", "40"], ["href", "https://www.photoshop.com/en", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/photoshop.svg", "alt", "photoshop", "width", "40", "height", "40"], ["href", "https://www.php.net", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/php.svg", "alt", "php", "width", "40", "height", "40"], ["href", "https://www.postgresql.org", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/postgresql.svg", "alt", "postgresql", "width", "40", "height", "40"], ["href", "https://postman.com", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/postman.svg", "alt", "postman", "width", "40", "height", "40"], ["href", "https://www.python.org", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/python.svg", "alt", "python", "width", "40", "height", "40"], ["href", "https://www.sqlite.org/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/sqlite.svg", "alt", "sqlite", "width", "40", "height", "40"], ["href", "https://tailwindcss.com/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/tailwindcss.svg", "alt", "tailwind", "width", "40", "height", "40"], ["href", "https://www.typescriptlang.org/", "target", "_blank", "rel", "noreferrer"], ["src", "../../assets/resources/public/tecnologis/skills/typescript.svg", "alt", "typescript", "width", "40", "height", "40"], [1, "mt-10"], [1, "space-y-10", "md:space-y-0", "md:grid", "md:grid-cols-2", "md:gap-x-8", "md:gap-y-10"], [1, "relative"], ["id", "myChart", "width", "400", "height", "400"], [1, "absolute", "flex", "items-center", "justify-center", "h-12", "w-12", "rounded-md", "bg-red-500", "text-white"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4"], [1, "ml-16", "text-lg", "leading-6", "font-medium", "text-gray-900"], [1, "mt-2", "ml-16", "text-base", "text-gray-500"], ["id", "myCharts", "width", "400", "height", "400"], [1, "absolute", "flex", "items-center", "justify-center", "h-12", "w-12", "rounded-md", "bg-blue-500", "text-white"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"], ["certificates", ""], [1, "text-center", "mb-4", "text-3xl", "font-extrabold", "tracking-tight", "text-gray-900", "dark:text-white"], [1, "flex", "justify-center"], [1, "w-9/12", "h-9/12", "lg:w-6/12", "lg:h-6/12"], [3, "options"], [4, "ngFor", "ngForOf"], ["projects", ""], [1, "pt-12", "bg-gray-50", "dark:bg-gray-800"], [1, "max-w-screen-xl", "px-4", "py-8", "mx-auto", "space-y-12", "lg:space-y-20", "lg:py-21", "lg:px-6"], [1, "items-center", "gap-8", "lg:grid", "lg:grid-cols-2", "xl:gap-16", "sm:grid-cols-12"], [1, "text-gray-500", "sm:text-lg", "dark:text-gray-400"], [1, "mb-4", "text-3xl", "font-extrabold", "tracking-tight", "text-gray-900", "dark:text-white"], [1, "mb-8", "font-light", "lg:text-xl"], ["role", "list", 1, "pt-8", "space-y-5", "border-t", "border-gray-200", "my-7", "dark:border-gray-700"], [1, "flex", "space-x-3"], ["fill", "currentColor", "viewBox", "0 0 20 20", "xmlns", "http://www.w3.org/2000/svg", 1, "flex-shrink-0", "w-5", "h-5", "text-green-500", "dark:text-green-400"], ["fill-rule", "evenodd", "d", "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z", "clip-rule", "evenodd"], [1, "text-base", "font-medium", "leading-tight", "text-gray-900", "dark:text-white"], ["routerLink", "/lvs", 1, "inline-flex", "items-center", "justify-center", "w-full", "px-5", "py-3", "text-sm", "font-medium", "text-center", "text-gray-900", "border", "border-gray-200", "rounded-lg", "sm:w-auto", "hover:bg-gray-100", "focus:ring-4", "focus:ring-gray-100", "dark:text-white", "dark:border-gray-700", "dark:hover:bg-gray-700", "dark:focus:ring-gray-800"], ["src", "../assets/resources/public/LVS/LogoLogin.png", "alt", "LVS Logo", 1, "w-10", "h-6", "mr-2", "text-gray-500", "dark:text-gray-400"], ["loading", "lazy", "src", "../assets/resources/public/LVS/Login and register.gif", "alt", "", 1, "w-full", "mb-4", "rounded-lg", "lg:mb-0", "lg:flex"], [1, "items-center", "gap-8", "lg:grid", "lg:grid-cols-2", "xl:gap-16"], ["src", "../assets/resources/public/medicom/Login.jpeg", "alt", "feature image 2", 1, "hidden", "w-full", "mb-4", "rounded-lg", "lg:mb-0", "lg:flex"], ["fill", "currentColor", "viewBox", "0 0 20 20", "xmlns", "http://www.w3.org/2000/svg", 1, "flex-shrink-0", "w-5", "h-5", "text-blue-500", "dark:text-blue-400"], ["fill", "currentColor", "viewBox", "0 0 20 20", "xmlns", "http://www.w3.org/2000/svg", 1, "flex-shrink-0", "w-5", "h-5", "text-blue-500", "dark:text-blue-500"], ["routerLink", "/medicom", 1, "inline-flex", "items-center", "justify-center", "w-full", "px-5", "py-3", "text-sm", "font-medium", "text-center", "text-gray-900", "border", "border-gray-200", "rounded-lg", "sm:w-auto", "hover:bg-gray-100", "focus:ring-4", "focus:ring-gray-100", "dark:text-white", "dark:border-gray-700", "dark:hover:bg-gray-700", "dark:focus:ring-gray-800"], ["loading", "lazy", "src", "../assets/resources/public/medicom/logo.png", "alt", "Medicom Logo", 1, "w-10", "h-10", "mr-2", "text-gray-500", "dark:text-gray-400"], ["role", "menu", "aria-orientation", "vertical", "aria-labelledby", "menu-button", "tabindex", "-1", 1, "origin-top-right", "absolute", "right-0", "mt-2", "w-56", "rounded-md", "shadow-lg", "bg-white", "ring-1", "ring-black", "ring-opacity-5", "focus:outline-none"], ["role", "none", 1, "py-1"], [1, "flex", "items-center", "px-3", "py-3", "text-sm", "text-gray-600", "capitalize", "transition-colors", "duration-200", "transform", "dark:text-gray-300", "hover:bg-gray-100", "dark:hover:bg-gray-700", "dark:hover:text-white", 3, "click"], ["src", "../assets/resources/public/flags/spain.svg", "alt", "russia", 1, "h-5"], [1, "mx-1"], [1, "flex", "items-center", "p-3", "text-sm", "text-gray-600", "capitalize", "transition-colors", "duration-200", "transform", "dark:text-gray-300", "hover:bg-gray-100", "dark:hover:bg-gray-700", "dark:hover:text-white", 3, "click"], ["src", "../assets/resources/public/flags/english.svg", "alt", "russia", 1, "h-5"], ["src", "../assets/resources/public/flags/russia.svg", "alt", "russia", 1, "h-5"], [1, "px-2", "pt-2", "pb-3", "space-y-1", "sm:px-3"], [1, "text-gray-300", "hover:bg-gray-700", "hover:text-white", "block", "px-3", "py-2", "rounded-md", "text-base", "font-medium", 3, "click"], ["routerLink", "/404", 1, "text-gray-300", "hover:bg-gray-700", "hover:text-white", "block", "px-3", "py-2", "rounded-md", "text-base", "font-medium"], ["carouselSlide", ""], [1, ""], [1, "border", "rounded", 3, "src"]], template: function (e, i) { if (1 & e) { const s = Ds(); _(0, "div", 0)(1, "nav", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5), C(6, "img", 6), w(), _(7, "div", 7)(8, "div", 8)(9, "a", 9), Pe("click", function () { xt(s); const o = gi(43); return Ct(i.scroll(o)) }), I(10), R(11, "translate"), w(), _(12, "a", 9), Pe("click", function () { xt(s); const o = gi(72); return Ct(i.scroll(o)) }), I(13), R(14, "translate"), w(), _(15, "a", 9), Pe("click", function () { xt(s); const o = gi(187); return Ct(i.scroll(o)) }), I(16), R(17, "translate"), w(), _(18, "a", 9), Pe("click", function () { xt(s); const o = gi(197); return Ct(i.scroll(o)) }), I(19), R(20, "translate"), w(), _(21, "a", 10), I(22, "404"), w()()()(), _(23, "div", 7)(24, "div", 11)(25, "button", 12), Pe("click", function () { return i.showLenguages() }), _(26, "span", 13), I(27), R(28, "translate"), w(), Je(), _(29, "svg", 14), C(30, "path", 15), w()(), yt(), _(31, "div", 16), Pe("click", function () { return i.showLenguages() }), jt(32, aV, 17, 9, "div", 17), w()()(), _(33, "div", 18)(34, "button", 19), Pe("click", function () { return i.shownOptionsNavbar() }), Je(), _(35, "svg", 20), C(36, "path", 21), w(), _(37, "svg", 22), C(38, "path", 23), w()()()()(), yt(), _(39, "div", 24), jt(40, lV, 15, 12, "div", 25), w()(), _(41, "section", 26)(42, "div", 27, 28)(44, "div", 29)(45, "h1", 30), I(46), R(47, "translate"), C(48, "br"), w(), _(49, "p", 31), I(50), R(51, "translate"), _(52, "span", 32), I(53), R(54, "translate"), w(), I(55), R(56, "translate"), w(), _(57, "div", 33)(58, "a", 34), Je(), _(59, "svg", 35), C(60, "path", 36), w(), I(61), R(62, "translate"), w()(), yt(), _(63, "div", 33)(64, "a", 37), Je(), _(65, "svg", 38), C(66, "path", 39), w(), I(67), R(68, "translate"), w()()(), yt(), _(69, "div", 40), C(70, "img", 41), w()()(), _(71, "section", null, 42)(73, "div", 43)(74, "div", 2)(75, "div", 44)(76, "p", 45), I(77), R(78, "translate"), w(), _(79, "p", 46), I(80), R(81, "translate"), w(), _(82, "h3"), I(83), R(84, "translate"), w(), _(85, "div", 47)(86, "div", 48)(87, "div")(88, "a", 49), C(89, "img", 50), w()(), _(90, "div")(91, "a", 51), C(92, "img", 52), w()(), _(93, "div")(94, "a", 53), C(95, "img", 54), w()(), _(96, "div")(97, "a", 55), C(98, "img", 56), w()(), _(99, "div")(100, "a", 57), C(101, "img", 58), w()(), _(102, "div")(103, "a", 59), C(104, "img", 60), w()(), _(105, "div")(106, "a", 61), C(107, "img", 62), w()(), _(108, "div")(109, "a", 63), C(110, "img", 64), w()(), _(111, "div")(112, "a", 65), C(113, "img", 66), w()(), _(114, "div")(115, "a", 67), C(116, "img", 68), w()(), _(117, "div")(118, "a", 69), C(119, "img", 70), w()(), _(120, "div")(121, "a", 71), C(122, "img", 72), w()(), _(123, "div")(124, "a", 73), C(125, "img", 74), w()(), _(126, "div")(127, "a", 75), C(128, "img", 76), w()(), _(129, "div")(130, "a", 77), C(131, "img", 78), w()(), _(132, "div")(133, "a", 79), C(134, "img", 80), w()(), _(135, "div")(136, "a", 81), C(137, "img", 82), w()(), _(138, "div")(139, "a", 83), C(140, "img", 84), w()(), _(141, "div")(142, "a", 85), C(143, "img", 86), w()(), _(144, "div")(145, "a", 87), C(146, "img", 88), w()(), _(147, "div")(148, "a", 89), C(149, "img", 90), w()(), _(150, "div")(151, "a", 91), C(152, "img", 92), w()(), _(153, "div")(154, "a", 93), C(155, "img", 94), w()(), _(156, "div")(157, "a", 95), C(158, "img", 96), w()(), _(159, "div")(160, "a", 97), C(161, "img", 98), w()()()()(), _(162, "div", 99)(163, "dl", 100)(164, "div", 101), C(165, "canvas", 102), _(166, "dt")(167, "div", 103), Je(), _(168, "svg", 14), C(169, "path", 104), w()(), yt(), _(170, "p", 105), I(171, "Back-End"), w()(), _(172, "dd", 106), I(173), R(174, "translate"), w()(), _(175, "div", 101), C(176, "canvas", 107), _(177, "dt")(178, "div", 108), Je(), _(179, "svg", 14), C(180, "path", 109), w()(), yt(), _(181, "p", 105), I(182, "Front-end"), w()(), _(183, "dd", 106), I(184), R(185, "translate"), w()()()()()()(), _(186, "section", null, 110)(188, "div")(189, "h2", 111), I(190), R(191, "translate"), w()(), _(192, "div", 112)(193, "div", 113)(194, "owl-carousel-o", 114), jt(195, uV, 1, 0, null, 115), w()()()(), _(196, "section", null, 116)(198, "section", 117)(199, "h2", 111), I(200), R(201, "translate"), w(), _(202, "div", 118)(203, "div", 119)(204, "div", 120)(205, "h2", 121), I(206), R(207, "translate"), w(), _(208, "p", 122), I(209), R(210, "translate"), w(), _(211, "ul", 123)(212, "li", 124), Je(), _(213, "svg", 125), C(214, "path", 126), w(), yt(), _(215, "span", 127), I(216), R(217, "translate"), w()(), _(218, "li", 124), Je(), _(219, "svg", 125), C(220, "path", 126), w(), yt(), _(221, "span", 127), I(222), R(223, "translate"), w()(), _(224, "li", 124), Je(), _(225, "svg", 125), C(226, "path", 126), w(), yt(), _(227, "span", 127), I(228), R(229, "translate"), w()()(), _(230, "div", 33)(231, "a", 128), C(232, "img", 129), I(233), R(234, "translate"), w()()(), C(235, "img", 130), w(), _(236, "div", 131)(237, "div"), C(238, "img", 132), w(), _(239, "div", 120)(240, "h2", 121), I(241), R(242, "translate"), w(), _(243, "p", 122), I(244), R(245, "translate"), w(), _(246, "ul", 123)(247, "li", 124), Je(), _(248, "svg", 133), C(249, "path", 126), w(), yt(), _(250, "span", 127), I(251), R(252, "translate"), w()(), _(253, "li", 124), Je(), _(254, "svg", 133), C(255, "path", 126), w(), yt(), _(256, "span", 127), I(257), R(258, "translate"), w()(), _(259, "li", 124), Je(), _(260, "svg", 134), C(261, "path", 126), w(), yt(), _(262, "span", 127), I(263), R(264, "translate"), w()()(), _(265, "div", 33)(266, "a", 135), C(267, "img", 136), I(268), R(269, "translate"), w()()()()()()()() } 2 & e && (M(10), q(O(11, 34, "startingpage.navbar2")), M(3), q(O(14, 36, "startingpage.navbar6")), M(3), q(O(17, 38, "startingpage.navbar3")), M(3), q(O(20, 40, "startingpage.navbar4")), M(8), q(O(28, 42, "startingpage.navbar5")), M(5), De("ngIf", i.showDropdownLanguages), M(8), De("ngIf", i.showNavbarMovile), M(6), fe(" ", O(47, 44, "startingpage.shortdescription"), ""), M(4), fe(" ", O(51, 46, "startingpage.mynameis"), ""), M(3), q(O(54, 48, "startingpage.name")), M(2), fe("", O(56, 50, "startingpage.description"), "."), M(6), fe(" ", O(62, 52, "startingpage.github"), " "), M(6), fe(" ", O(68, 54, "startingpage.telegram"), " "), M(10), fe(" ", O(78, 56, "startingpage.navbar6"), ""), M(3), fe("", O(81, 58, "startingpage.skillsdescription"), " "), M(3), q(O(84, 60, "startingpage.languages")), M(90), q(O(174, 62, "startingpage.backend")), M(11), q(O(185, 64, "startingpage.frontend")), M(6), fe(" ", O(191, 66, "startingpage.navbar3"), " "), M(4), De("options", i.customOptions), M(1), De("ngForOf", i.imgUrls), M(5), fe(" ", O(201, 68, "startingpage.navbar4"), " "), M(6), fe(" ", O(207, 70, "startingpage.title1lvs"), ""), M(3), q(O(210, 72, "startingpage.descriptionlvs")), M(7), q(O(217, 74, "startingpage.multiplatform")), M(6), q(O(223, 76, "startingpage.security")), M(6), q(O(229, 78, "startingpage.sql")), M(5), fe(" ", O(234, 80, "startingpage.seedetails"), " "), M(8), fe(" ", O(242, 82, "startingpage.title1medicom"), ""), M(3), q(O(245, 84, "startingpage.descriptionmedicom")), M(7), q(O(252, 86, "startingpage.multiplatform")), M(6), q(O(258, 88, "startingpage.security")), M(6), q(O(264, 90, "startingpage.sql")), M(5), fe(" ", O(269, 92, "startingpage.seedetails"), " ")) }, dependencies: [Zo, Sc, fC, jg, yu, Xc] }), n })() }, { path: "lvs", component: w6 }, { path: "medicom", component: D6 }, { path: "**", pathMatch: "full", component: m6 }]; let hV = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n }), n.\u0275inj = Xt({ imports: [fp, Hx.forRoot(dV), Hx] }), n })(), fV = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = un({ type: n, bootstrap: [b8] }), n.\u0275inj = Xt({ imports: [kw, g6, WF, L8, nN.forRoot({ loader: { provide: sa, useFactory: pV, deps: [Xx] } }), hV] }), n })(); function pV(n) { return new w8(n) } (function wR() { if (Pb) throw new Error("Cannot enable prod mode after platform setup."); Ib = !1 })(), R4().bootstrapModule(fV).catch(n => console.error(n)) } }, Ce => { Ce(Ce.s = 196) }]);